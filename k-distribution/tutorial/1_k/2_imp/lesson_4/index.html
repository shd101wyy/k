<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <!-- Copyright (c) 2010-2019 K Team. All Rights Reserved. --><html><head></head><body><h1 id="configuration-abstraction%2C-part-1%3B-types-of-rules">Configuration Abstraction, Part 1; Types of Rules</h1>
<p>Here we will complete the K definition of IMP and, while doing so, we will<br>
learn the very first step of what we call <em>configuration abstraction</em>, and<br>
the semantic distinction between structural and computational rules.</p>
<h2 id="the-imp-semantic-rules">The IMP Semantic Rules</h2>
<p>Let us add the remaining rules, in the order in which the language constructs<br>
were defined in IMP-SYNTAX.</p>
<p>The rules for the arithmetic and Boolean constructs are self-explanatory.<br>
Note, however, that K will infer the correct sorts of all the variables in<br>
these rules, because they appear as arguments of the builtin operations<br>
(<code>_+Int_</code>, etc.). Moreover, the inferred sorts will be enforced dynamically.<br>
Indeed, we do not want to apply the rule for addition, for example, when the<br>
two arguments are not integers. In the rules for <code>&amp;&amp;</code>, although we prefer to<br>
not do it here for simplicity, we could have eliminated the dynamic check by<br>
replacing <code>B</code> (and similarly for <code>_</code>) with <code>B:K</code>. Indeed, it can be shown<br>
that whenever any of these rules apply, <code>B</code> (or <code>_</code>) is a <code>BExp</code> anyway.<br>
That&apos;s because there is no rule that can touch such a <code>B</code> (or <code>_</code>); this<br>
will become clearer shortly, when we discuss the first step of configuration<br>
abstraction. Therefore, since we know that <code>B</code> will be a <code>BExp</code> anyway, we<br>
could save the time it takes to check its sort; such times may look minor,<br>
but they accumulate, so some designers may prefer to avoid run-time checks<br>
whenever possible.</p>
<p>The block rules are trivial. However, the rule for non-empty blocks is<br>
semantically correct only because we do not have local variable declarations<br>
in IMP. We will have to change this rule in IMP++.</p>
<p>The assignment rule has two <code>=&gt;</code>: one in the <code>k</code> cell dissolving the<br>
assignment statement, and the other in the <code>state</code> cell updating the value of<br>
the assigned variable. Note that the one in the <code>state</code> is surrounded by<br>
parentheses: <code>(_ =&gt; I)</code>. That is because <code>=&gt;</code> is greedy: it matches as much<br>
as it can to the left and to the right, until it reaches the cell boundaries<br>
(closed or open). If you want to limit its scope, or for clarity, you can use<br>
parentheses like here.</p>
<p>The rule for sequential composition simply desugars <code>S1 S2</code> into <code>S1 ~&gt; S2</code>.<br>
Indeed, the two have exactly the same semantics. Note that statements<br>
<em>evaluate</em> to nothing (<code>.</code>), so once <code>S1</code> is processed in <code>S1 ~&gt; S2</code>, then the<br>
next task is automatically <code>S2</code>, without wasting any step for the transition.</p>
<p>The rules for the conditional and while statements are clear. One thing to<br>
keep in mind now is that the <code>while</code> unrolling rule will not apply<br>
indefinitely in the positive branch of the resulting conditional, because<br>
of K&apos;s configuration abstraction, which will be discussed shortly.</p>
<p>An IMP program declares a set of variables and then executes a<br>
statement in the state obtained after initializing all those variables<br>
to <code>0</code>. The rules for programs initialize the declared variables one by one,<br>
checking also that there are no duplicates. We check for duplicates only for<br>
demonstration purposes, to illustrate the <code>keys</code> predefined operation that<br>
returns the set of keys of a map, and the set membership operation <code>in</code>.<br>
In practice, we typically define a static type checker for our language,<br>
which we execute before the semantics and reject inappropriate programs.</p>
<p>The use of the <code>.Ids</code> in the second rule is not necessary. We could have<br>
written <code>int; S</code> instead of <code>int .Ids; S</code> and the K tool would parse it and<br>
kompile the definition correctly, because it uses the same parser used for<br>
parsing programs also to parse the semantics. However, we typically prefer to<br>
explicitly write the <em>nothing</em> values in the semantics, for clarity;<br>
the parser has been extended to accept these. Note that the first rule<br>
matches the entire <code>k</code> cell, because <code>int_;_</code> is the top-level program<br>
construct in IMP, so there is nothing following it in the computation cell.<br>
The anonymous variable stands for the second argument of this top-level program<br>
construct, not for the rest of the computation. The second rule could have<br>
also been put in a complete <code>k</code> cell, but we preferred not to, for simplicity.</p>
<p>Our IMP semantics is now complete, but there are a few more things that we<br>
need to understand and do.</p>
<h2 id="configuration-abstraction%2C-part-1">Configuration Abstraction, Part 1</h2>
<p>First, let us briefly discuss the very first step of configuration abstraction.<br>
In K, all semantic rules are in fact rules between configurations. As soon<br>
explained in the IMP++ tutorial, the declared configuration cell structure is<br>
used to automatically complete the missing configuration parts in rules.<br>
However, many rules do not involve any cells, being rules between syntactic<br>
terms (of sort <code>K</code>); for example, we had only three rules involving cells in our<br>
IMP semantics. In this case, the <code>k</code> cell will be added automatically and the<br>
actual rewrite will happen on top of the enclosed computation. For example,<br>
the rule for the <code>while</code> loop is automatically translated into the following:</p>
<pre><code>rule &lt;k&gt; while (B) S =&gt; if (B) {S while (B) S} else {} ...&lt;/k&gt;
</code></pre>
<p>Since the first task in computations is what needs to be done next, the<br>
intuition for this rule completion is that the syntactic transition<br>
only happens when the term to rewrite is ready for processing. This explains,<br>
for example, why the while loop unrolling does not indefinitely apply in the<br>
positive branch of the conditional: the inner while loop is not ready for<br>
evaluation yet. We call this rule completion process, as well as other<br>
similar ones, <em>configuration abstraction</em>. That is because the incomplete<br>
rule abstracts away the configuration structure, thus being easier to read.<br>
As seen soon when we define IMP++, configuration abstraction is not only a<br>
user convenience; it actually significantly increases the modularity of our<br>
definitions. The k-cell-completion is only the very first step, though.</p>
<p>If you really want certain rewrites over syntactic terms to apply<br>
anywhere they match, then you should tag the rule with the attribute<br>
<code>anywhere</code>, which was discussed in Tutorial 1, Lesson 2.5.</p>
<h2 id="structural-vs.-computational-rules">Structural vs. Computational Rules</h2>
<p>The K rules are of two types: structural and computational. Intuitively,<br>
structural rules rearrange the configuration so that computational rules can<br>
apply. Structural rules therefore do not count as computational steps. A K<br>
semantics can be thought of as a generator of transition systems, one for each<br>
program. It is only the computational rules that create steps, or transitions,<br>
in the corresponding transition system, the structural rules being unobservable<br>
at this level. By default, rules are all assumed computational, except for<br>
the implicit heating/cooling rules that define evaluation strategies of<br>
language constructs, which are assumed structural. If you want to explicitly<br>
make a rule structural, then you should include the tag (or attribute)<br>
<code>structural</code> in square brackets right after the rule. These attributes may be<br>
taken into account by different K tools, so it is highly recommended to spend<br>
a moment or two after each rule and think whether you want it to be structural<br>
or computational.</p>
<p>Let us do it. We want the lookup and the arithmetic and Boolean construct<br>
rules to be computational, because they make computational progress whenever<br>
they apply. However, the block rules can be very well structural, because<br>
we can regard them simply as syntactic grouping constructs. In general,<br>
we want to have as few computational rules as possible, because we want<br>
the resulting transition systems to be smaller for analysis purposes, but not<br>
too few to lose behaviors. For example, making the block rules structural<br>
loses no meaningful behaviors. Similarly, the sequential composition,<br>
the while loop unrolling, and the no-variable declaration rules can all<br>
safely be structural.</p>
<p>Kompile and then krun the programs that you only parsed in Lesson 1. They<br>
should all execute as expected. The state cell shows the final state<br>
of the program. The <code>k</code> cell shows the final code contents, which should be<br>
empty whenever the IMP program executes correctly.</p>
<p>Kompile also with the documentation option and take a look at the generated<br>
documentation. The assignment rule should particularly be of interest,<br>
because it contains two local rewrites.</p>
<p>In the next lesson we comment the IMP definition and conclude this tutorial.</p>
<p>Go to <a href="../lesson_5/">Lesson 5, IMP: Completing and Documenting IMP</a>.</p>
<p><a href="http://youtu.be/fR2VEfGHtho" target="_blank" rel="noopener">MOVIE (out of date) [09&apos;16&quot;]</a></p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
