<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1 id="imp%2B%2B">IMP++</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<h3 id="abstract">Abstract</h3>
<p>This is the <strong>K</strong> semantic definition of the IMP++ language.<br>
IMP++ extends the IMP language with the features listed below. We<br>
strongly recommend you to first familiarize yourself with the IMP<br>
language and its <strong>K</strong> definition in Tutorial 2 before proceeding.</p>
<p><strong>Strings and concatenation of strings.</strong> Strings are useful<br>
for the <code>print</code> statement, which is discussed below. For<br>
string concatenation, we use the same <code>+</code> construct that we use<br>
for addition (so we overload it).</p>
<p><strong>Variable increment.</strong> We only add a pre-increment construct:<br>
<code>++x</code> increments variable <code>x</code> and evaluates to the<br>
incremented value. Variable increment makes the evaluation of<br>
expressions have side effects, and thus makes the evaluation strategies<br>
of the various language constructs have an influence on the set<br>
of possible program behaviors.</p>
<p><strong>Input and output.</strong> IMP++ adds a <code>read()</code> expression<br>
construct which reads an integer number and evaluates to it, and<br>
a variadic (i.e., it has an arbitrary number of arguments) statement<br>
construct <code>print(e1,e2,...,en)</code> which evaluates its arguments<br>
and then outputs their values. Note that the <strong>K</strong> tool allows to<br>
connect the input and output cells to the standard input and output<br>
buffers, this way compiling the language definition into an<br>
interactive interpreter.</p>
<p><strong>Abrupt termination.</strong> The <code>halt</code> statement simply halts<br>
the program. The <strong>K</strong> tool shows the resulting configuration, as if the<br>
program terminated normally. We therefore assume that an external<br>
observer does not care whether the program terminates normally or<br>
abruptly, same like with <code>exit</code> statements in conventional<br>
programming languages like C.</p>
<p><strong>Dynamic threads.</strong> The expression construct <code>spawn s</code><br>
starts a new concurrent thread that executes statement <code>s</code>,<br>
which is expected to be a block, and evaluates immediately to a fresh<br>
thread identifier that is also assigned to the newly created thread.<br>
The new thread is given at creation time the <code>environment</code> of its<br>
parent, so it can access all its parent&apos;s variables. This allows for<br>
the parent thread, and the child thread to communicate; it also allows<br>
for races and &quot;unexpected&quot; behaviors, so be careful.<br>
For thread synchronization, IMP++ provides a thread join statement<br>
construct <code>join t;</code>, where <code>t</code> evaluates to a thread<br>
identifier, which stalls the current thread until thread <code>t</code><br>
completes its computation. For simplicity, we here assume a<br>
sequentially consistent shared memory model. To experiment with other<br>
memory models, see the definition of KERNELC.</p>
<p><strong>Blocks and local variables.</strong> IMP++ allows blocks enclosed by<br>
curly brackets. Also, IMP&apos;s global variable declaration construct is<br>
generalized to be used anywhere as a statement, not only at the<br>
beginning of the program. As expected, the scope of the declared<br>
variables is from their declaration point till the end of the most<br>
nested enclosing block.</p>
<h3 id="what-you-will-learn-here">What You Will Learn Here</h3>
<ul>
<li>How to define a less trivial language in <strong>K</strong>, as explained above.</li>
<li>How to use the <code>superheat</code> and <code>supercool</code><br>
options of the <strong>K</strong> tool <code>kompile</code> to exhaustively explore the<br>
non-determinism due to underspecified evaluation strategies.</li>
<li>How to use the <code>transition</code> option of the <strong>K</strong> tool to<br>
exhaustively explore the non-determinism due to concurrency.</li>
<li>How to connect certain cells in the configuration to the<br>
standard input and standard output, and thus turn the <code>krun</code><br>
tool into an interactive interpreter for the defined language.</li>
<li>How to exhaustively search for the non-deterministic behaviors<br>
of a program using the <code>search</code> option of <code>krun</code>.</li>
</ul>
<pre class="language-k"><code><span class="token keyword">module</span> IMP<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</code></pre>
<h3 id="syntax">Syntax</h3>
<p>IMP++ adds several syntactic constructs to IMP. Also, since the<br>
variable declaration construct is generalized to be used anywhere a<br>
statement can be used, not only at the beginning of the program, we<br>
need to remove the previous global variable declaration of IMP and<br>
instead add a variable declaration statement construct</p>
<p>We do not re-discuss the constructs which are taken over from IMP,<br>
except when their syntax has been subtly modified (such as, for<br>
example, the syntax of the previous &quot;statement&quot; assignment which<br>
is now obtained by composing the new assignment expression, and the<br>
new expression statement constructs); go the last lesson of<br>
Tutorial 2 if you are interested in IMP&apos;s constructs. For execution<br>
purposes, we tag the addition and division operations with the<br>
<code>addition</code> and <code>division</code> tags. These attributes have<br>
no theoretical significance, in that they do not affect the semantics<br>
of the language in any way. They only have practical relevance,<br>
specific to our implementation of the <strong>K</strong> tool. Specifically, we can<br>
tell the <strong>K</strong> tool (using its <code>superheat</code> and <code>supercool</code><br>
options) that we want to exhaustively explore all the non-deterministic<br>
behaviors (due to strictness) of these language constructs. For performance<br>
reasons, by default the <strong>K</strong> tool chooses an arbitrary but fixed order to<br>
evaluate the arguments of the strict language constructs, thus possibly<br>
losing behaviors due to missed interleavings. This aspect was irrelevant in<br>
IMP, because its expressions had no side effects, but it becomes relevant<br>
in IMP++.</p>
<p>The syntax of the IMP++ constructs is self-explanatory. Note that assignment<br>
is now an expression construct. Also, <code>print</code> is variadic, taking a<br>
list of expressions as argument. It is also strict, which means that the<br>
entire list of expressions, that is, each expression in the list, will be<br>
evaluated. Note also that we have now defined sequential composition<br>
of statements as a whitespace-separated list of statements, aliased with<br>
the nonterminal <code>Stmts</code>, and block as such a (possibly empty) sequence<br>
of statements surrounded by curly brackets.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> AExp  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">String</span> <span class="token operator">|</span> <span class="token keyword">Id</span>
                 <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> <span class="token keyword">Id</span>
                 <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> AExp                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                 <span class="token operator">&gt;</span> AExp <span class="token string">&quot;/&quot;</span> AExp              <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">,</span> division<span class="token punctuation">]</span>
                 <span class="token operator">&gt;</span> AExp <span class="token string">&quot;+&quot;</span> AExp              <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">]</span>
                 <span class="token operator">&gt;</span> <span class="token string">&quot;spawn&quot;</span> Block
                 <span class="token operator">&gt;</span> <span class="token keyword">Id</span> <span class="token string">&quot;=&quot;</span> AExp                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> AExp <span class="token string">&quot;)&quot;</span>               <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> BExp  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Bool</span>
                 <span class="token operator">|</span> AExp <span class="token string">&quot;&lt;=&quot;</span> AExp             <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">,</span> <span class="token class-name">latex</span><span class="token punctuation">(</span><span class="token punctuation">{</span>#<span class="token number">1</span><span class="token punctuation">}</span>\leq<span class="token punctuation">{</span>#<span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;!&quot;</span> BExp                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                 <span class="token operator">&gt;</span> BExp <span class="token string">&quot;&amp;&amp;&quot;</span> BExp             <span class="token punctuation">[</span><span class="token class-name">left</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> BExp <span class="token string">&quot;)&quot;</span>               <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> Stmts <span class="token string">&quot;}&quot;</span>
  <span class="token keyword">syntax</span> Stmt  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Block
                 <span class="token operator">|</span> AExp <span class="token string">&quot;;&quot;</span>                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> BExp <span class="token string">&quot;)&quot;</span>
                   Block <span class="token string">&quot;else&quot;</span> Block         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> BExp <span class="token string">&quot;)&quot;</span> Block
                 <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> Ids <span class="token string">&quot;;&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> AExps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>
                 <span class="token operator">|</span> <span class="token string">&quot;halt&quot;</span> <span class="token string">&quot;;&quot;</span>
                 <span class="token operator">&gt;</span> <span class="token string">&quot;join&quot;</span> AExp <span class="token string">&quot;;&quot;</span>            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>

  <span class="token keyword">syntax</span> Ids   <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> AExps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>AExp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Stmt<span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> AExps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Ids
<span class="token keyword">endmodule</span>


<span class="token keyword">module</span> IMP
  <span class="token keyword">imports</span> IMP<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> DOMAINS
</code></pre>
<h3 id="semantics">Semantics</h3>
<p>We next give the semantics of IMP++. We start by first defining its<br>
configuration.</p>
<h4 id="configuration">Configuration</h4>
<p>The original configuration of IMP has been extended to include<br>
all the various additional cells needed for IMP++.<br>
To facilitate the semantics of threads, more specifically<br>
to naturally give them access to their parent&apos;s variables, we prefer a<br>
(rather conventional) split of the program state into an<br>
<code>environment</code> and a <code>store</code>. An environment maps<br>
variable names into <code>locations</code>, while a store maps locations<br>
into values. Stores are also sometimes called <code>states</code>, or<br>
<code>heaps</code>, or <code>memory</code>, in the literature. Like values, locations<br>
can be anything. For simplicity, here we assume they are natural<br>
numbers. Moreover, each thread has its own environment, so it knows<br>
where all the variables that it has access to are located in the store<br>
(that includes its locally declared variables as well as the variables<br>
of its parent thread), and its own unique identifier. The store is<br>
shared by all threads. For simplicity, we assume a sequentially consistent<br>
memory model in IMP++. Note that the <code>thread</code> cell has multiplicity<br>
<code>*</code>, meaning that there could be zero, one, or more instances of that cell<br>
in the configuration at any given time. This multiplicity information<br>
is important for <strong>K</strong>&apos;s <em>configuration abstraction</em> process: it tells<br>
<strong>K</strong> how to complete rules which, in order to increase the modularity of the<br>
definition, choose to not mention the entire configuration context.<br>
The <code>in</code> and <code>out</code> cells hold the input and the output<br>
buffers as lists of items.</p>
<pre class="language-k"><code>  <span class="token keyword">configuration</span> <span class="token operator">&lt;</span>T color<span class="token operator">=</span><span class="token string">&quot;yellow&quot;</span><span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>threads color<span class="token operator">=</span><span class="token string">&quot;orange&quot;</span><span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>thread multiplicity<span class="token operator">=</span><span class="token string">&quot;*&quot;</span> color<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span><span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>k color<span class="token operator">=</span><span class="token string">&quot;green&quot;</span><span class="token operator">&gt;</span> $PGM<span class="token punctuation">:</span>Stmts <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>env color<span class="token operator">=</span><span class="token string">&quot;LightSkyBlue&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>id color<span class="token operator">=</span><span class="token string">&quot;black&quot;</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span><span class="token operator">/</span>threads<span class="token operator">&gt;</span>
<span class="token comment">//                &lt;br/&gt;</span>
                  <span class="token operator">&lt;</span>store color<span class="token operator">=</span><span class="token string">&quot;red&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
<span class="token comment">//                  &lt;input color=&quot;magenta&quot;&gt; .List &lt;/input&gt;</span>
<span class="token comment">//                  &lt;output color=&quot;Orchid&quot;&gt; .List &lt;/output&gt;</span>
                  <span class="token operator">&lt;</span>input color<span class="token operator">=</span><span class="token string">&quot;magenta&quot;</span> stream<span class="token operator">=</span><span class="token string">&quot;stdin&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">&lt;</span><span class="token operator">/</span>input<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>output color<span class="token operator">=</span><span class="token string">&quot;Orchid&quot;</span> stream<span class="token operator">=</span><span class="token string">&quot;stdout&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">&lt;</span><span class="token operator">/</span>output<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>T<span class="token operator">&gt;</span>
<span class="token comment">// Replace the &lt;input/&gt; and &lt;output/&gt; cells with the next two in order to</span>
<span class="token comment">// initialize the input buffer through krun</span>
<span class="token comment">//     &lt;input color=&quot;magenta&quot;&gt; $IN:List &lt;/input&gt;</span>
<span class="token comment">//     &lt;output color=&quot;Orchid&quot;&gt; .List &lt;/output&gt;</span>
<span class="token comment">// Replace the &lt;input/&gt; and &lt;output/&gt; cells with the next two to connect the</span>
<span class="token comment">// input/output buffers to stdin/stdout through krun</span>
<span class="token comment">//     &lt;input color=&quot;magenta&quot; stream=&quot;stdin&quot;&gt; .List &lt;/input&gt;</span>
<span class="token comment">//     &lt;output color=&quot;Orchid&quot; stream=&quot;stdout&quot;&gt; .List &lt;/output&gt;</span>
<span class="token comment">// Replace the &lt;input/&gt; and &lt;output/&gt; cells with the next two to connect the</span>
<span class="token comment">// input/output buffers to stdin/stdout and also allow input through krun</span>
<span class="token comment">//     &lt;input color=&quot;magenta&quot; stream=&quot;stdin&quot;&gt; $IN:List &lt;/input&gt;</span>
<span class="token comment">//     &lt;output color=&quot;Orchid&quot; stream=&quot;stdout&quot;&gt; .List &lt;/output&gt;</span>
</code></pre>
<p>We can also use configuration variables to initialize<br>
the configuration through <code>krun</code>. For example, we may want to<br>
pass a few list items in the <code>in</code> cell when the program makes<br>
use of <code>read()</code>, so that the semantics does not get stuck.<br>
Recall from IMP that configuration variables start with a <em>$</em><br>
character when used in the configuration (see, for example,<br>
<em>$PGM</em>) and can be initialized with any string by<br>
<code>krun</code>; or course, the string should parse to a term of the<br>
corresponding sort, otherwise errors will be generated.<br>
Moreover, <strong>K</strong> allows you to connect list cells to the standard input or<br>
the standard output. For example, if you add the attribute<br>
<code>stream=&quot;stdin&quot;</code> to the <code>in</code> cell, then <code>krun</code><br>
will prompt the user to pass input when the <code>in</code> cell is empty<br>
and any semantic rule needs at least one item to be present there in<br>
order to match. Similarly but dually, if you add the attribute<br>
<code>stream=&quot;stdout&quot;</code> to the <code>out</code> cell, then any item<br>
placed into this cell by any rule will be promptly sent to the<br>
standard output. This way, <code>krun</code> can be used to obtain<br>
interactive interpreters based directly on the <strong>K</strong> semantics of the<br>
language. For example:</p>
<pre class="language-shell"><code>sh$ krun sum-io.imp --output none
Add numbers up to <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">0</span> to quit<span class="token punctuation">)</span>? <span class="token number">10</span>
Sum <span class="token operator">=</span> <span class="token number">55</span>
Add numbers up to <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">0</span> to quit<span class="token punctuation">)</span>? <span class="token number">1000</span>
Sum <span class="token operator">=</span> <span class="token number">500500</span>
Add numbers up to <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">=</span> <span class="token number">0</span> to quit<span class="token punctuation">)</span>? <span class="token number">0</span>
sh$
</code></pre>
<p>The option <code>--output none</code> instructs <code>krun</code> to not<br>
display the resulting configuration after the program executes. The<br>
input/output streaming works with or without this option, although<br>
if you don&apos;t use the option then a configuration with empty<br>
<code>in</code> and <code>out</code> cells will be displayed after the program<br>
is executed. You can also initialize the configuration using<br>
configuration variables and stream the contents of the cells to<br>
standard input/output at the same time. For example, if you use a<br>
configuration variable in the <code>in</code> cell and pass contents to it<br>
through <code>krun</code>, then that contents will be first consumed and<br>
then the user will be prompted to introduce additional input if the<br>
program&apos;s execution encounters more <code>read()</code> constructs.</p>
<h3 id="the-old-imp-constructs">The old IMP constructs</h3>
<p>The semantics of the old IMP constructs is almost identical to their<br>
semantics in the original IMP language, except for those constructs<br>
making use of the program state and for those whose syntax has slightly<br>
changed. Indeed, the rules for variable lookup and assignment in IMP<br>
accessed the <code>state</code> cell, but that cell is not available in IMP++<br>
anymore. Instead, we have to use the combination of environment and store<br>
cells. Thanks to <strong>K</strong>&apos;s implicit configuration abstraction, we do not have<br>
to mention the <code>thread</code> and <code>threads</code> cells: these are<br>
automatically inferred (and added by the <strong>K</strong> tool at compile time) from the<br>
definition of the configuration above, as there is only one correct<br>
way to complete the configuration context of these rules in order to<br>
match the configuration declared above. In our case here, &quot;correct way&quot;<br>
means that the <code>k</code> and <code>env</code> cells will be considered as<br>
being part of the same <code>thread</code> cell, as opposed to each being part<br>
of a different thread. Configuration abstraction is crucial for modularity,<br>
because it gives us the possibility to write our definitions in a way that<br>
may not require us to revisit existing rules when we change the configuration.<br>
Changes in the configuration are quite frequent in practice, typically<br>
needed in order to accommodate new language features. For example,<br>
imagine that we initially did not have threads in IMP++. There<br>
would be no need for the <code>thread</code> and <code>threads</code> cells in<br>
the configuration then, the cells <code>k</code> and <code>env</code> being simply<br>
placed at the top level in the <code>T</code> cell, together with the<br>
already existing cells. Then the rules below would be exactly the<br>
same. Thus, configuration abstraction allows you to not have to<br>
modify your rules when you make structural changes in your language<br>
configuration.</p>
<p>Below we list the semantics of the old IMP constructs, referring the<br>
reader to the <strong>K</strong> semantics of IMP for their meaning. Like we tagged the<br>
addition and the division rules above in the syntax, we also tag the lookup<br>
and the assignment rules below (with tags <code>lookup</code> and<br>
<code>assignment</code>), because we want to refer to them when we generate the<br>
language model (with the <code>kompile</code> tool), basically to allow them to<br>
generate (possibly non-deterministic) transitions. Indeed, these two rules,<br>
unlike the other rules corresponding to old IMP constructs, can yield<br>
non-deterministic behaviors when more threads are executed concurrently.<br>
In terms of rewriting, these two rules can &quot;compete&quot; with each other on<br>
some program configurations, in the sense that they can both match at the<br>
same time and different behaviors may be obtained depending upon which of<br>
them is chosen first.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span>
</code></pre>
<h3 id="variable-lookup">Variable lookup</h3>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> N <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> N <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>lookup<span class="token punctuation">]</span>
</code></pre>
<h3 id="arithmetic-constructs">Arithmetic constructs</h3>
<pre class="language-k"><code>  <span class="token keyword">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">/</span><span class="token keyword">Int</span> I2  when I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span><span class="token keyword">Int</span> <span class="token number">0</span>
  <span class="token keyword">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">+</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> <span class="token operator">-</span> I <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword">Int</span> I
</code></pre>
<h3 id="boolean-constructs">Boolean constructs</h3>
<pre class="language-k"><code>  <span class="token keyword">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> <span class="token operator">!</span> T <span class="token operator">=</span><span class="token operator">&gt;</span> notBool T
  <span class="token keyword">rule</span> <span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> B <span class="token operator">=</span><span class="token operator">&gt;</span> B
  <span class="token keyword">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>
</code></pre>
<h3 id="variable-assignment">Variable assignment</h3>
<p>Note that the old IMP assignment statement <code>X = I;</code> is now composed of two<br>
constructs: an assignment expression construct <code>X = I</code>, followed by a<br>
semicolon <code>;</code> turning the expression into a statement. The rationale behind<br>
this syntactic restructuring has been explained in Lesson 7. Here is the<br>
semantics of the two constructs:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> _<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X <span class="token operator">=</span> I<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> N <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> N <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">&gt;</span> I<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>assignment<span class="token punctuation">]</span>
</code></pre>
<h3 id="sequential-composition">Sequential composition</h3>
<p>Sequential composition has been defined as a whitespace-separated syntactic<br>
list of statements. Recall that syntactic lists are actually syntactic<br>
sugar for cons-lists. Therefore, the following two rules eventually<br>
sequentialize a syntactic list of statements <code>s1 s2 ... sn..</code> into the<br>
corresponding computation <code>s1 ~&gt; s2 ~&gt; ... ~&gt; sn</code>.</p>
<pre class="language-k"><code>   <span class="token keyword">rule</span> <span class="token punctuation">.</span>Stmts <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>
   <span class="token keyword">rule</span> S<span class="token punctuation">:</span>Stmt Ss<span class="token punctuation">:</span>Stmts <span class="token operator">=</span><span class="token operator">&gt;</span> S <span class="token operator">~</span><span class="token operator">&gt;</span> Ss  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h3 id="conditional-statement">Conditional statement</h3>
<pre class="language-k"><code>  <span class="token keyword">rule</span> if <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  S else _ <span class="token operator">=</span><span class="token operator">&gt;</span> S
  <span class="token keyword">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=</span><span class="token operator">&gt;</span> S
</code></pre>
<h3 id="while-loop">While loop</h3>
<p>The only thing to notice here is that the empty block has been replaced<br>
with the block holding the explicit empty sequence. That&apos;s because in<br>
the semantics all empty lists become explicit corresponding dots<br>
(to avoid parsing ambiguities)</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> while <span class="token punctuation">(</span>B<span class="token punctuation">)</span> S <span class="token operator">=</span><span class="token operator">&gt;</span> if <span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while <span class="token punctuation">(</span>B<span class="token punctuation">)</span> S<span class="token punctuation">}</span> else <span class="token punctuation">{</span><span class="token punctuation">.</span>Stmts<span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h3 id="the-new-imp%2B%2B-constructs">The new IMP++ constructs</h3>
<p>We next discuss the semantics of the new IMP++ constructs.</p>
<h3 id="strings">Strings</h3>
<p>First, we have to state that strings are also results.<br>
Second, we give the semantics of IMP++ string concatenation (which<br>
uses the already existing addition symbol <code>+</code> from IMP) by<br>
reduction to the built-in string concatenation operation.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">String</span>
  <span class="token keyword">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=</span><span class="token operator">&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword">String</span> Str2
</code></pre>
<h3 id="variable-increment">Variable increment</h3>
<p>Like variable lookup, this is also meant to be a supercool transition: we<br>
want it to count both in the non-determinism due to strict operations above<br>
it in the computation and in the non-determinism due to thread<br>
interleavings. This rule also relies on <strong>K</strong>&apos;s configuration abstraction.<br>
Without abstraction, you would have to also include the <code>thread</code> and<br>
<code>threads</code> cells.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token operator">++</span>X <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> N <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> N <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>I <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>increment<span class="token punctuation">]</span>
</code></pre>
<h3 id="read">Read</h3>
<p>The <code>read()</code> construct evaluates to the first integer in the<br>
input buffer, which it consumes. Note that this rule is tagged<br>
<code>increment</code>. This is because we will include it in the set of<br>
potentially non-deterministic transitions when we kompile the definition;<br>
we want to do that because two or more threads can &quot;compete&quot; on<br>
reading the next integer from the input buffer, and different choices<br>
for the next transition can lead to different behaviors.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>input<span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>input<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>read<span class="token punctuation">]</span>
</code></pre>
<h3 id="print">Print</h3>
<p>The <code>print</code> statement is strict, so all its arguments are<br>
eventually evaluated (recall that <code>print</code> is variadic). We<br>
append each of its evaluated arguments, in order, to the output buffer,<br>
and structurally discard the residual <code>print</code> statement with an<br>
empty list of arguments. We only want to allow printing integers and<br>
strings, so we define a <code>Printable</code> syntactic category including<br>
only these and define the <code>print</code> statement to only print<br>
<code>Printable</code> elements. Alternatively, we could have had two<br>
similar rules, one for integers and one for strings. Recall that,<br>
currently, <strong>K</strong>&apos;s lists are cons-lists, so we cannot simply rewrite the<br>
head of a list (<code>P</code>) into a list (<code>.</code>). The first rule below is tagged,<br>
because we want to include it in the list of transitions when we kompile;<br>
different threads may compete on the output buffer and we want to capture<br>
all behaviors. The second rule is structural because we do not want it to<br>
count as a computational step.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Printable <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">String</span>

<span class="token comment">/* currently it is necessary to subsort Printable to AExp,
  but future K should be able to infer that automatically. */</span>
  <span class="token keyword">syntax</span> AExp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Printable

  <span class="token keyword">context</span> print<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span>AExp<span class="token punctuation">,</span> AEs<span class="token punctuation">:</span>AExps<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> print<span class="token punctuation">(</span>P<span class="token punctuation">:</span>Printable<span class="token punctuation">,</span>AEs <span class="token operator">=</span><span class="token operator">&gt;</span> AEs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>output<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=</span><span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>output<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>print<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>AExps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h3 id="halt">Halt</h3>
<p>The <code>halt</code> statement empties the computation, so the rewriting process<br>
simply terminates as if the program terminated normally. Interestingly, once<br>
we add threads to the language, the <code>halt</code> statement as defined below<br>
will terminate the current thread only. If you want an abrupt termination<br>
statement that halts the entire program, then you need to discard the entire<br>
contents of the <code>threads</code> cell, so the entire computation abruptly<br>
terminates the entire program, no matter how many concurrent threads it has,<br>
because there is nothing else to rewrite.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> halt<span class="token punctuation">;</span> <span class="token operator">~</span><span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
</code></pre>
<h3 id="spawn-thread">Spawn thread</h3>
<p>A spawned thread is passed its parent&apos;s environment at creation time.<br>
The <code>spawn</code> expression in the parent thread is immediately<br>
replaced by the unique identifier of the newly created thread, so the<br>
parent thread can continue its execution. We only consider a sequentially<br>
consistent shared memory model for IMP++, but other memory models can also<br>
be defined in <strong>K</strong>; see, for example, the definition of KERNELC. Note that<br>
the rule below does not need to be tagged in order to make it a transition<br>
when we kompile, because the creation of the thread itself does not interfere<br>
with the execution of other threads. Also, note that <strong>K</strong>&apos;s configuration<br>
abstraction is at heavy work here, in two different places. First, the<br>
parent thread&apos;s <code>k</code> and <code>env</code> cells are wrapped within a<br>
<code>thread</code> cell. Second, the child thread&apos;s <code>k</code>, <code>env</code><br>
and <code>id</code> cells are also wrapped within a <code>thread</code> cell. Why<br>
that way and not putting all these four cells together within the<br>
same thread, or even create an additional <code>threads</code> cell at top<br>
holding a <code>thread</code> cell with the new <code>k</code>, <code>env</code><br>
and <code>id</code>? Because in the original configuration we declared<br>
the multiplicity of the <code>thread</code> cell to be <code>*</code>, which<br>
effectively tells the <strong>K</strong> tool that zero, one or more such cells can<br>
co-exist in a configuration at any moment. The other cells have the<br>
default multiplicity <code>one</code>, so they are not allowed to multiply.<br>
Thus, the only way to complete the rule below in a way consistent with<br>
the declared configuration is to wrap the first two cells in a<br>
<code>thread</code> cell, and the latter two cells under the <code>.</code><br>
also in a <code>thread</code> cell. Once the rule applies, the spawning<br>
thread cell will add a new thread cell next to it, which is consistent<br>
with the declared configuration cell multiplicity. The unique identifier<br>
of the new thread is generated using the <code>fresh</code> side condition.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> spawn S <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> S <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span> <span class="token operator">!</span>T <span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="join-thread">Join thread</h3>
<p>A thread who wants to join another thread <code>T</code> has to wait until<br>
the computation of <code>T</code> becomes empty. When that happens, the<br>
join statement is simply dissolved. The terminated thread is not removed,<br>
because we want to allow possible other join statements to also dissolve.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> join<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>T<span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span>
</code></pre>
<h3 id="blocks">Blocks</h3>
<p>The body statement of a block is executed normally, making sure<br>
that the environment at the block entry point is saved in the computation,<br>
in order to be recovered after the block body statement. This step is<br>
necessary because blocks can declare new variables having the same<br>
name as variables which already exist in the environment, and our<br>
semantics of variable declarations is to update the environment map in<br>
the declared variable with a fresh location. Thus, variables which<br>
are shadowed lose their original binding, which is why we take a<br>
snapshot of the environment at block entrance and place it after the<br>
block body (see the semantics of environment recovery at the end of<br>
this module). Note that any store updates through variables which are<br>
not declared locally are kept at the end of the block, since the store<br>
is not saved/restored. An alternative to this environment save/restore<br>
approach is to actually maintain a stack of environments and to push a<br>
new layer at block entrance and pop it at block exit. The variable<br>
lookup/assign/increment operations then also need to change, so we do<br>
not prefer that non-modular approach. Compilers solve this problem by<br>
statically renaming all local variables into fresh ones, to completely<br>
eliminate shadowing and thus environment saving/restoring. The rule<br>
below can be structural, because what it effectively does is to take a<br>
snapshot of the current environment; this operation is arguably not a<br>
computational step.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token punctuation">{</span>Ss<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Ss <span class="token operator">~</span><span class="token operator">&gt;</span> Rho <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h3 id="variable-declaration">Variable declaration</h3>
<p>We allocate a fresh location for each newly declared variable and<br>
initialize it with 0.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> int <span class="token punctuation">(</span>X<span class="token punctuation">,</span>Xs <span class="token operator">=</span><span class="token operator">&gt;</span> Xs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">=</span><span class="token operator">&gt;</span> Rho<span class="token punctuation">[</span>X <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">!</span>N<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">!</span>N <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> int <span class="token punctuation">.</span>Ids<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h3 id="auxiliary-operations">Auxiliary operations</h3>
<p>We only have one auxiliary operation in IMP++, the environment<br>
recovery. Its role is to discard the current environment in the<br>
<code>env</code> cell and replace it with the environment that it holds.<br>
This rule is structural: we do not want them to count as computational<br>
steps in the transition system of a program.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> Rho <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<p>If you want to avoid useless environment recovery steps and keep the size<br>
of the computation structure smaller, then you can also add the rule</p>
<pre class="language-text"><code>  rule (_:Map =&gt; .) ~&gt; _:Map  [structural]
</code></pre>
<p>This rule acts like a ``tail recursion&apos;&apos; optimization, but for blocks. */</p>
<pre class="language-k"><code><span class="token comment">// verification ids</span>
  <span class="token keyword">syntax</span> <span class="token keyword">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;n&quot;</span>     <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> <span class="token string">&quot;sum&quot;</span>   <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> <span class="token string">&quot;a&quot;</span>     <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span>     <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
              <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span>     <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword">endmodule</span>
</code></pre>
<h3 id="on-kompilation-options">On Kompilation Options</h3>
<p>We are done with the IMP++ semantics. The next step is to kompile the<br>
definition using the <code>kompile</code> tool, this way generating a language<br>
model. Depending upon for what you want to use the generated language model,<br>
you may need to kompile the definition using various options. We here discuss<br>
these options.</p>
<p>To tell the <strong>K</strong> tool to exhaustively explore all the behaviors due to the<br>
non-determinism of addition, division, and threads, we have to kompile<br>
with the command:</p>
<pre class="language-shell"><code>kompile imp.k --transition<span class="token operator">=</span><span class="token string">&quot;addition division lookup assignment increment read print&quot;</span>
</code></pre>
<p>As already mentioned, the syntax and rule tags play no theoretical or<br>
foundational role in <strong>K</strong>. They are only a means to allow <code>kompile</code> to<br>
refer to them in its options, like we did above. By default, <code>kompile</code>&apos;s<br>
transition option is empty, because this yields the fastest language model when<br>
executed. Transitions may slow down the execution, but they instrument<br>
the language model to allow for formal analysis of program behaviors, even for<br>
exhaustive analysis.</p>
<p>Theoretically, the heating/cooling rules in <strong>K</strong> are fully reversible and<br>
unconstrained by side conditions as we showed in the semantics of IMP.<br>
For example, the theoretical heating/cooling rules corresponding to the<br>
<code>strict</code> attribute of division are the following:</p>
<pre class="language-text"><code>E&#x2081; / E&#x2082; &#x21D2; E&#x2081; &#x2933; &#x25A1; / E&#x2082;
E&#x2081; &#x2933; &#x25A1; / E&#x2082; &#x21D2; E&#x2081; / E&#x2082;
E&#x2081; / E&#x2082; &#x21D2; E&#x2082; &#x2933; E&#x2081; / &#x25A1;
E&#x2082; &#x2933; E&#x2081; / &#x25A1; &#x21D2; E&#x2081; / E&#x2082;
</code></pre>
<p>The other semantic rules apply <code>modulo</code> such structural rules.<br>
For example, using heating rules we can bring a redex (a subterm which<br>
can be reduced with semantic rules) to the front of the computation,<br>
then reduce it, then use cooling rules to reconstruct a term over the<br>
original syntax of the language, then heat again and<br>
non-deterministically pick another redex, and so on and so forth<br>
without losing any opportunities to apply semantic rules.<br>
Nevertheless, these unrestricted heating/cooling rules may create an<br>
immense, often unfeasibly large space of possibilities to analyze.<br>
The <code>--transition</code> option implements an optimization which works<br>
well with other implementation choices made in the current <strong>K</strong> tool.<br>
Recall from the detailed description of the IMP language semantics that<br>
(theoretical) reversible rules like above are restricted by default<br>
to complementary conditional rules of the form</p>
<pre class="language-text"><code>E&#x2081; / E&#x2082; &#x21D2; E&#x2081; &#x2933; &#x25A1; / E&#x2082;
   if E&#x2081; not in KResult
E&#x2081; &#x2933; &#x25A1; / E&#x2082; &#x21D2; E&#x2081; / E&#x2082;
   if E&#x2081; in KResult
E&#x2081; / E&#x2082; &#x21D2; E&#x2082; &#x2933; E&#x2081; / &#x25A1;
   if E&#x2082; not in KResult
E&#x2082; &#x2933; E&#x2081; / &#x25A1;  &#x21D2; E&#x2081; / E&#x2082;
   if  E&#x2082; in KResult
</code></pre>
<p>Therefore, our tool eagerly heats and lazily cools the computation.<br>
In other words, heating rules apply until a redex gets placed on the<br>
top of the computation, then some semantic rule applies and rewrites<br>
that into a result, then a cooling rule is applied to plug the<br>
obtained result back into its context, then another argument may be<br>
chosen and completely heated, and so on. This leads to efficient<br>
execution, but it may and typically does hide program behaviors.<br>
Using the <code>--transition</code> option allows you to interfere with this<br>
process and to obtain all possible non-deterministic behaviors as if<br>
the theoretical heating/cooling rules were applied. Optimizations<br>
of course happen under the hood, but you need not be aware of them.<br>
Used carefully, this mechanism allows us to efficiently explore more of<br>
the non-deterministic behaviors of a program, even all of them (like here).<br>
For example, with the semantics of IMP++ given above, the <code>krun</code><br>
command with the <code>--search</code> option detects all five behaviors<br>
of the following IMP++ program (<code>x</code> can be 0, 1, 2, 3, or undefined<br>
due to division-by-zero):</p>
<pre class="language-text"><code>  int x,y;
  x = 1;
  y = ++x / (++x / x);
</code></pre>
<p>Besides non-determinism due to underspecified argument evaluation<br>
orders, which the current <strong>K</strong> tool addresses as explained above, there<br>
is another important source of non-determinism in programming languages:<br>
non-determinism due to concurrency/parallelism. For example, when two<br>
or more threads are about to access the same location in the store and at<br>
least one of these accesses is a write (i.e., an instance of the variable<br>
assignment rule), there is a high chance that different choices for<br>
the next transition lead to different program behaviors. While in the<br>
theory of <strong>K</strong> all the non-structural rules count as computational steps<br>
and hereby as transitions in the transition system associated to the<br>
program, in practice that may yield a tremendous number of step<br>
interleavings to consider. Most of these interleavings are behaviorally<br>
equivalent for most purposes. For example, the fact that a thread computes<br>
a step <code>8+3 &#x21D2; 11</code> is likely irrelevant for the other<br>
threads, so one may not want to consider it as an observable transition in<br>
the space of interleavings. Since the K tool cannot know without help which<br>
transitions need to be explored and which do not, our approach is to<br>
let the user say so explicitly using the <code>transition</code> option of<br>
<code>kompile</code>.</p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
