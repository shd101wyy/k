<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1 id="fun-%E2%80%94-untyped-%E2%80%94-environment">FUN &#x2014; Untyped &#x2014; Environment</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 id="abstract">Abstract</h2>
<p>This is the <strong>K</strong> semantic definition of the untyped FUN language.<br>
FUN is a pedagogical and research language that captures the essence<br>
of the functional programming paradigm, extended with several features<br>
often encountered in functional programming languages.<br>
Like many functional languages, FUN is an expression language, that<br>
is, everything, including the main program, is an expression.<br>
Functions can be declared anywhere and are first class values in the<br>
language.<br>
FUN is call-by-value here, but it has been extended (as student<br>
homework assignments) with other parameter-passing styles.<br>
To make it more interesting and to highlight some of <strong>K</strong>&apos;s strengths,<br>
FUN includes the following features:</p>
<ul>
<li>
<p>The basic builtin data-types of integers, booleans and strings.</p>
</li>
<li>
<p>Builtin lists, which can hold any elements, including other lists.<br>
Lists are enclosed in square brackets and their elements are<br>
comma-separated; e.g., <code>[1,2,3]</code>.</p>
</li>
<li>
<p>User-defined data-types, by means of constructor terms.<br>
Constructor names start with a capital letter (while any other<br>
identifier in the language starts with a lowercase letter), and they<br>
can be followed by an arbitrary number of comma-separated arguments<br>
enclosed in parentheses; parentheses are not needed when the<br>
constructor takes no arguments.<br>
For example, <code>Pair(5,7)</code> is a constructor term holding two<br>
numbers, <code>Cons(1,Cons(2,Cons(3,Nil)))</code> is a list-like<br>
constructor term holding 3 elements, and<br>
<code>Tree(Tree(Leaf(1), Leaf(2)), Leaf(3))</code> is a tree-like<br>
constructor term holding 3 elements.<br>
In the untyped version of the FUN language, no type checking or<br>
inference is performed to ensure that the data constructors are used<br>
correctly.<br>
The execution will simply get stuck when they are misused.<br>
Moreover, since no type checking is performed, the data-types are not<br>
even declared in the untyped version of FUN.</p>
</li>
<li>
<p>Functions and <code>let</code>/<code>letrec</code> binders can take<br>
multiple space-separated arguments, but these are desugared to<br>
ones that only take one argument, by currying.  For example, the<br>
expressions</p>
<pre class="language-text"><code>fun x y -&gt; x y
let x y = y in x
</code></pre>
<p>are desugared, respectively, into the following expressions:</p>
<pre class="language-text"><code>fun x -&gt; fun y -&gt; x y
let x = fun y -&gt; y in x
</code></pre>
</li>
<li>
<p>Functions can be defined using pattern matching over the<br>
available data-types.  For example, the program</p>
<pre class="language-text"><code>letrec max = fun [h] -&gt; h
             |   [h|t] -&gt; let x = max t
                          in  if h &gt; x then h else x
in max [1, 3, 5, 2, 4, 0, -1, -5]
</code></pre>
<p>defines a function <code>max</code> that calculates the maximum element of<br>
a non-empty list, and the function</p>
<pre class="language-text"><code>letrec ack = fun Pair(0,n) -&gt; n + 1
             |   Pair(m,0) -&gt; ack Pair(m - 1, 1)
             |   Pair(m,n) -&gt; ack Pair(m - 1, ack Pair(m, n - 1))
in ack Pair(2,3)
</code></pre>
<p>calculates the Ackermann function applied to a particular pair of numbers.<br>
Patterns can be nested.  Patterns can currently only be used in function<br>
definitions, and not directly in <code>let</code>/<code>letrec</code> binders.<br>
For example, this is not allowed:</p>
<pre class="language-text"><code>letrec Pai(x,y) = Pair(1,2) in x+y
</code></pre>
<p>But this is allowed:</p>
<pre class="language-text"><code>let f Pair(x,y) = x+y in f Pair(1,2)
</code></pre>
<p>because it is first reduced to</p>
<pre class="language-text"><code>let f = fun Pair(x,y) -&gt; x+y in f Pair(1,2)
</code></pre>
<p>by uncurrying of the <code>let</code> binder, and pattern matching is<br>
allowed in function arguments.</p>
</li>
<li>
<p>We include a <code>callcc</code> construct, for two reasons: first,<br>
several functional languages support this construct; second, some<br>
semantic frameworks have difficulties defining it.  Not <strong>K</strong>.</p>
</li>
<li>
<p>Finally, we include mutables by means of referencing an<br>
expression, getting the reference of a variable, dereferencing and<br>
assignment.  We include these for the same reasons as above: there are<br>
languages which have them, and they are not easy to define in some<br>
semantic frameworks.</p>
</li>
</ul>
<p>Like in many other languages, some of FUN&apos;s constructs can be<br>
desugared into a smaller set of basic constructs.  We do that as usual,<br>
using macros, and then we only give semantics to the core constructs.</p>
<p><strong>Note:</strong><br>
We recommend the reader to first consult the dynamic semantics of the<br>
LAMBDA++ language in the first part of the K Tutorial.<br>
To keep the comments below small and focused, we will not re-explain<br>
functional or <strong>K</strong> features that have already been explained in there.</p>
<h2 id="syntax">Syntax</h2>
<pre class="language-k"><code><span class="token comment">//require &quot;modules/pattern-matching.k&quot;</span>

<span class="token keyword">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</code></pre>
<p>FUN is an expression language.  The constructs below fall into<br>
several categories: names, arithmetic constructs, conventional<br>
functional constructs, patterns and pattern matching, data constructs,<br>
lists, references, and call-with-current-continuation (callcc).<br>
The arithmetic constructs are standard; they are present in almost all<br>
our <strong>K</strong> language definitions.  The meaning of FUN&apos;s constructs are<br>
discussed in more depth when we define their semantics in the next<br>
module.</p>
<h2 id="the-syntactic-constructs">The Syntactic Constructs</h2>
<p>We start with the syntactic definition of FUN names.<br>
We have several categories of names: ones to be used for functions and<br>
variables, others to be used for data constructors, others for types and<br>
others for type variables.  We will introduce them as needed, starting<br>
with the former category.  We prefer the names of variables and functions<br>
to start with lower case letters.  We take the freedom to tacitly introduce<br>
syntactic lists/sequences for each nonterminal for which we need them:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Name
  <span class="token keyword">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Name<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
</code></pre>
<p>Expression constructs will be defined throughtout the syntax module.<br>
Below are the very basic ones, namely the builtins, the names, and the<br>
parentheses used as brackets for grouping.  Lists of expressions are<br>
declared strict, so all expressions in the list get evaluated whenever<br>
the list is on a position which can be evaluated:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span> <span class="token operator">|</span> <span class="token keyword">String</span> <span class="token operator">|</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> Exps  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>                   <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> Val
  <span class="token keyword">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> Bottom
  <span class="token keyword">syntax</span> Bottoms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Bottom<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
</code></pre>
<p>We next define the syntax of arithmetic constructs, together with<br>
their relative priorities and left-/non-associativities.  We also<br>
tag all these rules with a new tag, &quot;arith&quot;, so we can more easily<br>
define global syntax priirities later (at the end of the syntax module).</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;^&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
<span class="token comment">// left attribute should not be necessary; currently a parsing bug</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">prefer</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
<span class="token comment">// the &quot;prefer&quot; attribute above is to not parse x-1 as x(-1)</span>
<span class="token comment">// Due to some parsing problems, we currently cannot add unary minus:</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token string">&quot;!&quot;</span> Exp                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;||&quot;</span> Exp                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">,</span> arith<span class="token punctuation">]</span>
</code></pre>
<p>The conditional construct has the expected evaluation strategy,<br>
stating that only the first argument is evaluate:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;if&quot;</span> Exp <span class="token string">&quot;then&quot;</span> Exp <span class="token string">&quot;else&quot;</span> Exp    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre>
<p>FUN&apos;s builtin lists are formed by enclosing comma-separated<br>
sequences of expressions (i.e., terms of sort <code>Exps</code>) in square<br>
brackets.  The list constructor <code>cons</code> adds a new element to the<br>
top of the list, <code>head</code> and <code>tail</code> get the first element<br>
and the tail sublist of a list if they exist, respectively, and get<br>
stuck otherwise, and <code>null??</code> tests whether a list is empty or<br>
not; syntactically, these are just expression constants.<br>
In function patterns, we are also going to allow patterns following the<br>
usual head/tail notation; for example, the pattern <code>[x_1,...,x_n|t]</code><br>
binds <code>x_1</code>, ..., <code>x_n</code> to the first elements of the matched list,<br>
and <code>t</code> to the list formed with the remaining elements.  We define list<br>
patterns as ordinary expression constructs, although we will make sure that<br>
we do not give them semantics if they appear in any other place then in a<br>
function case pattern.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;cons&quot;</span> <span class="token operator">|</span>  <span class="token string">&quot;head&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;tail&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;null?&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;|&quot;</span> Exp <span class="token string">&quot;]&quot;</span>
  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;[&quot;</span> Vals <span class="token string">&quot;]&quot;</span>
</code></pre>
<p>Data constructors start with capital letters and they may or may<br>
not have arguments.  We need to use the attribute &quot;prefer&quot; to make<br>
sure that, e.g., <code>Cons(a)</code> parses as constructor <code>Cons</code> with<br>
argument <code>a</code>, and not as the expression <code>Cons</code> (because<br>
constructor names are also expressions) regarded as a function applied<br>
to the expression <code>a</code>.  Also, note that the constructor is strict<br>
in its second argument, because we want to evaluate its arguments but<br>
not the constuctor name itsef.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> ConstructorName
  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
               <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName <span class="token string">&quot;(&quot;</span> Vals <span class="token string">&quot;)&quot;</span>
</code></pre>
<p>A function is essentially a <code>|</code>-separated ordered<br>
sequence of cases, each case of the form <code>pattern -&gt; expression</code>,<br>
preceded by the language construct <code>fun</code>.  Patterns will be defined<br>
shortly, both for the builtin lists and for user-defined constructors.<br>
Recall that the syntax we define in <strong>K</strong> is not meant to serve as a<br>
ultimate parser for the defined language, but rather as a convenient<br>
notation for <strong>K</strong> abstract syntax trees, which we prefer when we write<br>
the semantic rules.  It is therefore often the case that we define a<br>
more ``generous&apos;&apos; syntax than we want to allow programs to use.<br>
We do it here, too.  Specifically, the syntax of <code>Cases</code><br>
below allows any expressions to appear as pattern.  This syntactic<br>
relaxation permits many wrong programs to be parsed, but that is not a<br>
problem because we are not going to give semantics to wrong combinations,<br>
so those programs will get stuck; moreover, our type inferencer will reject<br>
those programs anyway.  Function application is just concatenation of<br>
expressions, without worrying about type correctness.  Again, the type<br>
system will reject type-incorrect programs.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;fun&quot;</span> Cases
               <span class="token operator">|</span> Exp Exp                              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: We would like eventually to also have Exp &quot;(&quot; Exps &quot;)</span>
  <span class="token keyword">syntax</span> Case  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;-&gt;&quot;</span> Exp
  <span class="token keyword">syntax</span> Cases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Case<span class="token punctuation">,</span> <span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>
</code></pre>
<p>The <code>let</code> and <code>letrec</code> binders have the usual syntax<br>
and functional meaning.  We allow multiple <code>and</code>-separated bindings.<br>
Like for the function cases above, we allow a more generous syntax for<br>
the left-hand sides of bindings, noting that the semantics will get stuck<br>
on incorrect bindings and that the type system will reject those programs.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;let&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp
               <span class="token operator">|</span> <span class="token string">&quot;letrec&quot;</span> Bindings <span class="token string">&quot;in&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
<span class="token comment">// The &quot;prefer&quot; attribute for letrec currently needed due to tool bug,</span>
<span class="token comment">// to make sure that &quot;letrec&quot; is not parsed as &quot;let rec&quot;.</span>
  <span class="token keyword">syntax</span> Binding  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Exp <span class="token string">&quot;=&quot;</span> Exp
  <span class="token keyword">syntax</span> Bindings <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Binding<span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">}</span>
</code></pre>
<p>References are first class values in FUN.  The construct <code>ref</code><br>
takes an expression, evaluates it, and then it stores the resulting value<br>
at a fresh location in the store and returns that reference.  Syntactically,<br>
<code>ref</code> is just an expression constant.  The construct <code>&amp;</code><br>
takes a name as argument and evaluates to a reference, namely the store<br>
reference where the variable passed as argument stores its value; this<br>
construct is a bit controversial and is further discussed in the<br>
environment-based semantics of the FUN language, where we desugar<br>
<code>ref</code> to it.  The construct <code>@</code> takes a reference<br>
and evaluates to the value stored there.  The construct <code>:=</code> takes<br>
two expressions, the first expected to evaluate to a reference; the value<br>
of its second argument will be stored at the location to which the first<br>
points (the old value is thus lost).  Finally, since expression evaluation<br>
now has side effects, it makes sense to also add a sequential composition<br>
construct, which is sequentially strict.  This evaluates to the value of<br>
its second argument; the value of the first argument is lost (which has<br>
therefore been evaluated only for its side effects.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;ref&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;&amp;&quot;</span> Name
               <span class="token operator">|</span> <span class="token string">&quot;@&quot;</span> Exp                                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;:=&quot;</span> Exp                                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span> Exp                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</code></pre>
<p>Call-with-current-continuation, named <code>callcc</code> in FUN, is a<br>
powerful control operator that originated in the Scheme programming<br>
language, but it now exists in many other functional languages.  It works<br>
by evaluating its argument, expected to evaluate to a function, and by<br>
passing the current continuation, or evaluation context (or computation,<br>
in <strong>K</strong> terminology), as a special value to it.  When/If this special value<br>
is invoked, the current context is discarded and replaced with the one<br>
held by the special value and the computation continues from there.<br>
It is like taking a snapshot of the execution context at some moment<br>
in time and then, when desired, being able to get back in time to that<br>
point.  If you like games, it is like saving the game now (so you can<br>
work on your homework!) and then continuing the game tomorrow or whenever<br>
you wish.  To issustrate the strength of <code>callcc</code>, we also<br>
allow exceptions in FUN by means of a conventional <code>try-catch</code><br>
construct, which will desugar to <code>callcc</code>.  We also need to<br>
introduce the special expression contant <code>throw</code>, but we need to<br>
use it as a function argument name in the desugaring macro, so we define<br>
it as a name instead of as an expression constant:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;callcc&quot;</span>
               <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Exp <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Name <span class="token string">&quot;)&quot;</span> Exp
  <span class="token keyword">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;throw&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</code></pre>
<p>Finally, FUN also allows polymorphic datatype declarations.  These<br>
will be useful when we define the type system later on.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;datatype&quot;</span> Type <span class="token string">&quot;=&quot;</span> TypeCases Exp
<span class="token comment">// NOTE: In a future version of K, we want the datatype declaration</span>
<span class="token comment">// to be a construct by itself, but that is not possible currently</span>
<span class="token comment">// because K&apos;s parser wronly identifies the __ operation allowing</span>
<span class="token comment">// a declaration to appear in front of an expression with the function</span>
<span class="token comment">// application construct, giving ambiguous parsing errors.</span>
</code></pre>
<p>We next need to define the syntax of types and type cases that appear<br>
in datatype declarations.</p>
<p>Like in many functional languages, type parameters/variables in<br>
user-defined types are quoted identifiers.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> TypeVar
  <span class="token keyword">syntax</span> TypeVars <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeVar<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
</code></pre>
<p>Types can be basic types, function types, or user-defined<br>
parametric types.  In the dynamic semantics we are going to simply ignore<br>
all the type declations, so here the syntax of types below is only useful<br>
for generating the desired parser.  To avoid syntactic ambiguities with<br>
the arrow construct for function cases, we use the symbol <code>--&gt;</code> as<br>
a constructor for function types:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> TypeName
  <span class="token keyword">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;--&gt;&quot;</span> Type                            <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>                             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> TypeVar
                <span class="token operator">|</span> TypeName             <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">avoid</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> Type TypeName   <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>Type<span class="token operator">-</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span> TypeName                    <span class="token punctuation">[</span><span class="token class-name">prefer</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> TypeVars

  <span class="token keyword">syntax</span> TypeCase <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
                    <span class="token operator">|</span> ConstructorName <span class="token string">&quot;(&quot;</span> Types <span class="token string">&quot;)&quot;</span>
  <span class="token keyword">syntax</span> TypeCases <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>TypeCase<span class="token punctuation">,</span><span class="token string">&quot;|&quot;</span><span class="token punctuation">}</span>     <span class="token punctuation">[</span><span class="token class-name">klabel</span><span class="token punctuation">(</span>_<span class="token operator">|</span>TypeCase_<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="additional-priorities">Additional Priorities</h2>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> priorities @__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  <span class="token operator">&gt;</span> ___FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  <span class="token operator">&gt;</span> arith
                  <span class="token operator">&gt;</span> _<span class="token punctuation">:</span><span class="token operator">=</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  <span class="token operator">&gt;</span> let_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                    letrec_in__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                    if_then_else__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  <span class="token operator">&gt;</span> _<span class="token punctuation">;</span>__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  <span class="token operator">&gt;</span> fun__FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
                  <span class="token operator">&gt;</span> datatype_<span class="token operator">=</span>___FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
<span class="token keyword">endmodule</span>

<span class="token keyword">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
</code></pre>
<h2 id="desugaring-macros">Desugaring macros</h2>
<p>We desugar the list non-constructor operations to functions matching<br>
over list patterns.  In order to do that we need some new variables; for<br>
those, we follow the same convention like in the <strong>K</strong> tutorial, where we<br>
added them as new identifier constructs starting with the character <code>$</code>,<br>
so we can easily recognize them when we debug or trace the semantics.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$h&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;$t&quot;</span>
  <span class="token keyword">rule</span> head <span class="token operator">=</span><span class="token operator">&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span> $h                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> tail <span class="token operator">=</span><span class="token operator">&gt;</span> fun <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span> $t                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> null<span class="token operator">?</span> <span class="token operator">=</span><span class="token operator">&gt;</span> fun <span class="token punctuation">[</span><span class="token punctuation">.</span>Exps<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token punctuation">[</span>$h<span class="token operator">|</span>$t<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>       <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</code></pre>
<p>Multiple-head list patterns desugar into successive one-head patterns:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">[</span>E1<span class="token punctuation">,</span>E2<span class="token punctuation">,</span>Es<span class="token punctuation">:</span>Exps<span class="token operator">|</span>T<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>E1<span class="token operator">|</span><span class="token punctuation">[</span>E2<span class="token punctuation">,</span>Es<span class="token operator">|</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span>                   <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token operator">-</span>rec<span class="token punctuation">]</span>
</code></pre>
<p>Uncurrying of multiple arguments in functions and binders:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> P1 P2 <span class="token operator">-</span><span class="token operator">&gt;</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> P1 <span class="token operator">-</span><span class="token operator">&gt;</span> fun P2 <span class="token operator">-</span><span class="token operator">&gt;</span> E                       <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token operator">-</span>rec<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> F P <span class="token operator">=</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> F <span class="token operator">=</span> fun P <span class="token operator">-</span><span class="token operator">&gt;</span> E                             <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token operator">-</span>rec<span class="token punctuation">]</span>
</code></pre>
<p>We desugar the <code>try-catch</code> construct into callcc:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$k&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;$v&quot;</span>
  <span class="token keyword">rule</span> try E catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> E&apos;
    <span class="token operator">=</span><span class="token operator">&gt;</span> callcc <span class="token punctuation">(</span>fun $k <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>fun throw <span class="token operator">-</span><span class="token operator">&gt;</span> E<span class="token punctuation">)</span><span class="token punctuation">(</span>fun X <span class="token operator">-</span><span class="token operator">&gt;</span> $k E&apos;<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</code></pre>
<p>For uniformity, we reduce all types to their general form:</p>
<pre class="language-k"><code><span class="token comment">//  rule TypeName(Tn:TypeName) =&gt; (.TypeVars) Tn               [macro]</span>
  <span class="token keyword">rule</span> `Type<span class="token operator">-</span>TypeName`<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Tn<span class="token punctuation">:</span>TypeName<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> Tn          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</code></pre>
<p>The dynamic semantics ignores all the type declarations:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> datatype T <span class="token operator">=</span> TCs E <span class="token operator">=</span><span class="token operator">&gt;</span> E                               <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>

<span class="token keyword">endmodule</span>


<span class="token keyword">module</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword">imports</span> BUILTIN<span class="token operator">-</span>ID<span class="token operator">-</span>TOKENS

  <span class="token keyword">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[a-z][_a-zA-Z0-9]*&quot;</span>           <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">,</span> prec<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> #LowerId                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> ConstructorName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> #UpperId             <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> TypeVar  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> r<span class="token string">&quot;[&apos;][a-z][_a-zA-Z0-9]*&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
  <span class="token keyword">syntax</span> TypeName <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Name                        <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
<span class="token keyword">endmodule</span>
</code></pre>
<h2 id="semantics">Semantics</h2>
<p>The semantics below is environment-based.  A substitution-based<br>
definition of FUN is also available, but that drops the <code>&amp;</code><br>
construct as explained above.</p>
<pre class="language-k"><code><span class="token keyword">module</span> FUN<span class="token operator">-</span>UNTYPED
  <span class="token keyword">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>COMMON
  <span class="token keyword">imports</span> FUN<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>MACROS
  <span class="token keyword">imports</span> DOMAINS
  <span class="token comment">//imports PATTERN-MATCHING</span>
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>The <code>k</code>, <code>env</code>, and <code>store</code> cells are standard<br>
(see, for example, the definition of LAMBDA++ or IMP++ in the first<br>
part of the <strong>K</strong> tutorial).</p>
<pre class="language-k"><code>  <span class="token keyword">configuration</span> <span class="token operator">&lt;</span>T color<span class="token operator">=</span><span class="token string">&quot;yellow&quot;</span><span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>k color<span class="token operator">=</span><span class="token string">&quot;green&quot;</span><span class="token operator">&gt;</span> $PGM<span class="token punctuation">:</span>Exp <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>env color<span class="token operator">=</span><span class="token string">&quot;violet&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>store color<span class="token operator">=</span><span class="token string">&quot;white&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>T<span class="token operator">&gt;</span>
</code></pre>
<h2 id="values-and-results">Values and results</h2>
<p>We only define integers, Booleans and strings as values here, but will<br>
add more values later.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span> <span class="token operator">|</span> <span class="token keyword">String</span>
  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
  <span class="token keyword">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
</code></pre>
<h2 id="lookup">Lookup</h2>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X<span class="token punctuation">:</span>Name <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
</code></pre>
<h2 id="arithmetic-expressions">Arithmetic expressions</h2>
<pre class="language-k"><code>  <span class="token keyword">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">*</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">/</span><span class="token keyword">Int</span> I2 when I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">%</span><span class="token keyword">Int</span> I2 when I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">+</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> S1 <span class="token operator">^</span> S2 <span class="token operator">=</span><span class="token operator">&gt;</span> S1 <span class="token operator">+</span><span class="token keyword">String</span> S2
  <span class="token keyword">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">-</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> <span class="token operator">-</span> I <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword">Int</span> I
  <span class="token keyword">rule</span> I1 <span class="token operator">&lt;</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&lt;</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">&gt;</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&gt;</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
  <span class="token keyword">rule</span> <span class="token operator">!</span> T <span class="token operator">=</span><span class="token operator">&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> E
  <span class="token keyword">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> E
</code></pre>
<h2 id="conditional">Conditional</h2>
<pre class="language-k"><code>  <span class="token keyword">rule</span> if  <span class="token boolean">true</span> then E else _ <span class="token operator">=</span><span class="token operator">&gt;</span> E
  <span class="token keyword">rule</span> if <span class="token boolean">false</span> then _ else E <span class="token operator">=</span><span class="token operator">&gt;</span> E
</code></pre>
<h2 id="lists">Lists</h2>
<p>We have already declared the syntactic list of expressions strict, so<br>
we can assume that all the elements that appear in a FUN list are<br>
evaluated.  The only thing left to do is to state that a list of<br>
values is a value itself, that is, that the list square-bracket<br>
construct is indeed a constructor, and to give the semantics of<br>
<code>cons</code>.  Since <code>cons</code> is a builtin function and is<br>
expected to take two arguments, we have to also state that<br>
<code>cons</code> itself is a value (specifically, a function/closure<br>
value, but we do not need that level of detail here), and also that<br>
<code>cons</code> applied to a value is a value (specifically, it would be<br>
a function/closure value that expects the second, list argument):</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> isVal<span class="token punctuation">(</span>cons<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">rule</span> isVal<span class="token punctuation">(</span>cons V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">rule</span> cons V<span class="token punctuation">:</span>Val <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>V<span class="token punctuation">,</span>Vs<span class="token punctuation">]</span>
</code></pre>
<h2 id="data-constructors">Data Constructors</h2>
<p>Constructors take values as arguments and produce other values:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ConstructorName
</code></pre>
<h2 id="functions-and-closures">Functions and Closures</h2>
<p>Like in the environment-based semantics of LAMBDA++ in the first part<br>
of the <strong>K</strong> tutorial, functions evaluate to closures.  A closure includes<br>
the current environment besides the function contents; the environment<br>
will be used at execution time to lookup all the variables that appear<br>
free in the function body (we want static scoping in FUN).</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> closure<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>Cases<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> fun Cases <span class="token operator">=</span><span class="token operator">&gt;</span> closure<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>Cases<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
</code></pre>
<p><strong>Note:</strong> The reader may want to get familiar with<br>
how the pre-defined pattern matching works before proceeding.<br>
The best way to do that is to consult<br>
<code>k/include/modules/pattern-matching.k</code>.</p>
<!--- To set up the pattern matching mechanism we need to specify what K
terms act as variables (for pattern matching, substitution, etc.).
This is currently done my subsorting those terms to the builtin
`Variable` sort.  In our case, we only want to allow the
`Name` identifiers to act as variables for pattern matching;
note that the `ConstructorName` identifiers are `not`
variables (they construct data values):

  syntax KVariable ::= Name
--->
<p>We distinguish two cases when the closure is applied.<br>
If the first pattern matches, then we pick the first case: switch to<br>
the closed environment, get the matching map and bind all its<br>
variables, and finally evaluate the function body of the first case,<br>
making sure that the environment is properly recovered afterwards.<br>
If the first pattern does not match, then we drop it and thus move on<br>
to the next one.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span> <span class="token operator">=</span><span class="token operator">&gt;</span> getMatching<span class="token punctuation">(</span>P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> closure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> P<span class="token operator">-</span><span class="token operator">&gt;</span>_ <span class="token operator">|</span> _<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> closure<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span> _<span class="token operator">-</span><span class="token operator">&gt;</span>E <span class="token operator">|</span> _<span class="token punctuation">)</span> _
           <span class="token operator">=</span><span class="token operator">&gt;</span> bindMap<span class="token punctuation">(</span>M<span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> E <span class="token operator">~</span><span class="token operator">&gt;</span> setEnv<span class="token punctuation">(</span>Rho&apos;<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho&apos; <span class="token operator">=</span><span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> <span class="token punctuation">(</span>matchFailure <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> closure<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">(</span>_<span class="token operator">-</span><span class="token operator">&gt;</span>_ <span class="token operator">|</span> Cs<span class="token punctuation">:</span>Cases <span class="token operator">=</span><span class="token operator">&gt;</span> Cs<span class="token punctuation">)</span><span class="token punctuation">)</span> _
<span class="token comment">//  rule &lt;k&gt; closure(Rho, P-&gt;E | _) V:Val</span>
<span class="token comment">//           =&gt; bindMap(getMatching(P,V)) ~&gt; E ~&gt; setEnv(Rho&apos;) ...&lt;/k&gt;</span>
<span class="token comment">//       &lt;env&gt; Rho&apos; =&gt; Rho &lt;/env&gt;  when isMatching(P,V)</span>
<span class="token comment">//  rule closure(_, (P-&gt;_ | Cs:Cases =&gt; Cs)) V:Val  when notBool isMatching(P,V)</span>
</code></pre>
<h2 id="let-and-letrec">Let and Letrec</h2>
<p>To highlight the similarities and differences between <code>let</code> and<br>
<code>letrec</code>, we prefer to give them direct semantics instead of<br>
to desugar them like in LAMBDA.  See the formal definitions of<br>
<code>bindTo</code>, <code>bind</code>, and <code>assignTo</code> at the end of<br>
this module.  Informally, <code>bindTo(Xs, Es)</code> first<br>
evaluates the expressions <code>Es</code> in <code>Exps</code> in the current<br>
environment (i.e., it is strict in its second argument), then it binds<br>
the variables in <code>Xs</code> in <code>Names</code> to new locations and adds<br>
those bindings to the environment, and finally writes the values<br>
previously obtained after evaluating the expressions <code>Es</code> to those<br>
new locations; <code>bind(Xs)</code> does only the bindings of<br>
<code>Xs</code> to new locations and adds those bindings to the environment;<br>
and <code>assignTo(Xs,Es)</code> evaluates the expressions<br>
<code>Es</code> in the current environment and then it writes the resulting<br>
values to the locations to which the variables <code>Xs</code> are already<br>
bound to in the environment.</p>
<p>Therefore, <code>let Xs = Es in E</code> first<br>
evaluates <code>Es</code> in the current environment, then adds new<br>
bindings for <code>Xs</code> to fresh locations in the environment, then<br>
writes the values of <code>Es</code> to those locations, and finally<br>
evaluates <code>E</code> in the new environment, making sure that the<br>
environment is properly recovered after the evaluation of <code>E</code>.<br>
On the other hand, <code>letrec</code> does the same things but in a<br>
different order: it first adds new bindings for <code>Xs</code> to fresh<br>
locations in the environment, then it evaluates <code>Es</code> in the new<br>
environment, then it writes the resulting values to their<br>
corresponding locations, and finally it evaluates <code>E</code> and<br>
recovers the environment.  The crucial difference is that the<br>
expressions <code>Es</code> now see the locations of the variables <code>Xs</code><br>
in the environment, so if they are functions, which is typically the<br>
case with <code>letrec</code>, their closures will encapsulate in their<br>
environments the bindings of all the bound variables, including<br>
themselves (thus, we may have a closure value stored at location<br>
<code>L</code>, whose environment contains a binding of the form<br>
<code>F &#x21A6; L</code>; this way, the closure can invoke<br>
itself).</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> let Bs in E
        <span class="token operator">=</span><span class="token operator">&gt;</span> bindTo<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> E <span class="token operator">~</span><span class="token operator">&gt;</span> setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> letrec Bs in E
        <span class="token operator">=</span><span class="token operator">&gt;</span> bind<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">~</span><span class="token operator">&gt;</span>assignTo<span class="token punctuation">(</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">~</span><span class="token operator">&gt;</span>E<span class="token operator">~</span><span class="token operator">&gt;</span>setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
</code></pre>
<p>Recall that our syntax allows <code>let</code> and <code>letrec</code> to<br>
take any expression in place of its binding.  This allows us to use<br>
the already existing function application construct to bind names to<br>
functions, such as, e.g., <code>let x y = y in ...</code>.<br>
The desugaring macro in the syntax module uncurries such declarations,<br>
and then the semantic rules above only work when the remaining<br>
bindings are identifiers, so the semantics will get stuck on programs<br>
that misuse the <code>let</code> and <code>letrec</code> binders.</p>
<h2 id="references">References</h2>
<p>The semantics of references is self-explanatory, except maybe for the<br>
desugaring rule of <code>ref</code>, which is further discussed.  Note<br>
that <code>&amp;X</code> grabs the location of <code>X</code> from the environment.<br>
Sequential composition, which is needed only to accumulate the<br>
side effects due to assignments, was strict in the first argument.<br>
Once evaluated, its first argument is simply discarded:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Name <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$x&quot;</span>
  <span class="token keyword">rule</span> ref <span class="token operator">=</span><span class="token operator">&gt;</span> fun $x <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> $x                                 <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token operator">&amp;</span> X <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> @ L<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token operator">=</span><span class="token operator">&gt;</span> V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> L<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token punctuation">:</span><span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>_<span class="token operator">=</span><span class="token operator">&gt;</span>V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> E
</code></pre>
<p>The desugaring rule of <code>ref</code> (first rule above) works<br>
because <code>&amp;</code> takes a variable and returns its location (like in C).<br>
Note that some ``pure&apos;&apos; functional programming researchers strongly dislike<br>
the <code>&amp;</code> construct, but favor <code>ref</code>.  We refrain from having<br>
a personal opinion on this issue here, but support <code>&amp;</code> in the<br>
environment-based definition of FUN because it is, technically speaking,<br>
more powerful than <code>ref</code>.  From a language design perspective, it<br>
would be equally easy to drop <code>&amp;</code> and instead give a direct<br>
semantics to <code>ref</code>.  In fact, this is precisely what we do in the<br>
substitution-based definition of FUN, because there appears to be no way<br>
to give a substitution-based definition to the <code>&amp;</code> construct.</p>
<h2 id="callcc">Callcc</h2>
<p>As we know it from the LAMBDA++ tutorial, call-with-current-continuation<br>
is quite easy to define in <strong>K</strong>.  We first need to define a special<br>
value wrapping an execution context, that is, an environment saying<br>
where the variables should be looked up, and a computation structure<br>
saying what is left to execute (in a substitution-based definition,<br>
this special value would be even simpler, as it would only need to<br>
wrap the computation structure---see, for example, the<br>
substitution-based semantics of LAMBDA++ in the the first part of the<br>
<strong>K</strong> tutorial, or the substitution-based definition of FUN).  Then<br>
<code>callcc</code> creates such a value containing the current<br>
environment and the current remaining computation, and passes it to<br>
its argument function.  When/If invoked, the special value replaces<br>
the current execution context with its own and continues the execution<br>
normally.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> cc<span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> isVal<span class="token punctuation">(</span>callcc<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token punctuation">(</span>callcc V<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V cc<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>K<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> K <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> cc<span class="token punctuation">(</span>Rho<span class="token punctuation">,</span>K<span class="token punctuation">)</span> V<span class="token punctuation">:</span>Val <span class="token operator">~</span><span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token operator">~</span><span class="token operator">&gt;</span> K <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
</code></pre>
<h2 id="auxiliary-operations">Auxiliary operations</h2>
<h2 id="environment-recovery">Environment recovery</h2>
<p>The environment recovery operation is the same as for the LAMBDA++<br>
language in the <strong>K</strong> tutorial and many other languages provided with the<br>
<strong>K</strong> distribution.  The first ``anywhere&apos;&apos; rule below shows an elegant<br>
way to achieve the benefits of tail recursion in <strong>K</strong>.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>  <span class="token comment">// TODO: get rid of env</span>
  <span class="token comment">//rule (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [anywhere]</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> _<span class="token punctuation">:</span>Val <span class="token operator">~</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="bindto%2C-bind-and-assignto"><code>bindTo</code>, <code>bind</code> and <code>assignTo</code></h2>
<p>The meaning of these operations has already been explained when we<br>
discussed the <code>let</code> and <code>letrec</code> language constructs<br>
above.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> bindTo<span class="token punctuation">(</span>Names<span class="token punctuation">,</span>Exps<span class="token punctuation">)</span>         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                 <span class="token operator">|</span> bindMap<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                 <span class="token operator">|</span> bind<span class="token punctuation">(</span>Names<span class="token punctuation">)</span>

  <span class="token keyword">rule</span> <span class="token punctuation">(</span><span class="token punctuation">.</span> <span class="token operator">=</span><span class="token operator">&gt;</span> getMatchingAux<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> bindTo<span class="token punctuation">(</span>Xs<span class="token punctuation">:</span>Names<span class="token punctuation">,</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> matchResult<span class="token punctuation">(</span>M<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> bindTo<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Names<span class="token punctuation">,</span> _<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> bindMap<span class="token punctuation">(</span>M<span class="token punctuation">)</span>

  <span class="token keyword">rule</span> bindMap<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> bindMap<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map<span class="token punctuation">)</span> _<span class="token punctuation">:</span>Map<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">=</span><span class="token operator">&gt;</span> Rho<span class="token punctuation">[</span>X <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">!</span>L<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">!</span>L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>

  <span class="token keyword">rule</span> bind<span class="token punctuation">(</span><span class="token punctuation">.</span>Names<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>                  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> bind<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token punctuation">,</span>Xs <span class="token operator">=</span><span class="token operator">&gt;</span> Xs<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Rho <span class="token operator">=</span><span class="token operator">&gt;</span> Rho<span class="token punctuation">[</span>X <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">!</span>L<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>

  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> assignTo<span class="token punctuation">(</span>Names<span class="token punctuation">,</span>Exps<span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> assignTo<span class="token punctuation">(</span><span class="token punctuation">.</span>Names<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>            <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> assignTo<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token punctuation">,</span>Xs <span class="token operator">=</span><span class="token operator">&gt;</span> Xs<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span>Vs<span class="token punctuation">:</span>Vals <span class="token operator">=</span><span class="token operator">&gt;</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>             <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="getters">Getters</h2>
<p>The following auxiliary operations extract the list of identifiers<br>
and of expressions in a binding, respectively.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> names<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> names<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Names
  <span class="token keyword">rule</span> names<span class="token punctuation">(</span>X<span class="token punctuation">:</span>Name<span class="token operator">=</span>_ and Bs<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>X<span class="token punctuation">,</span>names<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">:</span>Names

  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> exps<span class="token punctuation">(</span>Bindings<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> exps<span class="token punctuation">(</span><span class="token punctuation">.</span>Bindings<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Exps
  <span class="token keyword">rule</span> exps<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Name<span class="token operator">=</span>E and Bs<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> E<span class="token punctuation">,</span>exps<span class="token punctuation">(</span>Bs<span class="token punctuation">)</span>

  <span class="token comment">/* Extra kore stuff */</span>
  <span class="token keyword">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Names
  <span class="token keyword">syntax</span> Names <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms

  <span class="token comment">/* Matching */</span>
  <span class="token keyword">syntax</span> MatchResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getMatching<span class="token punctuation">(</span>Exp<span class="token punctuation">,</span> Val<span class="token punctuation">)</span>                      <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> getMatchingAux<span class="token punctuation">(</span>Exps<span class="token punctuation">,</span> Vals<span class="token punctuation">)</span>                 <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> mergeMatching<span class="token punctuation">(</span>MatchResult<span class="token punctuation">,</span> MatchResult<span class="token punctuation">)</span>    <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
                       <span class="token operator">|</span> matchResult<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
                       <span class="token operator">|</span> <span class="token string">&quot;matchFailure&quot;</span>

  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">(</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>Es<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token operator">=</span><span class="token operator">&gt;</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>C<span class="token punctuation">:</span>ConstructorName<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>B<span class="token punctuation">:</span><span class="token keyword">Bool</span><span class="token punctuation">,</span> B<span class="token punctuation">)</span>            <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">,</span> I<span class="token punctuation">)</span>             <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>S<span class="token punctuation">:</span><span class="token keyword">String</span><span class="token punctuation">,</span> S<span class="token punctuation">)</span>          <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>N<span class="token punctuation">:</span>Name<span class="token punctuation">,</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span>N <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchFailure        <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> mergeMatching<span class="token punctuation">(</span>getMatching<span class="token punctuation">(</span>E<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">,</span> getMatchingAux<span class="token punctuation">(</span>Es<span class="token punctuation">,</span> Vs<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">,</span> <span class="token punctuation">.</span>Vals<span class="token punctuation">)</span>                       <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span><span class="token punctuation">.</span>Map<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getMatchingAux<span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchFailure     <span class="token punctuation">[</span>owise<span class="token punctuation">]</span>

  <span class="token keyword">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>M1<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>M2<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchResult<span class="token punctuation">(</span>M1 M2<span class="token punctuation">)</span>
    <span class="token keyword">requires</span> intersectSet<span class="token punctuation">(</span>keys<span class="token punctuation">(</span>M1<span class="token punctuation">)</span><span class="token punctuation">,</span> keys<span class="token punctuation">(</span>M2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>K <span class="token punctuation">.</span>Set
  <span class="token comment">//rule mergeMatching(_, _) =&gt; matchFailure      [owsie]</span>
  <span class="token keyword">rule</span> mergeMatching<span class="token punctuation">(</span>matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchFailure
  <span class="token keyword">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchResult<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> matchFailure
  <span class="token keyword">rule</span> mergeMatching<span class="token punctuation">(</span>matchFailure<span class="token punctuation">,</span> matchFailure<span class="token punctuation">)</span>       <span class="token operator">=</span><span class="token operator">&gt;</span> matchFailure
</code></pre>
<p>Besides the generic decomposition rules for patterns and values,<br>
we also want to allow <code>[head|tail]</code> matching for lists, so we add<br>
the following custom pattern decomposition rule:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> getMatching<span class="token punctuation">(</span><span class="token punctuation">[</span>H<span class="token punctuation">:</span>Exp <span class="token operator">|</span> T<span class="token punctuation">:</span>Exp<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token operator">=</span><span class="token operator">&gt;</span> getMatchingAux<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token punctuation">[</span>Vs<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">endmodule</span>
</code></pre>
<p>Go to <a href="../../../2_substitution/fun-untyped/">Lesson 2, FUN untyped, Substitution-Based</a>.</p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
