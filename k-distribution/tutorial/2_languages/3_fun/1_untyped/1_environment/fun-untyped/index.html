<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1>FUN &#x2014; Untyped &#x2014; Environment</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2>Abstract</h2>
<p>This is the <strong>K</strong> semantic definition of the untyped FUN language.
FUN is a pedagogical and research language that captures the essence
of the functional programming paradigm, extended with several features
often encountered in functional programming languages.
Like many functional languages, FUN is an expression language, that
is, everything, including the main program, is an expression.
Functions can be declared anywhere and are first class values in the
language.
FUN is call-by-value here, but it has been extended (as student
homework assignments) with other parameter-passing styles.
To make it more interesting and to highlight some of <strong>K</strong>&apos;s strengths,
FUN includes the following features:</p>
<ul>
<li>
<p>The basic builtin data-types of integers, booleans and strings.</p>
</li>
<li>
<p>Builtin lists, which can hold any elements, including other lists.
Lists are enclosed in square brackets and their elements are
comma-separated; e.g., <code>[1,2,3]</code>.</p>
</li>
<li>
<p>User-defined data-types, by means of constructor terms.
Constructor names start with a capital letter (while any other
identifier in the language starts with a lowercase letter), and they
can be followed by an arbitrary number of comma-separated arguments
enclosed in parentheses; parentheses are not needed when the
constructor takes no arguments.
For example, <code>Pair(5,7)</code> is a constructor term holding two
numbers, <code>Cons(1,Cons(2,Cons(3,Nil)))</code> is a list-like
constructor term holding 3 elements, and
<code>Tree(Tree(Leaf(1), Leaf(2)), Leaf(3))</code> is a tree-like
constructor term holding 3 elements.
In the untyped version of the FUN language, no type checking or
inference is performed to ensure that the data constructors are used
correctly.
The execution will simply get stuck when they are misused.
Moreover, since no type checking is performed, the data-types are not
even declared in the untyped version of FUN.</p>
</li>
<li>
<p>Functions and <code>let</code>/<code>letrec</code> binders can take
multiple space-separated arguments, but these are desugared to
ones that only take one argument, by currying.  For example, the
expressions</p>
<pre class="hljs"><code>fun x y -&gt; x y
let x y = y in x
</code></pre>
<p>are desugared, respectively, into the following expressions:</p>
<pre class="hljs"><code>fun x -&gt; fun y -&gt; x y
let x = fun y -&gt; y in x
</code></pre>
</li>
<li>
<p>Functions can be defined using pattern matching over the
available data-types.  For example, the program</p>
<pre class="hljs"><code>letrec max = fun [h] -&gt; h
             |   [h|t] -&gt; let x = max t
                          in  if h &gt; x then h else x
in max [1, 3, 5, 2, 4, 0, -1, -5]
</code></pre>
<p>defines a function <code>max</code> that calculates the maximum element of
a non-empty list, and the function</p>
<pre class="hljs"><code>letrec ack = fun Pair(0,n) -&gt; n + 1
             |   Pair(m,0) -&gt; ack Pair(m - 1, 1)
             |   Pair(m,n) -&gt; ack Pair(m - 1, ack Pair(m, n - 1))
in ack Pair(2,3)
</code></pre>
<p>calculates the Ackermann function applied to a particular pair of numbers.
Patterns can be nested.  Patterns can currently only be used in function
definitions, and not directly in <code>let</code>/<code>letrec</code> binders.
For example, this is not allowed:</p>
<pre class="hljs"><code>letrec Pai(x,y) = Pair(1,2) in x+y
</code></pre>
<p>But this is allowed:</p>
<pre class="hljs"><code>let f Pair(x,y) = x+y in f Pair(1,2)
</code></pre>
<p>because it is first reduced to</p>
<pre class="hljs"><code>let f = fun Pair(x,y) -&gt; x+y in f Pair(1,2)
</code></pre>
<p>by uncurrying of the <code>let</code> binder, and pattern matching is
allowed in function arguments.</p>
</li>
<li>
<p>We include a <code>callcc</code> construct, for two reasons: first,
several functional languages support this construct; second, some
semantic frameworks have difficulties defining it.  Not <strong>K</strong>.</p>
</li>
<li>
<p>Finally, we include mutables by means of referencing an
expression, getting the reference of a variable, dereferencing and
assignment.  We include these for the same reasons as above: there are
languages which have them, and they are not easy to define in some
semantic frameworks.</p>
</li>
</ul>
<p>Like in many other languages, some of FUN&apos;s constructs can be
desugared into a smaller set of basic constructs.  We do that as usual,
using macros, and then we only give semantics to the core constructs.</p>
<p><strong>Note:</strong><br>
We recommend the reader to first consult the dynamic semantics of the
LAMBDA++ language in the first part of the K Tutorial.
To keep the comments below small and focused, we will not re-explain
functional or <strong>K</strong> features that have already been explained in there.</p>
<h2>Syntax</h2>
<pre class="hljs"><code><span class="hljs-comment">//require &quot;modules/pattern-matching.k&quot;</span><span class="hljs-keyword">

module</span> FUN-UNTYPED-COMMON<span class="hljs-keyword">
  imports</span> DOMAINS-SYNTAX
</code></pre>
<p>FUN is an expression language.  The constructs below fall into
several categories: names, arithmetic constructs, conventional
functional constructs, patterns and pattern matching, data constructs,
lists, references, and call-with-current-continuation (callcc).
The arithmetic constructs are standard; they are present in almost all
our <strong>K</strong> language definitions.  The meaning of FUN&apos;s constructs are
discussed in more depth when we define their semantics in the next
module.</p>
<h2>The Syntactic Constructs</h2>
<p>We start with the syntactic definition of FUN names.
We have several categories of names: ones to be used for functions and
variables, others to be used for data constructors, others for types and
others for type variables.  We will introduce them as needed, starting
with the former category.  We prefer the names of variables and functions
to start with lower case letters.  We take the freedom to tacitly introduce
syntactic lists/sequences for each nonterminal for which we need them:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Name<span class="hljs-keyword">
  syntax</span> Names ::= List{Name,<span class="hljs-string">&quot;,&quot;</span>}
</code></pre>
<p>Expression constructs will be defined throughtout the syntax module.
Below are the very basic ones, namely the builtins, the names, and the
parentheses used as brackets for grouping.  Lists of expressions are
declared strict, so all expressions in the list get evaluated whenever
the list is on a position which can be evaluated:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::=<span class="hljs-keyword"> Int</span> |<span class="hljs-keyword"> Bool</span> |<span class="hljs-keyword"> String</span> | Name
               | <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>                       [<span class="hljs-literal">bracket</span>]<span class="hljs-keyword">
  syntax</span> Exps  ::= List{Exp,<span class="hljs-string">&quot;,&quot;</span>}                   [<span class="hljs-literal">strict</span>]<span class="hljs-keyword">
  syntax</span> Val<span class="hljs-keyword">
  syntax</span> Vals ::= List{Val,<span class="hljs-string">&quot;,&quot;</span>}<span class="hljs-keyword">
  syntax</span> Bottom<span class="hljs-keyword">
  syntax</span> Bottoms ::= List{Bottom,<span class="hljs-string">&quot;,&quot;</span>}
</code></pre>
<p>We next define the syntax of arithmetic constructs, together with
their relative priorities and left-/non-associativities.  We also
tag all these rules with a new tag, &quot;arith&quot;, so we can more easily
define global syntax priirities later (at the end of the syntax module).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;*&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;/&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;%&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, arith]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;+&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>, arith]
               | Exp <span class="hljs-string">&quot;^&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>, arith]
<span class="hljs-comment">// left attribute should not be necessary; currently a parsing bug</span>
               | Exp <span class="hljs-string">&quot;-&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, <span class="hljs-literal">prefer</span>, arith]
<span class="hljs-comment">// the &quot;prefer&quot; attribute above is to not parse x-1 as x(-1)</span>
<span class="hljs-comment">// Due to some parsing problems, we currently cannot add unary minus:</span>
               | <span class="hljs-string">&quot;-&quot;</span> Exp                           [<span class="hljs-literal">strict</span>, arith]
               &gt; <span class="hljs-literal">non-assoc</span>:
                 Exp <span class="hljs-string">&quot;&lt;&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;&lt;=&quot;</span> Exp                      [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;&gt;&quot;</span> Exp                       [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;&gt;=&quot;</span> Exp                      [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;==&quot;</span> Exp                      [<span class="hljs-literal">strict</span>, arith]
               | Exp <span class="hljs-string">&quot;!=&quot;</span> Exp                      [<span class="hljs-literal">strict</span>, arith]
               &gt; <span class="hljs-string">&quot;!&quot;</span> Exp                           [<span class="hljs-literal">strict</span>, arith]
               &gt; Exp <span class="hljs-string">&quot;&amp;&amp;&quot;</span> Exp                      [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">left</span>, arith]
               &gt; Exp <span class="hljs-string">&quot;||&quot;</span> Exp                      [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">left</span>, arith]
</code></pre>
<p>The conditional construct has the expected evaluation strategy,
stating that only the first argument is evaluate:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;if&quot;</span> Exp <span class="hljs-string">&quot;then&quot;</span> Exp <span class="hljs-string">&quot;else&quot;</span> Exp    [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]
</code></pre>
<p>FUN&apos;s builtin lists are formed by enclosing comma-separated
sequences of expressions (i.e., terms of sort <code>Exps</code>) in square
brackets.  The list constructor <code>cons</code> adds a new element to the
top of the list, <code>head</code> and <code>tail</code> get the first element
and the tail sublist of a list if they exist, respectively, and get
stuck otherwise, and <code>null??</code> tests whether a list is empty or
not; syntactically, these are just expression constants.
In function patterns, we are also going to allow patterns following the
usual head/tail notation; for example, the pattern <code>[x_1,...,x_n|t]</code>
binds <code>x_1</code>, ..., <code>x_n</code> to the first elements of the matched list,
and <code>t</code> to the list formed with the remaining elements.  We define list
patterns as ordinary expression constructs, although we will make sure that
we do not give them semantics if they appear in any other place then in a
function case pattern.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;[&quot;</span> Exps <span class="hljs-string">&quot;]&quot;</span>                             [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;cons&quot;</span> |  <span class="hljs-string">&quot;head&quot;</span> | <span class="hljs-string">&quot;tail&quot;</span> | <span class="hljs-string">&quot;null?&quot;</span>
               | <span class="hljs-string">&quot;[&quot;</span> Exps <span class="hljs-string">&quot;|&quot;</span> Exp <span class="hljs-string">&quot;]&quot;</span><span class="hljs-keyword">
  syntax</span> Val ::= <span class="hljs-string">&quot;[&quot;</span> Vals <span class="hljs-string">&quot;]&quot;</span>
</code></pre>
<p>Data constructors start with capital letters and they may or may
not have arguments.  We need to use the attribute &quot;prefer&quot; to make
sure that, e.g., <code>Cons(a)</code> parses as constructor <code>Cons</code> with
argument <code>a</code>, and not as the expression <code>Cons</code> (because
constructor names are also expressions) regarded as a function applied
to the expression <code>a</code>.  Also, note that the constructor is strict
in its second argument, because we want to evaluate its arguments but
not the constuctor name itsef.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> ConstructorName<span class="hljs-keyword">
  syntax</span> Exp ::= ConstructorName
               | ConstructorName <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span>    [<span class="hljs-literal">prefer</span>, <span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]<span class="hljs-keyword">
  syntax</span> Val ::= ConstructorName <span class="hljs-string">&quot;(&quot;</span> Vals <span class="hljs-string">&quot;)&quot;</span>
</code></pre>
<p>A function is essentially a <code>|</code>-separated ordered
sequence of cases, each case of the form <code>pattern -&gt; expression</code>,
preceded by the language construct <code>fun</code>.  Patterns will be defined
shortly, both for the builtin lists and for user-defined constructors.
Recall that the syntax we define in <strong>K</strong> is not meant to serve as a
ultimate parser for the defined language, but rather as a convenient
notation for <strong>K</strong> abstract syntax trees, which we prefer when we write
the semantic rules.  It is therefore often the case that we define a
more ``generous&apos;&apos; syntax than we want to allow programs to use.
We do it here, too.  Specifically, the syntax of <code>Cases</code>
below allows any expressions to appear as pattern.  This syntactic
relaxation permits many wrong programs to be parsed, but that is not a
problem because we are not going to give semantics to wrong combinations,
so those programs will get stuck; moreover, our type inferencer will reject
those programs anyway.  Function application is just concatenation of
expressions, without worrying about type correctness.  Again, the type
system will reject type-incorrect programs.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;fun&quot;</span> Cases
               | Exp Exp                              [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We would like eventually to also have Exp &quot;(&quot; Exps &quot;)</span><span class="hljs-keyword">
  syntax</span> Case  ::= Exp <span class="hljs-string">&quot;-&gt;&quot;</span> Exp<span class="hljs-keyword">
  syntax</span> Cases ::= List{Case, <span class="hljs-string">&quot;|&quot;</span>}
</code></pre>
<p>The <code>let</code> and <code>letrec</code> binders have the usual syntax
and functional meaning.  We allow multiple <code>and</code>-separated bindings.
Like for the function cases above, we allow a more generous syntax for
the left-hand sides of bindings, noting that the semantics will get stuck
on incorrect bindings and that the type system will reject those programs.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;let&quot;</span> Bindings <span class="hljs-string">&quot;in&quot;</span> Exp
               | <span class="hljs-string">&quot;letrec&quot;</span> Bindings <span class="hljs-string">&quot;in&quot;</span> Exp                 [<span class="hljs-literal">prefer</span>]
<span class="hljs-comment">// The &quot;prefer&quot; attribute for letrec currently needed due to tool bug,</span>
<span class="hljs-comment">// to make sure that &quot;letrec&quot; is not parsed as &quot;let rec&quot;.</span><span class="hljs-keyword">
  syntax</span> Binding  ::= Exp <span class="hljs-string">&quot;=&quot;</span> Exp<span class="hljs-keyword">
  syntax</span> Bindings ::= List{Binding,<span class="hljs-string">&quot;and&quot;</span>}
</code></pre>
<p>References are first class values in FUN.  The construct <code>ref</code>
takes an expression, evaluates it, and then it stores the resulting value
at a fresh location in the store and returns that reference.  Syntactically,
<code>ref</code> is just an expression constant.  The construct <code>&amp;</code>
takes a name as argument and evaluates to a reference, namely the store
reference where the variable passed as argument stores its value; this
construct is a bit controversial and is further discussed in the
environment-based semantics of the FUN language, where we desugar
<code>ref</code> to it.  The construct <code>@</code> takes a reference
and evaluates to the value stored there.  The construct <code>:=</code> takes
two expressions, the first expected to evaluate to a reference; the value
of its second argument will be stored at the location to which the first
points (the old value is thus lost).  Finally, since expression evaluation
now has side effects, it makes sense to also add a sequential composition
construct, which is sequentially strict.  This evaluates to the value of
its second argument; the value of the first argument is lost (which has
therefore been evaluated only for its side effects.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;ref&quot;</span>
               | <span class="hljs-string">&quot;&amp;&quot;</span> Name
               | <span class="hljs-string">&quot;@&quot;</span> Exp                                     [<span class="hljs-literal">strict</span>]
               | Exp <span class="hljs-string">&quot;:=&quot;</span> Exp                                [<span class="hljs-literal">strict</span>]
               | Exp <span class="hljs-string">&quot;;&quot;</span> Exp                       [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">right</span>]
</code></pre>
<p>Call-with-current-continuation, named <code>callcc</code> in FUN, is a
powerful control operator that originated in the Scheme programming
language, but it now exists in many other functional languages.  It works
by evaluating its argument, expected to evaluate to a function, and by
passing the current continuation, or evaluation context (or computation,
in <strong>K</strong> terminology), as a special value to it.  When/If this special value
is invoked, the current context is discarded and replaced with the one
held by the special value and the computation continues from there.
It is like taking a snapshot of the execution context at some moment
in time and then, when desired, being able to get back in time to that
point.  If you like games, it is like saving the game now (so you can
work on your homework!) and then continuing the game tomorrow or whenever
you wish.  To issustrate the strength of <code>callcc</code>, we also
allow exceptions in FUN by means of a conventional <code>try-catch</code>
construct, which will desugar to <code>callcc</code>.  We also need to
introduce the special expression contant <code>throw</code>, but we need to
use it as a function argument name in the desugaring macro, so we define
it as a name instead of as an expression constant:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;callcc&quot;</span>
               | <span class="hljs-string">&quot;try&quot;</span> Exp <span class="hljs-string">&quot;catch&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Name <span class="hljs-string">&quot;)&quot;</span> Exp<span class="hljs-keyword">
  syntax</span> Name ::= <span class="hljs-string">&quot;throw&quot;</span> [<span class="hljs-literal">token</span>]
</code></pre>
<p>Finally, FUN also allows polymorphic datatype declarations.  These
will be useful when we define the type system later on.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= <span class="hljs-string">&quot;datatype&quot;</span> Type <span class="hljs-string">&quot;=&quot;</span> TypeCases Exp
<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> In a future version of K, we want the datatype declaration</span>
<span class="hljs-comment">// to be a construct by itself, but that is not possible currently</span>
<span class="hljs-comment">// because K&apos;s parser wronly identifies the __ operation allowing</span>
<span class="hljs-comment">// a declaration to appear in front of an expression with the function</span>
<span class="hljs-comment">// application construct, giving ambiguous parsing errors.</span>
</code></pre>
<p>We next need to define the syntax of types and type cases that appear
in datatype declarations.</p>
<p>Like in many functional languages, type parameters/variables in
user-defined types are quoted identifiers.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> TypeVar<span class="hljs-keyword">
  syntax</span> TypeVars ::= List{TypeVar,<span class="hljs-string">&quot;,&quot;</span>}
</code></pre>
<p>Types can be basic types, function types, or user-defined
parametric types.  In the dynamic semantics we are going to simply ignore
all the type declations, so here the syntax of types below is only useful
for generating the desired parser.  To avoid syntactic ambiguities with
the arrow construct for function cases, we use the symbol <code>--&gt;</code> as
a constructor for function types:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> TypeName<span class="hljs-keyword">
  syntax</span> Type ::= <span class="hljs-string">&quot;int&quot;</span> | <span class="hljs-string">&quot;bool&quot;</span> | <span class="hljs-string">&quot;string&quot;</span>
                | Type <span class="hljs-string">&quot;--&gt;&quot;</span> Type                            [<span class="hljs-literal">right</span>]
                | <span class="hljs-string">&quot;(&quot;</span> Type <span class="hljs-string">&quot;)&quot;</span>                             [<span class="hljs-literal">bracket</span>]
                | TypeVar
                | TypeName             [klabel(TypeName), <span class="hljs-literal">avoid</span>]
                | Type TypeName   [klabel(Type-TypeName)]
                | <span class="hljs-string">&quot;(&quot;</span> Types <span class="hljs-string">&quot;)&quot;</span> TypeName                    [<span class="hljs-literal">prefer</span>]<span class="hljs-keyword">
  syntax</span> Types ::= List{Type,<span class="hljs-string">&quot;,&quot;</span>}<span class="hljs-keyword">
  syntax</span> Types ::= TypeVars<span class="hljs-keyword">

  syntax</span> TypeCase ::= ConstructorName
                    | ConstructorName <span class="hljs-string">&quot;(&quot;</span> Types <span class="hljs-string">&quot;)&quot;</span><span class="hljs-keyword">
  syntax</span> TypeCases ::= List{TypeCase,<span class="hljs-string">&quot;|&quot;</span>}     [klabel(_|TypeCase_)]
</code></pre>
<h2>Additional Priorities</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> priorities @__FUN-UNTYPED-COMMON
                  &gt; ___FUN-UNTYPED-COMMON
                  &gt; arith
                  &gt; _:=__FUN-UNTYPED-COMMON
                  &gt; let_in__FUN-UNTYPED-COMMON
                    letrec_in__FUN-UNTYPED-COMMON
                    if_then_else__FUN-UNTYPED-COMMON
                  &gt; _;__FUN-UNTYPED-COMMON
                  &gt; fun__FUN-UNTYPED-COMMON
                  &gt; datatype_=___FUN-UNTYPED-COMMON<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> FUN-UNTYPED-MACROS<span class="hljs-keyword">
  imports</span> FUN-UNTYPED-COMMON
</code></pre>
<h2>Desugaring macros</h2>
<p>We desugar the list non-constructor operations to functions matching
over list patterns.  In order to do that we need some new variables; for
those, we follow the same convention like in the <strong>K</strong> tutorial, where we
added them as new identifier constructs starting with the character <code>$</code>,
so we can easily recognize them when we debug or trace the semantics.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Name ::= <span class="hljs-string">&quot;$h&quot;</span> | <span class="hljs-string">&quot;$t&quot;</span><span class="hljs-keyword">
  rule</span> head =&gt; fun [$h|$t] -&gt; $h                             [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> tail =&gt; fun [$h|$t] -&gt; $t                             [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> null? =&gt; fun [.Exps] -&gt; true | [$h|$t] -&gt; false       [<span class="hljs-literal">macro</span>]
</code></pre>
<p>Multiple-head list patterns desugar into successive one-head patterns:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> [E1,E2,Es:Exps|T] =&gt; [E1|[E2,Es|T]]                   [<span class="hljs-literal">macro</span>-rec]
</code></pre>
<p>Uncurrying of multiple arguments in functions and binders:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> P1 P2 -&gt; E =&gt; P1 -&gt; fun P2 -&gt; E                       [<span class="hljs-literal">macro</span>-rec]<span class="hljs-keyword">
  rule</span> F P = E =&gt; F = fun P -&gt; E                             [<span class="hljs-literal">macro</span>-rec]
</code></pre>
<p>We desugar the <code>try-catch</code> construct into callcc:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Name ::= <span class="hljs-string">&quot;$k&quot;</span> | <span class="hljs-string">&quot;$v&quot;</span><span class="hljs-keyword">
  rule</span> try E catch(X) E&apos;
    =&gt; callcc (fun $k -&gt; (fun throw -&gt; E)(fun X -&gt; $k E&apos;))   [<span class="hljs-literal">macro</span>]
</code></pre>
<p>For uniformity, we reduce all types to their general form:</p>
<pre class="hljs"><code><span class="hljs-comment">//  rule TypeName(Tn:TypeName) =&gt; (.TypeVars) Tn               [macro]</span><span class="hljs-keyword">
  rule</span> `Type-TypeName`(T:Type, Tn:TypeName) =&gt; (T) Tn          [<span class="hljs-literal">macro</span>]
</code></pre>
<p>The dynamic semantics ignores all the type declarations:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> datatype T = TCs E =&gt; E                               [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">


module</span> FUN-UNTYPED-SYNTAX<span class="hljs-keyword">
  imports</span> FUN-UNTYPED-COMMON<span class="hljs-keyword">
  imports</span> BUILTIN-ID-TOKENS<span class="hljs-keyword">

  syntax</span> Name ::= r<span class="hljs-string">&quot;[a-z][_a-zA-Z0-9]*&quot;</span>           [<span class="hljs-literal">token</span>, prec(<span class="hljs-number">2</span>)]
                | #LowerId                        [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
  syntax</span> ConstructorName ::= #UpperId             [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
  syntax</span> TypeVar  ::= r<span class="hljs-string">&quot;[&apos;][a-z][_a-zA-Z0-9]*&quot;</span>    [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
  syntax</span> TypeName ::= Name                        [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Semantics</h2>
<p>The semantics below is environment-based.  A substitution-based
definition of FUN is also available, but that drops the <code>&amp;</code>
construct as explained above.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> FUN-UNTYPED<span class="hljs-keyword">
  imports</span> FUN-UNTYPED-COMMON<span class="hljs-keyword">
  imports</span> FUN-UNTYPED-MACROS<span class="hljs-keyword">
  imports</span> DOMAINS
  <span class="hljs-comment">//imports PATTERN-MATCHING</span>
</code></pre>
<h2>Configuration</h2>
<p>The <code>k</code>, <code>env</code>, and <code>store</code> cells are standard
(see, for example, the definition of LAMBDA++ or IMP++ in the first
part of the <strong>K</strong> tutorial).</p>
<pre class="hljs"><code><span class="hljs-keyword">  configuration</span> &lt;T color=<span class="hljs-string">&quot;yellow&quot;</span>&gt;
                  &lt;k color=<span class="hljs-string">&quot;green&quot;</span>&gt; $PGM:Exp &lt;/k&gt;
                  &lt;env color=<span class="hljs-string">&quot;violet&quot;</span>&gt; .Map &lt;/env&gt;
                  &lt;store color=<span class="hljs-string">&quot;white&quot;</span>&gt; .Map &lt;/store&gt;
                &lt;/T&gt;
</code></pre>
<h2>Values and results</h2>
<p>We only define integers, Booleans and strings as values here, but will
add more values later.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Val ::=<span class="hljs-keyword"> Int</span> |<span class="hljs-keyword"> Bool</span> |<span class="hljs-keyword"> String</span><span class="hljs-keyword">
  syntax</span> Exp ::= Val<span class="hljs-keyword">
  syntax</span> Exps ::= Vals<span class="hljs-keyword">
  syntax</span> Vals ::= Bottoms<span class="hljs-keyword">
  syntax</span> KResult ::= Val
</code></pre>
<h2>Lookup</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; X:Name =&gt; V ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V ...&lt;/store&gt;
</code></pre>
<h2>Arithmetic expressions</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> I1 * I2 =&gt; I1 *<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 / I2 =&gt; I1 /<span class="hljs-keyword">Int</span> I2 when I2 =/=K <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> I1 % I2 =&gt; I1 %<span class="hljs-keyword">Int</span> I2 when I2 =/=K <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> I1 + I2 =&gt; I1 +<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> S1 ^ S2 =&gt; S1 +<span class="hljs-keyword">String</span> S2<span class="hljs-keyword">
  rule</span> I1 - I2 =&gt; I1 -<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> - I =&gt; <span class="hljs-number">0</span> -<span class="hljs-keyword">Int</span> I<span class="hljs-keyword">
  rule</span> I1 &lt; I2 =&gt; I1 &lt;<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 &lt;= I2 =&gt; I1 &lt;=<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 &gt; I2 =&gt; I1 &gt;<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 &gt;= I2 =&gt; I1 &gt;=<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> V1:Val == V2:Val =&gt; V1 ==K V2<span class="hljs-keyword">
  rule</span> V1:Val != V2:Val =&gt; V1 =/=K V2<span class="hljs-keyword">
  rule</span> ! T =&gt; notBool(T)<span class="hljs-keyword">
  rule</span> true  &amp;&amp; E =&gt; E<span class="hljs-keyword">
  rule</span> false &amp;&amp; _ =&gt; false<span class="hljs-keyword">
  rule</span> true  || _ =&gt; true<span class="hljs-keyword">
  rule</span> false || E =&gt; E
</code></pre>
<h2>Conditional</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> if  true then E else _ =&gt; E<span class="hljs-keyword">
  rule</span> if false then _ else E =&gt; E
</code></pre>
<h2>Lists</h2>
<p>We have already declared the syntactic list of expressions strict, so
we can assume that all the elements that appear in a FUN list are
evaluated.  The only thing left to do is to state that a list of
values is a value itself, that is, that the list square-bracket
construct is indeed a constructor, and to give the semantics of
<code>cons</code>.  Since <code>cons</code> is a builtin function and is
expected to take two arguments, we have to also state that
<code>cons</code> itself is a value (specifically, a function/closure
value, but we do not need that level of detail here), and also that
<code>cons</code> applied to a value is a value (specifically, it would be
a function/closure value that expects the second, list argument):</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> isVal(cons) =&gt; true<span class="hljs-keyword">
  rule</span> isVal(cons V:Val) =&gt; true<span class="hljs-keyword">
  rule</span> cons V:Val [Vs:Vals] =&gt; [V,Vs]
</code></pre>
<h2>Data Constructors</h2>
<p>Constructors take values as arguments and produce other values:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Val ::= ConstructorName
</code></pre>
<h2>Functions and Closures</h2>
<p>Like in the environment-based semantics of LAMBDA++ in the first part
of the <strong>K</strong> tutorial, functions evaluate to closures.  A closure includes
the current environment besides the function contents; the environment
will be used at execution time to lookup all the variables that appear
free in the function body (we want static scoping in FUN).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Val ::= closure(Map,Cases)<span class="hljs-keyword">
  rule</span> &lt;k&gt; fun Cases =&gt; closure(Rho,Cases) ...&lt;/k&gt;  &lt;env&gt; Rho &lt;/env&gt;
</code></pre>
<p><strong>Note:</strong> The reader may want to get familiar with
how the pre-defined pattern matching works before proceeding.
The best way to do that is to consult
<code>k/include/modules/pattern-matching.k</code>.</p>
<!--- To set up the pattern matching mechanism we need to specify what K
terms act as variables (for pattern matching, substitution, etc.).
This is currently done my subsorting those terms to the builtin
`Variable` sort.  In our case, we only want to allow the
`Name` identifiers to act as variables for pattern matching;
note that the `ConstructorName` identifiers are `not`
variables (they construct data values):

  syntax KVariable ::= Name
--->
<p>We distinguish two cases when the closure is applied.
If the first pattern matches, then we pick the first case: switch to
the closed environment, get the matching map and bind all its
variables, and finally evaluate the function body of the first case,
making sure that the environment is properly recovered afterwards.
If the first pattern does not match, then we drop it and thus move on
to the next one.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> (. =&gt; getMatching(P, V)) ~&gt; closure(_, P-&gt;_ | _) V:Val<span class="hljs-keyword">
  rule</span> &lt;k&gt; matchResult(M:Map) ~&gt; closure(Rho, _-&gt;E | _) _
           =&gt; bindMap(M) ~&gt; E ~&gt; setEnv(Rho&apos;) ...&lt;/k&gt;
       &lt;env&gt; Rho&apos; =&gt; Rho &lt;/env&gt;<span class="hljs-keyword">
  rule</span> (matchFailure =&gt; .) ~&gt; closure(_, (_-&gt;_ | Cs:Cases =&gt; Cs)) _
<span class="hljs-comment">//  rule &lt;k&gt; closure(Rho, P-&gt;E | _) V:Val</span>
<span class="hljs-comment">//           =&gt; bindMap(getMatching(P,V)) ~&gt; E ~&gt; setEnv(Rho&apos;) ...&lt;/k&gt;</span>
<span class="hljs-comment">//       &lt;env&gt; Rho&apos; =&gt; Rho &lt;/env&gt;  when isMatching(P,V)</span>
<span class="hljs-comment">//  rule closure(_, (P-&gt;_ | Cs:Cases =&gt; Cs)) V:Val  when notBool isMatching(P,V)</span>
</code></pre>
<h2>Let and Letrec</h2>
<p>To highlight the similarities and differences between <code>let</code> and
<code>letrec</code>, we prefer to give them direct semantics instead of
to desugar them like in LAMBDA.  See the formal definitions of
<code>bindTo</code>, <code>bind</code>, and <code>assignTo</code> at the end of
this module.  Informally, <code>bindTo(Xs, Es)</code> first
evaluates the expressions <code>Es</code> in <code>Exps</code> in the current
environment (i.e., it is strict in its second argument), then it binds
the variables in <code>Xs</code> in <code>Names</code> to new locations and adds
those bindings to the environment, and finally writes the values
previously obtained after evaluating the expressions <code>Es</code> to those
new locations; <code>bind(Xs)</code> does only the bindings of
<code>Xs</code> to new locations and adds those bindings to the environment;
and <code>assignTo(Xs,Es)</code> evaluates the expressions
<code>Es</code> in the current environment and then it writes the resulting
values to the locations to which the variables <code>Xs</code> are already
bound to in the environment.</p>
<p>Therefore, <code>let Xs = Es in E</code> first
evaluates <code>Es</code> in the current environment, then adds new
bindings for <code>Xs</code> to fresh locations in the environment, then
writes the values of <code>Es</code> to those locations, and finally
evaluates <code>E</code> in the new environment, making sure that the
environment is properly recovered after the evaluation of <code>E</code>.
On the other hand, <code>letrec</code> does the same things but in a
different order: it first adds new bindings for <code>Xs</code> to fresh
locations in the environment, then it evaluates <code>Es</code> in the new
environment, then it writes the resulting values to their
corresponding locations, and finally it evaluates <code>E</code> and
recovers the environment.  The crucial difference is that the
expressions <code>Es</code> now see the locations of the variables <code>Xs</code>
in the environment, so if they are functions, which is typically the
case with <code>letrec</code>, their closures will encapsulate in their
environments the bindings of all the bound variables, including
themselves (thus, we may have a closure value stored at location
<code>L</code>, whose environment contains a binding of the form
<code>F &#x21A6; L</code>; this way, the closure can invoke
itself).</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; let Bs in E
        =&gt; bindTo(names(Bs),exps(Bs)) ~&gt; E ~&gt; setEnv(Rho) ...&lt;/k&gt;
       &lt;env&gt; Rho &lt;/env&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; letrec Bs in E
        =&gt; bind(names(Bs))~&gt;assignTo(names(Bs),exps(Bs))~&gt;E~&gt;setEnv(Rho)...&lt;/k&gt;
       &lt;env&gt; Rho &lt;/env&gt;
</code></pre>
<p>Recall that our syntax allows <code>let</code> and <code>letrec</code> to
take any expression in place of its binding.  This allows us to use
the already existing function application construct to bind names to
functions, such as, e.g., <code>let x y = y in ...</code>.
The desugaring macro in the syntax module uncurries such declarations,
and then the semantic rules above only work when the remaining
bindings are identifiers, so the semantics will get stuck on programs
that misuse the <code>let</code> and <code>letrec</code> binders.</p>
<h2>References</h2>
<p>The semantics of references is self-explanatory, except maybe for the
desugaring rule of <code>ref</code>, which is further discussed.  Note
that <code>&amp;X</code> grabs the location of <code>X</code> from the environment.
Sequential composition, which is needed only to accumulate the
side effects due to assignments, was strict in the first argument.
Once evaluated, its first argument is simply discarded:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Name ::= <span class="hljs-string">&quot;$x&quot;</span><span class="hljs-keyword">
  rule</span> ref =&gt; fun $x -&gt; &amp; $x                                 [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; &amp; X =&gt; L ...&lt;/k&gt;  &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;<span class="hljs-keyword">
  rule</span> &lt;k&gt; @ L:<span class="hljs-keyword">Int</span> =&gt; V:Val ...&lt;/k&gt;  &lt;store&gt;... L |-&gt; V ...&lt;/store&gt;<span class="hljs-keyword">
  rule</span> &lt;k&gt; L:<span class="hljs-keyword">Int</span> := V:Val =&gt; V ...&lt;/k&gt;  &lt;store&gt;... L |-&gt; (_=&gt;V) ...&lt;/store&gt;<span class="hljs-keyword">
  rule</span> V:Val; E =&gt; E
</code></pre>
<p>The desugaring rule of <code>ref</code> (first rule above) works
because <code>&amp;</code> takes a variable and returns its location (like in C).
Note that some ``pure&apos;&apos; functional programming researchers strongly dislike
the <code>&amp;</code> construct, but favor <code>ref</code>.  We refrain from having
a personal opinion on this issue here, but support <code>&amp;</code> in the
environment-based definition of FUN because it is, technically speaking,
more powerful than <code>ref</code>.  From a language design perspective, it
would be equally easy to drop <code>&amp;</code> and instead give a direct
semantics to <code>ref</code>.  In fact, this is precisely what we do in the
substitution-based definition of FUN, because there appears to be no way
to give a substitution-based definition to the <code>&amp;</code> construct.</p>
<h2>Callcc</h2>
<p>As we know it from the LAMBDA++ tutorial, call-with-current-continuation
is quite easy to define in <strong>K</strong>.  We first need to define a special
value wrapping an execution context, that is, an environment saying
where the variables should be looked up, and a computation structure
saying what is left to execute (in a substitution-based definition,
this special value would be even simpler, as it would only need to
wrap the computation structure---see, for example, the
substitution-based semantics of LAMBDA++ in the the first part of the
<strong>K</strong> tutorial, or the substitution-based definition of FUN).  Then
<code>callcc</code> creates such a value containing the current
environment and the current remaining computation, and passes it to
its argument function.  When/If invoked, the special value replaces
the current execution context with its own and continues the execution
normally.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Val ::= cc(Map,K)<span class="hljs-keyword">
  rule</span> isVal(callcc) =&gt; true<span class="hljs-keyword">
  rule</span> &lt;k&gt; (callcc V:Val =&gt; V cc(Rho,K)) ~&gt; K &lt;/k&gt;  &lt;env&gt; Rho &lt;/env&gt;<span class="hljs-keyword">
  rule</span> &lt;k&gt; cc(Rho,K) V:Val ~&gt; _ =&gt; V ~&gt; K &lt;/k&gt;  &lt;env&gt; _ =&gt; Rho &lt;/env&gt;
</code></pre>
<h2>Auxiliary operations</h2>
<h2>Environment recovery</h2>
<p>The environment recovery operation is the same as for the LAMBDA++
language in the <strong>K</strong> tutorial and many other languages provided with the
<strong>K</strong> distribution.  The first ``anywhere&apos;&apos; rule below shows an elegant
way to achieve the benefits of tail recursion in <strong>K</strong>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= setEnv(Map)  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> get rid of env</span>
  <span class="hljs-comment">//rule (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [anywhere]</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; _:Val ~&gt; (setEnv(Rho) =&gt; .) ...&lt;/k&gt; &lt;env&gt; _ =&gt; Rho &lt;/env&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2><code>bindTo</code>, <code>bind</code> and <code>assignTo</code></h2>
<p>The meaning of these operations has already been explained when we
discussed the <code>let</code> and <code>letrec</code> language constructs
above.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= bindTo(Names,Exps)         [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]
                 | bindMap(Map)
                 | bind(Names)<span class="hljs-keyword">

  rule</span> (. =&gt; getMatchingAux(Xs,Vs)) ~&gt; bindTo(Xs:Names,Vs:Vals)<span class="hljs-keyword">
  rule</span> matchResult(M:Map) ~&gt; bindTo(_:Names, _:Vals) =&gt; bindMap(M)<span class="hljs-keyword">

  rule</span> bindMap(.Map) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; bindMap((X:Name |-&gt; V:Val =&gt; .Map) _:Map) ...&lt;/k&gt;
       &lt;env&gt; Rho =&gt; Rho[X &lt;- !L:<span class="hljs-keyword">Int</span>] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; !L |-&gt; V ...&lt;/store&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> bind(.Names) =&gt; .                  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; bind(X:Name,Xs =&gt; Xs) ...&lt;/k&gt;
       &lt;env&gt; Rho =&gt; Rho[X &lt;- !L:<span class="hljs-keyword">Int</span>] &lt;/env&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  syntax</span> KItem ::= assignTo(Names,Exps)  [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]<span class="hljs-keyword">

  rule</span> &lt;k&gt; assignTo(.Names,.Vals) =&gt; . ...&lt;/k&gt;            [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; assignTo((X:Name,Xs =&gt; Xs),(V:Val,Vs:Vals =&gt; Vs)) ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; V ...&lt;/store&gt;             [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Getters</h2>
<p>The following auxiliary operations extract the list of identifiers
and of expressions in a binding, respectively.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Names ::= names(Bindings)  [function]<span class="hljs-keyword">
  rule</span> names(.Bindings) =&gt; .Names<span class="hljs-keyword">
  rule</span> names(X:Name=_ and Bs) =&gt; (X,names(Bs))::Names<span class="hljs-keyword">

  syntax</span> Exps ::= exps(Bindings)  [function]<span class="hljs-keyword">
  rule</span> exps(.Bindings) =&gt; .Exps<span class="hljs-keyword">
  rule</span> exps(_:Name=E and Bs) =&gt; E,exps(Bs)

  <span class="hljs-comment">/* Extra kore stuff */</span><span class="hljs-keyword">
  syntax</span> KResult ::= Vals<span class="hljs-keyword">
  syntax</span> Exps ::= Names<span class="hljs-keyword">
  syntax</span> Names ::= Bottoms

  <span class="hljs-comment">/* Matching */</span><span class="hljs-keyword">
  syntax</span> MatchResult ::= getMatching(Exp, Val)                      [function]
                       | getMatchingAux(Exps, Vals)                 [function]
                       | mergeMatching(MatchResult, MatchResult)    [function]
                       | matchResult(Map)
                       | <span class="hljs-string">&quot;matchFailure&quot;</span><span class="hljs-keyword">

  rule</span> getMatching(C:ConstructorName(Es:Exps), C(Vs:Vals)) =&gt; getMatchingAux(Es, Vs)<span class="hljs-keyword">
  rule</span> getMatching([Es:Exps], [Vs:Vals])                   =&gt; getMatchingAux(Es, Vs)<span class="hljs-keyword">
  rule</span> getMatching(C:ConstructorName, C) =&gt; matchResult(.Map)<span class="hljs-keyword">
  rule</span> getMatching(B:<span class="hljs-keyword">Bool</span>, B)            =&gt; matchResult(.Map)<span class="hljs-keyword">
  rule</span> getMatching(I:<span class="hljs-keyword">Int</span>, I)             =&gt; matchResult(.Map)<span class="hljs-keyword">
  rule</span> getMatching(S:<span class="hljs-keyword">String</span>, S)          =&gt; matchResult(.Map)<span class="hljs-keyword">
  rule</span> getMatching(N:Name, V:Val) =&gt; matchResult(N |-&gt; V)<span class="hljs-keyword">
  rule</span> getMatching(_, _) =&gt; matchFailure        [owise]<span class="hljs-keyword">

  rule</span> getMatchingAux((E:Exp, Es:Exps), (V:Val, Vs:Vals)) =&gt; mergeMatching(getMatching(E, V), getMatchingAux(Es, Vs))<span class="hljs-keyword">
  rule</span> getMatchingAux(.Exps, .Vals)                       =&gt; matchResult(.Map)<span class="hljs-keyword">
  rule</span> getMatchingAux(_, _) =&gt; matchFailure     [owise]<span class="hljs-keyword">

  rule</span> mergeMatching(matchResult(M1:Map), matchResult(M2:Map)) =&gt; matchResult(M1 M2)<span class="hljs-keyword">
    requires</span> intersectSet(keys(M1), keys(M2)) ==K .Set
  <span class="hljs-comment">//rule mergeMatching(_, _) =&gt; matchFailure      [owsie]</span><span class="hljs-keyword">
  rule</span> mergeMatching(matchResult(_:Map), matchFailure) =&gt; matchFailure<span class="hljs-keyword">
  rule</span> mergeMatching(matchFailure, matchResult(_:Map)) =&gt; matchFailure<span class="hljs-keyword">
  rule</span> mergeMatching(matchFailure, matchFailure)       =&gt; matchFailure
</code></pre>
<p>Besides the generic decomposition rules for patterns and values,
we also want to allow <code>[head|tail]</code> matching for lists, so we add
the following custom pattern decomposition rule:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> getMatching([H:Exp | T:Exp], [V:Val, Vs:Vals])
    =&gt; getMatchingAux((H, T), (V, [Vs]))<span class="hljs-keyword">
endmodule</span>
</code></pre>
<p>Go to <a href="../../2_substitution/fun-untyped/">Lesson 2, FUN untyped, Substitution-Based</a>.</p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
