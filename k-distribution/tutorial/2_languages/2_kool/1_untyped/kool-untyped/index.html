<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1>KOOL &#x2014; Untyped</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2>Abstract</h2>
<p>This is the <strong>K</strong> semantic definition of the untyped KOOL language.  KOOL
is aimed at being a pedagogical and research language that captures
the essence of the object-oriented programming paradigm.  Its untyped
variant discussed here is simpler than the typed one, ignoring several
intricate aspects of types in the presence of objects.  A program
consists of a set of class declarations.  Each class can extend at
most one other class (KOOL is single-inheritance).  A class can
declare a set of fields and a set of methods, all public and called
the class&apos; <em>members</em>.  Specifically, KOOL includes the
following features:</p>
<ul>
<li>
<p>Class declarations, where a class may or may not explicitly
extend another class.  In case a class does not explicitly extend
another class, then it is assumed that it extends the default top-most
and empty (i.e., no members) class called <code>Object</code>.  Each class
is required to declare precisely one homonymous method, called its
<em>constructor</em>.  Each valid program should contain one class
named <code>Main</code>, whose constructor, <code>Main()</code>, takes no
arguments.  The execution of a program consists of creating an object
instance of class <code>Main</code> and invoking the constructor
<code>Main()</code> on it, that is, of executing <code>new Main();</code>.</p>
</li>
<li>
<p>All features of SIMPLE (see <code>examples/simple/untyped</code>),
i.e., multidimensional arrays, function (here called &quot;method&quot;)
abstractions with call-by-value parameter passing style and static
scoping, blocks with locals, input/output, parametric exceptions, and
concurrency via dynamic thread creation/termination and synchronization.
The only change in the syntax of SIMPLE when imported in KOOL is the
function declaration keyword, <code>function</code>, which is changed into
<code>method</code>.  The exact same desugaring macros from SIMPLE are
also included in KOOL.  We can think of KOOL&apos;s classes as embedding
SIMPLE programs (extended with OO constructs, as discussed next).</p>
</li>
<li>
<p>Object creation using the <code>new C(e1,...,en)</code>
expression construct.  An object instance of class <code>C</code> is first
created and then the constructor <code>C(e1,...,en)</code> is implicitly
called on that object.  KOOL only allows (and requires) one
constructor per class.  The class constructor can be called either
implicitly during a new object creation for the class, or explicitly.
The superclass constructor is <strong>not</strong> implicitly invoked when a
class constructor is invoked; if you want to invoke the superclass
constructor from a subclass constructor then you have to do it
explicitly.</p>
</li>
<li>
<p>An expression construct <code>this</code>, which evaluates to the
current object.</p>
</li>
<li>
<p>An expression construct <code>super</code>, which is used (only) in
combination with member lookup (see next) to refer to a superclass
field or method.</p>
</li>
<li>
<p>A member lookup expression construct <code>e.x</code>, where <code>e</code>
is an expression (either an expression expected to evaluate to an object
or the <code>super</code> construct) and <code>x</code> is a class member name,
that is, a field or a method name.</p>
</li>
<li>
<p>Expression constructs <code>e instanceOf C</code> and
<code>(C) e</code>, where <code>e</code> is an expression expected
to evaluate to an object and <code>C</code> a class name.  The former
tells whether the class of <code>e</code> is a subclass of <code>C</code>,
that is, whether <code>e</code> can be used as an instance of <code>C</code>,
and the latter changes the class of <code>e</code> to <code>C</code>.  These
operations always succeed: the former returns a Boolean value, while
the latter changes the current class of <code>e</code> to <code>C</code>
regardless of whether it is safe to do so or not.  The typed version
of KOOL will check the safety of casting by ensuring that the instance
class of the object is a subclass of <code>C</code>.  In untyped KOOL we
do not want to perform this check because we want to allow the
programmer maximum of flexibility: if one always accesses only
available members, then the program can execute successfully despite
the potentially unsafe cast.</p>
</li>
</ul>
<p>There are some specific aspects of KOOL that need to be discussed.</p>
<p>First, KOOL is higher-order, allowing function abstractions to be
treated like any other values in the language.  For example, if
<code>m</code> is a method of object <code>e</code> then <code>e.m</code>
evaluates to the corresponding function abstraction.  The function
abstraction is in fact a closure, because in addition to the method
parameters and body it also encapsulates the object value (i.e., the
environment of the object together with its current class&#x2014;see below)
that <code>e</code> evaluates to.  This way, function abstractions can be
invoked anywhere and have the capability to change the state of their
object.  For example, if <code>m</code> is a method of object <code>e</code>
which increments a field <code>c</code> of <code>e</code> when invoked, and if
<code>getm</code> is another method of <code>e</code> which simply returns
<code>m</code> when invoked, then the double application
<code>(e.getm())()</code> has the same effect as <code>e.m()</code>, that is,
increments the counter <code>c</code> of <code>e</code>.  Note that the
higher-order nature of KOOL was not originally planned; it came as a
natural consequence of evaluating methods to closures and we decided
to keep it.  If you do not like it then do not use it.</p>
<p>Second, since all the fields and methods are public in KOOL and since
they can be redeclared in subclasses, it is not immediately clear how
to lookup the member <code>x</code> when we write <code>e.x</code> and
<code>e</code> is different from <code>super</code>.  We distinguish two cases,
depending on whether <code>e.x</code> occurs in a method invocation
context (i.e., <code>e.x(...)</code>) or in a field context.  KOOL has
dynamic method dispatch, so if <code>e.x</code> is invoked as a method
then <code>x</code> will be searched for starting with the instance class of
the object value to which <code>e</code> evaluates.  If <code>e.x</code>
occurs in a non-method-invocation context then <code>x</code> will be
treated as a field (although it may hold a method closure due to the
higher-order nature of KOOL) and thus will be searched starting with
the current class of the object value of <code>e</code> (which, because of
<code>this</code> and casting, may be different from its instance class).
In order to achieve the above, each object value will consist of a
pair holding the current class of the object and an environment stack
with one layer for each class in the object&apos;s instance class hierarchy.</p>
<p>Third, although KOOL is dynamic method dispatch, its capabilities
described above are powerful enough to allow us to mimic static
method dispatch.  For example, suppose that you want to invoke method
<code>m()</code> statically.  Then all you need to do is to declare a
local variable and bind it to <code>m</code>, for example <code>var staticm = m;</code>, and
then call <code>staticm()</code>.  This works because
<code>staticm</code> is first bound to the method closure that <code>m</code>
evaluates to, and then looked up as any local variable when invoked.
We only enable the dynamic method dispatch when we have an object
member on an application position, e.g., <code>m()</code>.</p>
<p>In what follows, we limit our comments to the new, KOOL-specific
aspects of the language.  We refer the reader to the untyped SIMPLE
language for documentation on the the remaining features, because
those were all borrowed from SIMPLE.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> KOOL-UNTYPED-SYNTAX<span class="hljs-keyword">
  imports</span> DOMAINS-SYNTAX
</code></pre>
<h2>Syntax</h2>
<p>The syntax of KOOL extends that of SIMPLE with object-oriented
constructs.  We removed from the <strong>K</strong> annotated syntax of SIMPLE two
constructs, namely the one for function declarations (because we want
to call them <code>methods</code> now) and the one for function application
(because application is not strict in the first argument
anymore&#x2014;needs to initiate dynamic method dispatch).  The additional
syntax includes:</p>
<ul>
<li>First, we need a new dedicated identifier, <code>Object</code>, for
the default top-most class.</li>
<li>Second, we rename the <code>function</code> keyword of SIMPLE into <code>method</code>.</li>
<li>Third, we add syntax for class declarations together with a
macro making classes which extend nothing to extend <code>Object</code>.</li>
<li>Fourth, we change the strictness attribute of application
into <code>strict(2)</code>.</li>
<li>Finally, we add syntax and corresponding strictness
for the KOOL object-oriented constructs.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Id</span> ::= <span class="hljs-string">&quot;Object&quot;</span> [<span class="hljs-literal">token</span>] | <span class="hljs-string">&quot;Main&quot;</span> [<span class="hljs-literal">token</span>]<span class="hljs-keyword">

  syntax</span> Decl ::= <span class="hljs-string">&quot;var&quot;</span> Exps <span class="hljs-string">&quot;;&quot;</span>
                | <span class="hljs-string">&quot;method&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;(&quot;</span> Ids <span class="hljs-string">&quot;)&quot;</span> Block  <span class="hljs-comment">// called &quot;function&quot; in SIMPLE</span>
                | <span class="hljs-string">&quot;class&quot;</span><span class="hljs-keyword"> Id</span> Block               <span class="hljs-comment">// KOOL</span>
                | <span class="hljs-string">&quot;class&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;extends&quot;</span><span class="hljs-keyword"> Id</span> Block  <span class="hljs-comment">// KOOL</span><span class="hljs-keyword">

  syntax</span> Exp ::=<span class="hljs-keyword"> Int</span> |<span class="hljs-keyword"> Bool</span> |<span class="hljs-keyword"> String</span> |<span class="hljs-keyword"> Id</span>
               | <span class="hljs-string">&quot;this&quot;</span>                                 <span class="hljs-comment">// KOOL</span>
               | <span class="hljs-string">&quot;super&quot;</span>                                <span class="hljs-comment">// KOOL</span>
               | <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>             [<span class="hljs-literal">bracket</span>]
               | <span class="hljs-string">&quot;++&quot;</span> Exp
               | Exp <span class="hljs-string">&quot;instanceOf&quot;</span><span class="hljs-keyword"> Id</span>     [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]    <span class="hljs-comment">// KOOL</span>
               | <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;)&quot;</span> Exp          [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]    <span class="hljs-comment">// KOOL  cast</span>
               | <span class="hljs-string">&quot;new&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span>   [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]    <span class="hljs-comment">// KOOL</span>
               | Exp <span class="hljs-string">&quot;.&quot;</span><span class="hljs-keyword"> Id</span>                             <span class="hljs-comment">// KOOL</span>
               &gt; Exp <span class="hljs-string">&quot;[&quot;</span> Exps <span class="hljs-string">&quot;]&quot;</span>        [<span class="hljs-literal">strict</span>]
               &gt; Exp <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span>        [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]    <span class="hljs-comment">// was strict in SIMPLE</span>
               | <span class="hljs-string">&quot;-&quot;</span> Exp                 [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;sizeOf&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>    [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;)&quot;</span>
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;*&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;/&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;%&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;+&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;-&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-literal">non-assoc</span>:
                 Exp <span class="hljs-string">&quot;&lt;&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&lt;=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&gt;&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&gt;=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;==&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;!=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               &gt; <span class="hljs-string">&quot;!&quot;</span> Exp                 [<span class="hljs-literal">strict</span>]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;&amp;&amp;&quot;</span> Exp            [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;||&quot;</span> Exp            [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="hljs-string">&quot;=&quot;</span> Exp             [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>), <span class="hljs-literal">right</span>]<span class="hljs-keyword">

  syntax</span> Ids  ::= List{<span class="hljs-keyword">Id</span>,<span class="hljs-string">&quot;,&quot;</span>}<span class="hljs-keyword">

  syntax</span> Exps ::= List{Exp,<span class="hljs-string">&quot;,&quot;</span>}          [<span class="hljs-literal">strict</span>, klabel(exps)]<span class="hljs-keyword">
  syntax</span> Val<span class="hljs-keyword">
  syntax</span> Vals ::= List{Val,<span class="hljs-string">&quot;,&quot;</span>}          [klabel(exps)]<span class="hljs-keyword">

  syntax</span> Block ::= <span class="hljs-string">&quot;{&quot;</span> <span class="hljs-string">&quot;}&quot;</span>
                | <span class="hljs-string">&quot;{&quot;</span> Stmts <span class="hljs-string">&quot;}&quot;</span><span class="hljs-keyword">

  syntax</span> Stmt ::= Decl | Block
                | Exp <span class="hljs-string">&quot;;&quot;</span>                               [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block <span class="hljs-string">&quot;else&quot;</span> Block   [<span class="hljs-literal">avoid</span>, <span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]
                | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;while&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
            | <span class="hljs-string">&quot;for&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Stmts Exp <span class="hljs-string">&quot;;&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;return&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                      [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;return&quot;</span> <span class="hljs-string">&quot;;&quot;</span>
                | <span class="hljs-string">&quot;print&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-string">&quot;;&quot;</span>              [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;try&quot;</span> Block <span class="hljs-string">&quot;catch&quot;</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;throw&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                       [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;join&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                        [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;acquire&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                     [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;release&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                     [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;rendezvous&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                  [<span class="hljs-literal">strict</span>]<span class="hljs-keyword">

  syntax</span> Stmts ::= Stmt
                 | Stmts Stmts                          [<span class="hljs-literal">right</span>]
</code></pre>
<p>Old desugaring rules, from SIMPLE</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> if (E) S =&gt; if (E) S else {}                                 [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> for(Start Cond; Step) {S} =&gt; {Start while (Cond) {S Step;}}  [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> var E1::Exp, E2::Exp, Es::Exps; =&gt; var E1; var E2, Es;       [<span class="hljs-literal">macro</span>-rec]<span class="hljs-keyword">
  rule</span> var X::<span class="hljs-keyword">Id</span> = E; =&gt; var X; X = E;                              [<span class="hljs-literal">macro</span>]
</code></pre>
<p>New desugaring rule</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> class C:<span class="hljs-keyword">Id</span> S =&gt; class C extends Object S                     <span class="hljs-comment">// KOOL</span><span class="hljs-keyword">

endmodule</span>
</code></pre>
<h2>Semantics</h2>
<p>We first discuss the new configuration of KOOL, which extends that of
SIMPLE.  Then we include the semantics of the constructs borrowed from
SIMPLE unchanged; we refrain from discussing those, because they were
already discussed in the <strong>K</strong> definition of SIMPLE.  Then we discuss
changes to SIMPLE&apos;s semantics needed for the more general meaning of
the previous SIMPLE constructs (for example for thread spawning,
assignment, etc.).  Finally, we discuss in detail the
semantics of the additional KOOL constructs.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> KOOL-UNTYPED<span class="hljs-keyword">
  imports</span> KOOL-UNTYPED-SYNTAX<span class="hljs-keyword">
  imports</span> DOMAINS
</code></pre>
<h2>Configuration</h2>
<p>KOOL removes one cell and adds two nested cells to the configuration
of SIMPLE.  The cell which is removed is the one holding the global
environment, because a KOOL program consists of a set of classes only,
with no global declarations.  In fact, since informally speaking each
KOOL class now includes a SIMPLE program, it is safe to say that the
global variables in SIMPLE became class fields in KOOL.  Let us now
discuss the new cells that are added to the configuration of SIMPLE.</p>
<ul>
<li>
<p>The cell <code>crntObj</code> holds data pertaining to the current
object, that is, the object environment in which the code in cell
<code>k</code> executes: <code>crntClass</code> holds the current class (which
can change as methods of the current object are invoked);
<code>envStack</code> holds the stack of environments as a list,
each layer corresponding to one class in the objects&apos; instance class
hierarchy; <code>location</code>, which is optional, holds the location in
the store where the current object is or has to be located (this is
useful both for method closures and for the semantics of object
creation).</p>
</li>
<li>
<p>The cell <code>classes</code> holds all the declared classes, each
class being held in its own <code>class</code> cell which contains a name
(<code>className</code>), a parent (<code>extends</code>), and the actual
member declarations (<code>declarations</code>).</p>
</li>
</ul>
<pre class="hljs"><code>  <span class="hljs-comment">// the syntax declarations below are required because the sorts are
  // referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="hljs-comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="hljs-comment">// should simply work once KIL is removed completely</span>
  <span class="hljs-comment">// check other definitions for this hack as well</span><span class="hljs-keyword">
  syntax</span> EnvCell<span class="hljs-keyword">
  syntax</span> ControlCell<span class="hljs-keyword">
  syntax</span> EnvStackCell<span class="hljs-keyword">
  syntax</span> CrntObjCellFragment<span class="hljs-keyword">

  configuration</span> &lt;T color=<span class="hljs-string">&quot;red&quot;</span>&gt;
                  &lt;threads color=<span class="hljs-string">&quot;orange&quot;</span>&gt;
                    &lt;thread multiplicity=<span class="hljs-string">&quot;*&quot;</span> type=<span class="hljs-string">&quot;Set&quot;</span> color=<span class="hljs-string">&quot;yellow&quot;</span>&gt;
                      &lt;k color=<span class="hljs-string">&quot;green&quot;</span>&gt; $PGM:Stmts ~&gt; execute &lt;/k&gt;
                    <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      &lt;control color=<span class="hljs-string">&quot;cyan&quot;</span>&gt;
                        &lt;fstack color=<span class="hljs-string">&quot;blue&quot;</span>&gt; .List &lt;/fstack&gt;
                        &lt;xstack color=<span class="hljs-string">&quot;purple&quot;</span>&gt; .List &lt;/xstack&gt;
                      <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                        &lt;crntObj color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt;  <span class="hljs-comment">// KOOL</span>
                           &lt;crntClass&gt; Object &lt;/crntClass&gt;
                           &lt;envStack&gt; .List &lt;/envStack&gt;
                           &lt;location multiplicity=<span class="hljs-string">&quot;?&quot;</span>&gt; .K &lt;/location&gt;
                        &lt;/crntObj&gt;
                      &lt;/control&gt;
                    <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      &lt;env color=<span class="hljs-string">&quot;violet&quot;</span>&gt; .Map &lt;/env&gt;
                      &lt;holds color=<span class="hljs-string">&quot;black&quot;</span>&gt; .Map &lt;/holds&gt;
                      &lt;id color=<span class="hljs-string">&quot;pink&quot;</span>&gt; <span class="hljs-number">0</span> &lt;/id&gt;
                    &lt;/thread&gt;
                  &lt;/threads&gt;
                <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  &lt;store color=<span class="hljs-string">&quot;white&quot;</span>&gt; .Map &lt;/store&gt;
                  &lt;busy color=<span class="hljs-string">&quot;cyan&quot;</span>&gt;.Set &lt;/busy&gt;
                  &lt;terminated color=<span class="hljs-string">&quot;red&quot;</span>&gt; .Set &lt;/terminated&gt;
                  &lt;input color=<span class="hljs-string">&quot;magenta&quot;</span> stream=<span class="hljs-string">&quot;stdin&quot;</span>&gt; .List &lt;/input&gt;
                  &lt;output color=<span class="hljs-string">&quot;brown&quot;</span> stream=<span class="hljs-string">&quot;stdout&quot;</span>&gt; .List &lt;/output&gt;
                  &lt;nextLoc color=<span class="hljs-string">&quot;gray&quot;</span>&gt; <span class="hljs-number">0</span> &lt;/nextLoc&gt;
                <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  &lt;classes color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt;        <span class="hljs-comment">// KOOL</span>
                     &lt;classData multiplicity=<span class="hljs-string">&quot;*&quot;</span> type=<span class="hljs-string">&quot;Map&quot;</span> color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt;
                        <span class="hljs-comment">// the Map has as its key the first child of the cell,</span>
                        <span class="hljs-comment">// in this case the className cell.</span>
                        &lt;className color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; Main &lt;/className&gt;
                        &lt;baseClass color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; Object &lt;/baseClass&gt;
                        &lt;declarations color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; .K &lt;/declarations&gt;
                     &lt;/classData&gt;
                  &lt;/classes&gt;
                &lt;/T&gt;
</code></pre>
<h2>Unchanged Semantics from untyped SIMPLE</h2>
<p>The semantics below is taken over from SIMPLE unchanged.
The semantics of function declaration and invocation, including the
use of the special <code>lambda</code> abstraction value, needs to change
in order to account for the fact that methods are now invoked into
their object&apos;s environment.  The semantics of function return actually
stays unchanged.  Also, the semantics of program initialization is
different: now we have to create an instance of the <code>Main</code>
class which also calls the constructor <code>Main()</code>, while in
SIMPLE we only had to invoke the function <code>Main()</code>.
Finally, the semantics of thread spawning needs to change, too: the
parent thread needs to also share its object environment with the
spawned thread (in addition to its local environment, like in SIMPLE).
This is needed in order to be able to spawn method invokations under
dynamic method dispatch; for example, <code>spawn { run(); }</code>
will need to look up the method <code>run()</code> in the newly created
thread, operation which will most likely fail unless the child thread
sees the object environment of the parent thread.  Note that the
<code>spawn</code> statement of KOOL is more permissive than the threads
of Java.  In fact, the latter can be implemented in terms of our
<code>spawn</code>&#x2014;see the program <code>threads.kool</code> for a sketch.</p>
<p>Below is a subset of the values of SIMPLE, which are also values
of KOOL.  We will add other values later in the semantics, such as
object and method closures.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Val ::=<span class="hljs-keyword"> Int</span> |<span class="hljs-keyword"> Bool</span> |<span class="hljs-keyword"> String</span>
               | array(<span class="hljs-keyword">Int</span>,<span class="hljs-keyword">Int</span>)<span class="hljs-keyword">
  syntax</span> Exp ::= Val<span class="hljs-keyword">
  syntax</span> Exps ::= Vals<span class="hljs-keyword">
  syntax</span> KResult ::= Val<span class="hljs-keyword">
  syntax</span> KResult ::= Vals
</code></pre>
<p>The semantics below are taken verbatim from the untyped SIMPLE
definition.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= <span class="hljs-string">&quot;undefined&quot;</span>  [<span class="hljs-literal">latex</span>(\bot)]<span class="hljs-keyword">

  rule</span> &lt;k&gt; var X:<span class="hljs-keyword">Id</span>; =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; Env[X &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; undefined ...&lt;/store&gt;
       &lt;nextLoc&gt; L:<span class="hljs-keyword">Int</span> =&gt; L +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> &lt;/nextLoc&gt;<span class="hljs-keyword">


  context</span> var _:<span class="hljs-keyword">Id</span>[HOLE];<span class="hljs-keyword">

  rule</span> &lt;k&gt; var X:<span class="hljs-keyword">Id</span>[N:<span class="hljs-keyword">Int</span>]; =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; Env[X &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; array(L +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, N)
                          (L +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>) ... (L +<span class="hljs-keyword">Int</span> N) |-&gt; undefined ...&lt;/store&gt;
       &lt;nextLoc&gt; L:<span class="hljs-keyword">Int</span> =&gt; L +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> +<span class="hljs-keyword">Int</span> N &lt;/nextLoc&gt;
    when N &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">


  syntax</span><span class="hljs-keyword"> Id</span> ::= <span class="hljs-string">&quot;$1&quot;</span> | <span class="hljs-string">&quot;$2&quot;</span><span class="hljs-keyword">
  rule</span> var X:<span class="hljs-keyword">Id</span>[N1:<span class="hljs-keyword">Int</span>, N2:<span class="hljs-keyword">Int</span>, Vs:Vals];
    =&gt; var X[N1];
       {
         var $<span class="hljs-number">1</span>=X;
         for(var $<span class="hljs-number">2</span>=<span class="hljs-number">0</span>; $<span class="hljs-number">2</span> &lt;= N1 - <span class="hljs-number">1</span>; ++$<span class="hljs-number">2</span>) {
           var X[N2,Vs];
           $<span class="hljs-number">1</span>[$<span class="hljs-number">2</span>] = X;
         }
       }
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">


  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; V ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]<span class="hljs-keyword">


  context</span> ++(HOLE =&gt; lvalue(HOLE))<span class="hljs-keyword">
  rule</span> &lt;k&gt; ++loc(L) =&gt; I +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> ...&lt;/k&gt;
       &lt;store&gt;... L |-&gt; (I:<span class="hljs-keyword">Int</span> =&gt; I +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>) ...&lt;/store&gt;  [increment]<span class="hljs-keyword">


  rule</span> I1 + I2 =&gt; I1 +<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> Str1 + Str2 =&gt; Str1 +<span class="hljs-keyword">String</span> Str2<span class="hljs-keyword">
  rule</span> I1 - I2 =&gt; I1 -<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 * I2 =&gt; I1 *<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 / I2 =&gt; I1 /<span class="hljs-keyword">Int</span> I2 when I2 =/=K <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> I1 % I2 =&gt; I1 %<span class="hljs-keyword">Int</span> I2 when I2 =/=K <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> - I =&gt; <span class="hljs-number">0</span> -<span class="hljs-keyword">Int</span> I<span class="hljs-keyword">
  rule</span> I1 &lt; I2 =&gt; I1 &lt;<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 &lt;= I2 =&gt; I1 &lt;=<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 &gt; I2 =&gt; I1 &gt;<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> I1 &gt;= I2 =&gt; I1 &gt;=<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">

  rule</span> V1:Val == V2:Val =&gt; V1 ==K V2<span class="hljs-keyword">
  rule</span> V1:Val != V2:Val =&gt; V1 =/=K V2<span class="hljs-keyword">
  rule</span> ! T =&gt; notBool(T)<span class="hljs-keyword">
  rule</span> true  &amp;&amp; E =&gt; E<span class="hljs-keyword">
  rule</span> false &amp;&amp; _ =&gt; false<span class="hljs-keyword">
  rule</span> true  || _ =&gt; true<span class="hljs-keyword">
  rule</span> false || E =&gt; E<span class="hljs-keyword">


  rule</span> V:Val[N1:<span class="hljs-keyword">Int</span>, N2:<span class="hljs-keyword">Int</span>, Vs:Vals] =&gt; V[N1][N2, Vs]
    [<span class="hljs-literal">structural</span>, anywhere]<span class="hljs-keyword">

  rule</span> array(L,_)[N:<span class="hljs-keyword">Int</span>] =&gt; lookup(L +<span class="hljs-keyword">Int</span> N)
    [<span class="hljs-literal">structural</span>, anywhere]<span class="hljs-keyword">


  rule</span> sizeOf(array(_,N)) =&gt; N
</code></pre>
<p>The semantics of function application needs to change into dynamic
method dispatch invocation, which is defined shortly.  However,
interestingly, the semantics of return stays unchanged.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; return(V:Val); ~&gt; _ =&gt; V ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;fstack&gt; ListItem(fstackFrame(Env,K,XS,&lt;crntObj&gt; CO &lt;/crntObj&gt;)) =&gt; .List ...&lt;/fstack&gt;
         &lt;xstack&gt; _ =&gt; XS &lt;/xstack&gt;
         &lt;crntObj&gt; _ =&gt; CO &lt;/crntObj&gt;
       &lt;/control&gt;
       &lt;env&gt; _ =&gt; Env &lt;/env&gt;<span class="hljs-keyword">

  syntax</span> Val ::= <span class="hljs-string">&quot;nothing&quot;</span><span class="hljs-keyword">
  rule</span> return; =&gt; return nothing;   [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">


  rule</span> &lt;k&gt; read() =&gt; I ...&lt;/k&gt; &lt;input&gt; ListItem(I:<span class="hljs-keyword">Int</span>) =&gt; .List ...&lt;/input&gt;  [read]<span class="hljs-keyword">


  context</span> (HOLE =&gt; lvalue(HOLE)) = _<span class="hljs-keyword">

  rule</span> &lt;k&gt; loc(L) = V:Val =&gt; V ...&lt;/k&gt; &lt;store&gt;... L |-&gt; (_ =&gt; V) ...&lt;/store&gt;
    [assignment]<span class="hljs-keyword">


  rule</span> {} =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; { S } =&gt; S ~&gt; setEnv(Env) ...&lt;/k&gt;  &lt;env&gt; Env &lt;/env&gt;  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">


  rule</span> S1::Stmts S2::Stmts =&gt; S1 ~&gt; S2  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> _:Val; =&gt; .<span class="hljs-keyword">

  rule</span> if ( true) S else _ =&gt; S<span class="hljs-keyword">
  rule</span> if (false) _ else S =&gt; S<span class="hljs-keyword">

  rule</span> while (E) S =&gt; if (E) {S while(E)S}  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> &lt;k&gt; print(V:Val, Es =&gt; Es); ...&lt;/k&gt; &lt;output&gt;... .List =&gt; ListItem(V) &lt;/output&gt;
    [print]<span class="hljs-keyword">
  rule</span> print(.Vals); =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">


  syntax</span> KItem ::= xstackFrame(<span class="hljs-keyword">Id</span>,Stmt,K,Map,K)
  <span class="hljs-comment">// TODO(KORE): drop the additional production once parsing issue #1842 is fixed</span>
                 | (<span class="hljs-keyword">Id</span>,Stmt,K,Map,K)<span class="hljs-keyword">

  syntax</span> KItem ::= <span class="hljs-string">&quot;popx&quot;</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; (try S1 catch(X) {S2} =&gt; S1 ~&gt; popx) ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;xstack&gt; .List =&gt; ListItem(xstackFrame(X, S2, K, Env, C)) ...&lt;/xstack&gt;
         C
       &lt;/control&gt;
       &lt;env&gt; Env &lt;/env&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; popx =&gt; . ...&lt;/k&gt;
       &lt;xstack&gt; ListItem(_) =&gt; .List ...&lt;/xstack&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; throw V:Val; ~&gt; _ =&gt; { var X = V; S2 } ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;xstack&gt; ListItem(xstackFrame(X, S2, K, Env, C)) =&gt; .List ...&lt;/xstack&gt;
         (_ =&gt; C)
       &lt;/control&gt;
       &lt;env&gt; _ =&gt; Env &lt;/env&gt;
</code></pre>
<p>Thread spawning needs a new semantics, because we want the child
thread to also share the object environment with its parent.  The new
semantics of thread spawning will be defined shortly.  However,
interestingly, the other concurrency constructs keep their semantics
from SIMPLE unchanged.</p>
<pre class="hljs"><code>  <span class="hljs-comment">// TODO(KORE): ..Bag should be . throughout this definition #1772</span><span class="hljs-keyword">
  rule</span> (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .Bag)
  <span class="hljs-comment">/*
  rule (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .)
  */</span>
       &lt;busy&gt; Busy =&gt; Busy -Set keys(H) &lt;/busy&gt;
       &lt;terminated&gt;... .Set =&gt; SetItem(T) ...&lt;/terminated&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; join T:<span class="hljs-keyword">Int</span>; =&gt; . ...&lt;/k&gt;
       &lt;terminated&gt;... SetItem(T) ...&lt;/terminated&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; acquire V:Val; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... .Map =&gt; V |-&gt; <span class="hljs-number">0</span> ...&lt;/holds&gt;
       &lt;busy&gt; Busy (.Set =&gt; SetItem(V)) &lt;/busy&gt;
    when (notBool(V in Busy:Set))  [acquire]<span class="hljs-keyword">

  rule</span> &lt;k&gt; acquire V; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... V:Val |-&gt; (N:<span class="hljs-keyword">Int</span> =&gt; N +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>) ...&lt;/holds&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; release V:Val; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... V |-&gt; (N =&gt; N:<span class="hljs-keyword">Int</span> -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>) ...&lt;/holds&gt;
    when N &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; release V; =&gt; . ...&lt;/k&gt; &lt;holds&gt;... V:Val |-&gt; <span class="hljs-number">0</span> =&gt; .Map ...&lt;/holds&gt;
       &lt;busy&gt;... SetItem(V) =&gt; .Set ...&lt;/busy&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; rendezvous V:Val; =&gt; . ...&lt;/k&gt;
       &lt;k&gt; rendezvous V; =&gt; . ...&lt;/k&gt;  [rendezvous]
</code></pre>
<h2>Unchanged auxiliary operations from untyped SIMPLE</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Stmts ::= mkDecls(Ids,Vals)  [function]<span class="hljs-keyword">
  rule</span> mkDecls((X:<span class="hljs-keyword">Id</span>, Xs:Ids), (V:Val, Vs:Vals)) =&gt; var X=V; mkDecls(Xs,Vs)<span class="hljs-keyword">
  rule</span> mkDecls(.Ids,.Vals) =&gt; {}

  <span class="hljs-comment">// TODO(KORE): clarify sort inferences #1803</span><span class="hljs-keyword">
  syntax</span> Exp ::= lookup(<span class="hljs-keyword">Int</span>)
  <span class="hljs-comment">/*
  syntax KItem ::= lookup(Int)
  */</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; lookup(L) =&gt; V ...&lt;/k&gt; &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]<span class="hljs-keyword">

  syntax</span> KItem ::= setEnv(Map)<span class="hljs-keyword">
  rule</span> &lt;k&gt; setEnv(Env) =&gt; . ...&lt;/k&gt;  &lt;env&gt; _ =&gt; Env &lt;/env&gt;  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [<span class="hljs-literal">structural</span>]
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> How can we make sure that the second rule above applies before the first one?</span>
  <span class="hljs-comment">//       Probably we&apos;ll deal with this using strategies, eventually.</span><span class="hljs-keyword">

  syntax</span> Exp ::= lvalue(K)<span class="hljs-keyword">
  syntax</span> Val ::= loc(<span class="hljs-keyword">Int</span>)<span class="hljs-keyword">

  rule</span> &lt;k&gt; lvalue(X:<span class="hljs-keyword">Id</span> =&gt; loc(L)) ...&lt;/k&gt; &lt;env&gt;... X |-&gt; L:<span class="hljs-keyword">Int</span> ...&lt;/env&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  context</span> lvalue(_::Exp[HOLE::Exps])<span class="hljs-keyword">
  context</span> lvalue(HOLE::Exp[_::Exps])<span class="hljs-keyword">

  rule</span> lvalue(lookup(L:<span class="hljs-keyword">Int</span>) =&gt; loc(L))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">


  syntax</span> Map ::=<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;...&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;|-&gt;&quot;</span> K
    [function, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\ldots{#<span class="hljs-number">2</span>}\mapsto{#<span class="hljs-number">3</span>})]<span class="hljs-keyword">
  rule</span> N...M |-&gt; _ =&gt; .Map  when N &gt;<span class="hljs-keyword">Int</span> M<span class="hljs-keyword">
  rule</span> N...M |-&gt; K =&gt; N |-&gt; K (N +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>)...M |-&gt; K  when N &lt;=<span class="hljs-keyword">Int</span> M
</code></pre>
<h2>Changes to the existing untyped SIMPLE semantics</h2>
<p>When we extend a language, sometimes we need to do more than just add
new language constructs and semantics for them.  Sometimes we want to
also extend the semantics of existing language constructs, in order to
get more from them.</p>
<h2>Program initialization</h2>
<p>In SIMPLE, once all the global declarations were processed, the
function <code>main()</code> was invoked.  In KOOL, the global
declarations are classes, and their specific semantics is given
shortly; essentially, they are pre-processed one by one and added
into the <code>class</code> cell structure in the configuration.
Once all the classes are processed, the computation item
<code>execute</code>, which was placed right after the program in the
initial configuration, is reached.  In SIMPLE, the program was
initialized by calling the method <code>main()</code>.  In KOOL, the
program is initialized by creating an object instance of class
<code>Main</code>.  This will also implicitly call the method
<code>Main()</code> (the <code>Main</code> class constructor).  The emptiness
of the <code>env</code> cell below is just a sanity check, to make sure
that the user has not declared anything but classes at the top level
of the program.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= <span class="hljs-string">&quot;execute&quot;</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; execute =&gt; new Main(.Exps); &lt;/k&gt; &lt;env&gt; .Map &lt;/env&gt;  [<span class="hljs-literal">structural</span>]
</code></pre>
<p>The semantics of <code>new</code> (defined below) requires the
execution of all the class&apos; declarations (and also of its
superclasses&apos;).</p>
<h2>Object and method closures</h2>
<p>Before we can define the semantics of method application (previously
called function application in SIMPLE), we need to add two more values
to the language, namely object and method closures:</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Val ::= objectClosure(<span class="hljs-keyword">Id</span>, List)
               | methodClosure(<span class="hljs-keyword">Id</span>,<span class="hljs-keyword">Int</span>,Ids,Stmt)
</code></pre>
<p>An object value consists of an <code>objectClosure</code>-wrapped bag
containing the current class of the object and the environment stack
of the object.  The current class of an object will always be one of
the classes mapped to an environment in the environment stack of the
object.  A method closure encapsulates the method&apos;s parameters and
code (last two arguments), as well as the object context in which the
method code should execute.  This object context includes the current
class of the object (the first argument of <code>methodClosure</code>) and
the object environment stack (located in the object stored at the
location specified as the second argument of <code>methodClosure</code>).</p>
<h2>Method application</h2>
<p>KOOL has a complex mechanism to invoke methods, because it allows both
dynamic method dispatch and methods as first-class-citizen values (the
latter making it a higher-order language).  The invocation mechanism
will be defined later.  What is sufficient to know for now is that
the two arguments of the application construct eventually reduce to
values, the first being a method closure and the latter a list of
values.  The semantics of the method closure application is then as
expected: the local environment and control are stacked, then we
switch to method closure&apos;s class and object environment and execute
the method body.  The <code>mkDecls</code> construct is the one that came
with the unchanged semantics of SIMPLE above.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= fstackFrame(Map,K,List,K)
  <span class="hljs-comment">// TODO(KORE): drop the additional production once parsing issue #1842 is fixed</span>
                 | (Map,K,K)<span class="hljs-keyword">

  rule</span> &lt;k&gt; methodClosure(Class,OL,Xs,S)(Vs:Vals) ~&gt; K
           =&gt; mkDecls(Xs,Vs) S return; &lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;store&gt;... OL |-&gt; objectClosure(_, EnvStack)...&lt;/store&gt;
     <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       &lt;control&gt;
          &lt;xstack&gt; XS &lt;/xstack&gt;
          &lt;fstack&gt; .List =&gt; ListItem(fstackFrame(Env, K, XS, &lt;crntObj&gt; Obj&apos; &lt;/crntObj&gt;))
          ...&lt;/fstack&gt;
          &lt;crntObj&gt; Obj&apos; =&gt; &lt;crntClass&gt; Class &lt;/crntClass&gt; &lt;envStack&gt; EnvStack &lt;/envStack&gt; &lt;/crntObj&gt;
       &lt;/control&gt;
</code></pre>
<h2>Spawn</h2>
<p>We want to extend the semantics of <code>spawn</code> to also share the
current object environment with the child thread, in addition to the
current environment.  This extension will allow us to also use method
invocations in the spawned statements, which will be thus looked up as
expected, using dynamic method dispatch.  This lookup operation would
fail if the child thread did not have access to its parent&apos;s object
environment.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;thread&gt;...
         &lt;k&gt; spawn S =&gt; !T:<span class="hljs-keyword">Int</span> ...&lt;/k&gt;
         &lt;env&gt; Env &lt;/env&gt;
         &lt;crntObj&gt; Obj &lt;/crntObj&gt;
       ...&lt;/thread&gt;
       (.Bag =&gt; &lt;thread&gt;...
               &lt;k&gt; S &lt;/k&gt;
               &lt;env&gt; Env &lt;/env&gt;
               &lt;id&gt; !T &lt;/id&gt;
               &lt;crntObj&gt; Obj &lt;/crntObj&gt;
             ...&lt;/thread&gt;)
</code></pre>
<h2>Semantics of the new KOOL constructs</h2>
<h2>Class declaration</h2>
<p>Initially, the classes forming the program are moved into their
corresponding cells:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; class Class1 extends Class2 { S } =&gt; . ...&lt;/k&gt;
       &lt;classes&gt;... (.Bag =&gt; &lt;classData&gt;
                            &lt;className&gt; Class1 &lt;/className&gt;
                            &lt;baseClass&gt; Class2 &lt;/baseClass&gt;
                            &lt;declarations&gt; S &lt;/declarations&gt;
                        &lt;/classData&gt;)
       ...&lt;/classes&gt;  [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Method declaration</h2>
<p>Like in SIMPLE, method names are added to the environment and bound
to their code.  However, unlike in SIMPLE where each function was
executed in the same environment, namely the program global
environment, a method in KOOL needs to be executed into its object&apos;s
environment.  Thus, methods evaluate to closures, which encapsulate
their object&apos;s context (i.e., the current class and environment stack
of the object) in addition to method&apos;s parameters and body.  This
approach to bind method names to method closures in the environment
will also allow objects to pass their methods to other objects, to
dynamically change their methods by assigning them other method
closures, and even to allow all these to be done from other objects.
This gives the KOOL programmer a lot of power; one should use this
power wisely, though, because programs can become easily hard to
understand and reason about if one overuses these features.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; method F:<span class="hljs-keyword">Id</span>(Xs:Ids) S =&gt; . ...&lt;/k&gt;
       &lt;crntClass&gt; Class:<span class="hljs-keyword">Id</span> &lt;/crntClass&gt;
       &lt;location&gt; OL:<span class="hljs-keyword">Int</span> &lt;/location&gt;
       &lt;env&gt; Env =&gt; Env[F &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; methodClosure(Class,OL,Xs,S) ...&lt;/store&gt;
       &lt;nextLoc&gt; L =&gt; L +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> &lt;/nextLoc&gt;
</code></pre>
<h2>New</h2>
<p>The semantics of <code>new</code> consists of two actions: memory
allocation for the new object and execution of the corresponding
constructor.  Then the created object is returned as the result of the
<code>new</code> operation; the value returned by the constructor, if any,
is discarded.  The current environment and object are stored onto the
stack and recovered after new (according to the semantics of
<code>return</code> borrowed from SIMPLE, when the statement
<code>return this;</code> in the rule below is reached and evaluated),
because the object creation part of <code>new</code> will destroy them.
The rule below also initializes the object creation process by
emptying the local environment and the current object, and allocating
a location in the store where the created object will be eventually
stored (this is what the <code>storeObj</code> task after the object
creation task in the rule below will do&#x2014;its rule is defined
shortly).  The location where the object will be stored is also made
available in the <code>crntObj</code> cell, so that method closures can
refer to it (see rule above).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= <span class="hljs-string">&quot;envStackFrame&quot;</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;,&quot;</span> Map <span class="hljs-string">&quot;)&quot;</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; new Class:<span class="hljs-keyword">Id</span>(Vs:Vals) ~&gt; K
           =&gt; create(Class) ~&gt; storeObj ~&gt; Class(Vs); return this; &lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;nextLoc&gt; L:<span class="hljs-keyword">Int</span> =&gt; L +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> &lt;/nextLoc&gt;
     <span class="hljs-comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
       &lt;control&gt; &lt;xstack&gt; XS &lt;/xstack&gt;
         &lt;crntObj&gt; Obj
                   =&gt; &lt;crntClass&gt; Object &lt;/crntClass&gt;
                      &lt;envStack&gt; ListItem(envStackFrame(Object, .Map)) &lt;/envStack&gt;
                      &lt;location&gt; L &lt;/location&gt;
         &lt;/crntObj&gt;
         &lt;fstack&gt; .List =&gt; ListItem(fstackFrame(Env, K, XS, &lt;crntObj&gt; Obj &lt;/crntObj&gt;)) ...&lt;/fstack&gt;
       &lt;/control&gt;
</code></pre>
<p>The creation of a new object (the memory allocation part only) is
a recursive process, requiring to first create an object for the
superclass.  A memory object representation is a layered structure:
for each class on the path from the instance class to the root of the
hierarchy there is a layer including the memory allocated for the
members (both fields and methods) of that class.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= create(<span class="hljs-keyword">Id</span>)<span class="hljs-keyword">

  rule</span> &lt;k&gt; create(Class:<span class="hljs-keyword">Id</span>)
           =&gt; create(Class1) ~&gt; setCrntClass(Class) ~&gt; S ~&gt; addEnvLayer ...&lt;/k&gt;
       &lt;className&gt; Class &lt;/className&gt;
       &lt;baseClass&gt; Class1:<span class="hljs-keyword">Id</span> &lt;/baseClass&gt;
       &lt;declarations&gt; S &lt;/declarations&gt;  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> &lt;k&gt; create(Object) =&gt; . ...&lt;/k&gt;  [<span class="hljs-literal">structural</span>]
</code></pre>
<p>The next operation sets the current class of the current object.
This is necessary to be done at each layer, because the current class
of the object is enclosed as part of the method closures (see the
semantics of method declarations above).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= setCrntClass(<span class="hljs-keyword">Id</span>)<span class="hljs-keyword">

  rule</span> &lt;k&gt; setCrntClass(C) =&gt; . ...&lt;/k&gt;
       &lt;crntClass&gt; _ =&gt; C &lt;/crntClass&gt;  [<span class="hljs-literal">structural</span>]
</code></pre>
<p>The next operation adds a new tagged environment layer to the
current object and gets ready for the next layer by clearing the
environment (note that <code>create</code> expects the environment to be
empty).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= <span class="hljs-string">&quot;addEnvLayer&quot;</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; addEnvLayer =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;crntClass&gt; Class:<span class="hljs-keyword">Id</span> &lt;/crntClass&gt;
       &lt;envStack&gt; .List =&gt; ListItem(envStackFrame(Class, Env)) ...&lt;/envStack&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<p>The following operation stores the created object at the location
reserved by <code>new</code>.  Note that the location reserved by
<code>new</code> was temporarily stored in the <code>crntObj</code> cell
precisely for this purpose.  Now that the newly created object is
stored at its location and that all method closures are aware of it,
the location is unnecessary and thus we delete it from the
<code>crntObj</code> cell.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= <span class="hljs-string">&quot;storeObj&quot;</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; storeObj =&gt; . ...&lt;/k&gt;
       &lt;crntObj&gt; &lt;crntClass&gt; CC &lt;/crntClass&gt; &lt;envStack&gt; ES &lt;/envStack&gt; (&lt;location&gt; L:<span class="hljs-keyword">Int</span> &lt;/location&gt; =&gt; .Bag) &lt;/crntObj&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; objectClosure(CC, ES) ...&lt;/store&gt;
</code></pre>
<h2>Self reference</h2>
<p>The semantics of <code>this</code> is straightforward: evaluate to the
current object.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; this =&gt; objectClosure(CC, ES) ...&lt;/k&gt;
       &lt;crntObj&gt; &lt;crntClass&gt; CC &lt;/crntClass&gt; &lt;envStack&gt; ES &lt;/envStack&gt; &lt;/crntObj&gt;
</code></pre>
<h2>Object member access</h2>
<p>We can access an object member (field or method) either explicitly,
using the construct <code>e.x</code>, or implicitly, using only the member
name <code>x</code> directly.  The borrowed semantics of SIMPLE will
already lookup a sole name in the local environment.  The first rule
below reduces implicit member access to explicit access when the name
cannot be found in the local environment.  There are two cases to
analyze for explicit object member access, depending upon whether the
object is a proper object or it is just a redirection to the parent
class via the construct <code>super</code>.  In the first case, we
evaluate the object expression and lookup the member starting with the
current class (static scoping).  Note the use of the conditional
evaluation context.  In the second case, we just lookup the member
starting with the superclass of the current class.  In both cases,
the <code>lookupMember</code> task eventually yields a <code>lookup(L)</code>
task for some appropriate location <code>L</code>, which will be further
solved with the corresponding rule borrowed from SIMPLE.  Note that the
current object is not altered by <code>super</code>, so future method
invocations see the entire object, as needed for dynamic method dispatch.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; this . X ...&lt;/k&gt; &lt;env&gt; Env:Map &lt;/env&gt;
    when notBool(X in keys(Env))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  context</span> HOLE._::<span class="hljs-keyword">Id</span> when (HOLE =/=K super)

<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> explain how Assoc matching has been replaced with two rules here.</span>
<span class="hljs-comment">// Maybe also improve it a bit.</span>

<span class="hljs-comment">/*  rule objectClosure(&lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
                     &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt;)
       . X:Id
    =&gt; lookupMember(envStackFrame(Class,EnvC) EStack, X)
    [structural]*/</span><span class="hljs-keyword">

  rule</span> objectClosure(Class:<span class="hljs-keyword">Id</span>, ListItem(envStackFrame(Class,Env)) EStack)
       . X:<span class="hljs-keyword">Id</span>
    =&gt; lookupMember(ListItem(envStackFrame(Class,Env)) EStack, X)
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> objectClosure(Class:<span class="hljs-keyword">Id</span>, (ListItem(envStackFrame(Class&apos;:<span class="hljs-keyword">Id</span>,_)) =&gt; .List) _)
       . X:<span class="hljs-keyword">Id</span>
    when Class =/=K Class&apos;  [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">/*  rule &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt;
    [structural]*/</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class:<span class="hljs-keyword">Id</span> &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class,_)) EStack &lt;/envStack&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; super . X ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class&apos;:<span class="hljs-keyword">Id</span>,_)) =&gt; .List ...&lt;/envStack&gt;
    when Class =/=K Class&apos;  [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Method invocation</h2>
<p>Unlike in SIMPLE, in KOOL application was declared strict only in its
second argument.  That is because we want to ensure dynamic method
dispatch when the first argument is a method access.  As a
consequence, we need to consider all the cases of interest for the
first argument and to explicitly say what to do in each case.  In all
cases except for method access in a proper object (i.e., not
<code>super</code>), we want the same behavior for the first argument as
if it was not in a method invocation position.  When it is a member
access (the third rule below), we look it up starting with the
instance class of the corresponding object.  This ensures dynamic
dispatch for methods; it actually dynamically dispatches field
accesses, too, which is correct in KOOL, because one can assign method
closures to fields and the field appeared in a method invocation
context.  The last context declaration below says that method
applications or array accesses are also allowed as first argument to
applications; that is because methods are allowed to return methods
and arrays are allowed to hold methods in KOOL, since it is
higher-order.  If that is the case, then we want to evaluate the
method call or the array access.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; (X:<span class="hljs-keyword">Id</span> =&gt; V)(_:Exps) ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]<span class="hljs-keyword">

  rule</span> &lt;k&gt; (X:<span class="hljs-keyword">Id</span> =&gt; this . X)(_:Exps) ...&lt;/k&gt;
       &lt;env&gt; Env &lt;/env&gt;
    when notBool(X in keys(Env))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  context</span> HOLE._::<span class="hljs-keyword">Id</span>(_) when HOLE =/=K super<span class="hljs-keyword">

  rule</span> (objectClosure(_, EStack) . X
    =&gt; lookupMember(EStack, X:<span class="hljs-keyword">Id</span>))(_:Exps)  [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">/*  rule &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,_) EStack &lt;/envStack&gt;
    [structural]*/</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class,_)) EStack &lt;/envStack&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; (super . X)(_:Exps) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class&apos;:<span class="hljs-keyword">Id</span>,_)) =&gt; .List ...&lt;/envStack&gt;
    when Class =/=K Class&apos;  [<span class="hljs-literal">structural</span>]

  <span class="hljs-comment">// TODO(KORE): fix getKLabel #1801</span><span class="hljs-keyword">
  rule</span> (A:Exp(B:Exps))(C:Exps) =&gt; A(B) ~&gt; #freezerFunCall(C)<span class="hljs-keyword">
  rule</span> (A:Exp[B:Exps])(C:Exps) =&gt; A[B] ~&gt; #freezerFunCall(C)<span class="hljs-keyword">
  rule</span> V:Val ~&gt; #freezerFunCall(C:Exps) =&gt; V(C)<span class="hljs-keyword">
  syntax</span> KItem ::= <span class="hljs-string">&quot;#freezerFunCall&quot;</span> <span class="hljs-string">&quot;(&quot;</span> K <span class="hljs-string">&quot;)&quot;</span>
  <span class="hljs-comment">/*
  context HOLE(_:Exps)
    when getKLabel(HOLE) ==K #klabel(`_(_)`) orBool getKLabel(HOLE) ==K #klabel(`_[_]`)
  */</span>
</code></pre>
<p>Eventually, each of the rules above produces a <code>lookup(L)</code>
task as a replacement for the method.  When that happens, we just
lookup the value at location <code>L</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; (lookup(L) =&gt; V)(_:Exps) ...&lt;/k&gt;  &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;
    [lookup]
</code></pre>
<p>The value <code>V</code> looked up above is expected to be a method closure,
in which case the semantics of method application given above will
apply.  Otherwise, the execution will get stuck.</p>
<h2>Instance Of</h2>
<p>It searches the object environment for a layer corresponding to the
desired class.  It returns <code>true</code> iff it can find the class,
otherwise it returns <code>false</code>; it only gets stuck when its first
argument does not evaluate to an object.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> objectClosure(_, ListItem(envStackFrame(C,_)) _)
       instanceOf C =&gt; true<span class="hljs-keyword">

  rule</span> objectClosure(_, (ListItem(envStackFrame(C,_)) =&gt; .List) _)
       instanceOf C&apos;  when C =/=K C&apos;  [<span class="hljs-literal">structural</span>]
<span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> remove the sort cast ::Id of C above, when sort inference bug fixed</span><span class="hljs-keyword">

  rule</span> objectClosure(_, .List) instanceOf _ =&gt; false
</code></pre>
<h2>Cast</h2>
<p>In untyped KOOL, we prefer to not check the validity of casting.  In
other words, any cast is allowed on any object, simply changing the
current class of the object to the desired class.  The execution will
get stuck later if one attempts to access a field which is not
available.  Moreover, the execution may complete successfully even
in the presence of invalid casts, provided that each accessed member
during the current execution is, or happens to be, available.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> (C) objectClosure(_ , EnvStack) =&gt; objectClosure(C ,EnvStack)
</code></pre>
<h2>KOOL-specific auxiliary declarations and operations</h2>
<p>Here we define all the auxiliary constructs used in the above
KOOL-specific semantics (those used in the SIMPLE fragment
have already been defined in a corresponding section above).</p>
<h2>Objects as lvalues</h2>
<p>The current machinery borrowed with the semantics of SIMPLE allows us
to enrich the set of lvalues, this way allowing new means to assign
values to locations.  In KOOL, we want object member names to be
lvalues, so that we can assign values to them using the already
existing machinery.  The first rule below ensures that the object is
always explicit, the evaluation context enforces the object to be
evaluated, and finally the second rule initiates the lookup for the
member&apos;s location based on the current class of the object.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; lvalue(X:<span class="hljs-keyword">Id</span> =&gt; this . X) ...&lt;/k&gt;  &lt;env&gt; Env &lt;/env&gt;
    when notBool(X in keys(Env))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  context</span> lvalue((HOLE . _)::Exp)

<span class="hljs-comment">/*  rule lvalue(objectClosure(&lt;crntClass&gt; C &lt;/crntClass&gt;
                            &lt;envStack&gt;... envStackFrame(C,EnvC) EStack &lt;/envStack&gt;)
              . X
              =&gt; lookupMember(&lt;envStack&gt; envStackFrame(C,EnvC) EStack &lt;/envStack&gt;,
                              X))  [structural]*/</span><span class="hljs-keyword">
  rule</span> lvalue(objectClosure(Class, ListItem(envStackFrame(Class,Env)) EStack)
              . X
              =&gt; lookupMember(ListItem(envStackFrame(Class,Env)) EStack,
                              X))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> lvalue(objectClosure(Class, (ListItem(envStackFrame(Class&apos;:<span class="hljs-keyword">Id</span>,_)) =&gt; .List) _)
              . X)
    when Class =/=K Class&apos;  [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Lookup member</h2>
<p>It searches for the given member in the given environment stack,
starting with the most concrete class and going up in the hierarchy.</p>
<pre class="hljs"><code>  <span class="hljs-comment">// TODO(KORE): clarify sort inferences #1803</span><span class="hljs-keyword">
  syntax</span> Exp ::= lookupMember(List,<span class="hljs-keyword"> Id</span>)  [function]
  <span class="hljs-comment">/*
  syntax KItem ::= lookupMember(EnvStackCell,Id)  [function]
  */</span>

<span class="hljs-comment">//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt;... X|-&gt;L ...&lt;/env&gt;) ...&lt;/envStack&gt;, X)</span>
<span class="hljs-comment">//    =&gt; lookup(L)</span><span class="hljs-keyword">
  rule</span> lookupMember(ListItem(envStackFrame(_, X|-&gt;L _)) _, X)
    =&gt; lookup(L)

<span class="hljs-comment">//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt; Env &lt;/env&gt;) =&gt; .List ...&lt;/envStack&gt;, X)</span>
<span class="hljs-comment">//    when notBool(X in keys(Env))</span><span class="hljs-keyword">
  rule</span> lookupMember(ListItem(envStackFrame(_, Env)) Rest, X) =&gt;
       lookupMember(Rest, X)
    when notBool(X in keys(Env))
<span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> beautify the above</span><span class="hljs-keyword">

endmodule</span>
</code></pre>
<p>Go to <a href="../../2_typed/1_dynamic/kool-typed-dynamic/">Lesson 2, KOOL typed dynamic</a>.</p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
