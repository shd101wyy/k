<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../projects/">Projects</a>
      <a class="bd-toc-link" href="../../../../../../../news/">News</a>
      <a class="bd-toc-link" href="../../../../../../../events/">Events</a>
      <a class="bd-toc-link" href="../../../../../../../funding/">Funding</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <h1>KOOL — Typed — Static</h1>
<p>Author: Grigore Roșu (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin Șerbănuță (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2>Abstract</h2>
<p>This is the <strong>K</strong> static semantics of the typed KOOL language.
It extends the static semantics of typed SIMPLE with static semantics
for the object-oriented constructs.  Also, the static semantics of
some of the existing SIMPLE constructs need to change, in order to
become more generous with regards to the set of accepted programs,
mostly due to subtyping.  For example, the assignment construct
<code>x = e</code> required that both the variable <code>x</code> and the
expression <code>e</code> had the same type in SIMPLE.  In KOOL, the type
of <code>e</code> can be a subtype of the type of <code>x</code>.
Specifically, we define the following typing policy for KOOL,
everything else not mentioned below borrowing its semantics from
SIMPLE:</p>
<ul>
<li>
<p>Each class <code>C</code> yields a homonymous type, which can be
explicitly used in programs to type variables and methods, possibly in
combination with other types.</p>
</li>
<li>
<p>Since now we have user-defined types, we check that each type
used in a KOOL program is well-formed, that is, it is constructed only
from primitive and class types corresponding to declared classes.</p>
</li>
<li>
<p>Class members and their types form a <strong>class type
environment</strong>.  Each class will have such a type environment.
Each member in a class is allowed to be declared only once.  Since in
KOOL we allow methods to be assigned to fields, we make no distinction
between field and method members; in other words, we reject programs
declaring both a field and a method with the same name.</p>
</li>
<li>
<p>If an identifier is not found in the local type environment, it
will be searched for in the current class type environment.  If not
there, then it will be searched for in its superclass' type
environment.  And so on and so forth.  If not found until the
<code>Object</code> class is reached, a typing error is reported.</p>
</li>
<li>
<p>The assignment allows variables to be assigned values of
more concrete types.  The result type of the assignment expression
construct will be the (more abstract) type of the assigned variable,
and not the (more concrete) type of the expression, like in Java.</p>
</li>
<li>
<p>Exceptions are changed (from SIMPLE) to allow throwing and
catching only objects, like in Java.  Also, unlike in SIMPLE, we do
not check whether the type of the thrown exception matches the type of
the caught variable, because exceptions can be caught by other
<code>try/catch</code> blocks, even by ones in other methods.  To avoid
having to annotate each method with what exceptions it can throw, we
prefer to not check the type safety of exceptions (although this is an
excellent homework!).  We only check that the <code>try</code> block
type-checks and that the <code>catch</code> block type-checks after we bind
the caught variable to its claimed type.</p>
</li>
<li>
<p>Class declarations are not allowed to have any cycles in their
extends relation.  Such cycles would lead to non-termination of
<code>new</code>, as it actually does in the dynamic semantics of KOOL
where no such circularity checks are performed.</p>
</li>
<li>
<p>Methods overriding other methods should be in the right subtyping
relationship with the overridden methods: co-variant in the codomain
and contra-variant in the domain.</p>
</li>
</ul>
<pre><code class="language-k">module KOOL-TYPED-STATIC-SYNTAX
  imports DOMAINS-SYNTAX
</code></pre>
<h2>Syntax</h2>
<p>The syntax of statically typed KOOL is identical to that of
dynamically typed KOOL, they both taking as input the same programs.
What differs is the <strong>K</strong> strictness attributes.  Like in statically
typed SIMPLE, almost all language constructs are strict now, since we
want each to type its arguments almost all the time.  Like in the
other two KOOL definitions, we prefer to copy and then modify/extend
the syntax of statically typed SIMPLE.</p>
<p><strong>Note</strong>: This paragraph is old, now we can do things better.  We keep
it here only for historical reasons, to see how much we used to suffer :)</p>
<p><strong>Annoying K-tool technical problem:</strong>
Currently, the <strong>K</strong> tool treats the &quot;non-terminal&quot; productions (i.e.,
productions consisting of just one non-terminal), also called
&quot;subsorting&quot; production, differently from the other productions.
Specifically, it does not insert a node in the AST for them.  This may
look desirable at first, but it has a big problem: it does not allow
us to treat the subsort differently in different context.  For
example, since we want <em><code>Id</code></em> to be both a type (a class name) and a
program variable, and since we want expressions to reduce to their
types, we are in an impossible situations in which we do not know how
to treat an identifier in the semantics: as a type, i.e., a result of
computations, or as a program variable, i.e., a non-result.  Ideally,
we would like to tag the identifiers at parse-time with their local
interpretation, but that, unfortunately, is not possible with the
current parsing capabilities of the <strong>K</strong> tool, because it requires to
insert additional information in the AST for the subsort productions.
This will be fixed soon.  Until then, unfortunately, we have to do the
job of the parser manually.  Instead of subsorting <em><code>Id</code></em> directly
to <em><code>Type</code></em>, we &quot;wrap&quot; it first, say with a wrapper called
<code>class(...)</code>, exactly how the parser should have done.
The major drawback of this is that all the typed KOOL programs
in <code>kool/typed/programs</code> need to also be modified to always
declare class types accordingly.  The modified programs can be found
in <code>kool/typed/static/programs</code>.  So make sure you execute the
static semantics of KOOL using the modified programs.  To avoid seeing
the wrapper in the generated documentation, we associate it an
&quot;invisibility&quot; latex attribute below.</p>
<pre><code class="language-k">  syntax Id ::= &quot;Object&quot; [token] | &quot;Main&quot; [token]
</code></pre>
<h2>Types</h2>
<pre><code class="language-k">  syntax Type ::= &quot;void&quot; | &quot;int&quot; | &quot;bool&quot; | &quot;string&quot;
                | Id                     [klabel(&quot;class&quot;), avoid]  // see next
                | class(Id)         // explicit KOOL class type
                | Type &quot;[&quot; &quot;]&quot;
                &gt; Types &quot;-&gt;&quot; Type
                | &quot;(&quot; Type &quot;)&quot;           [bracket]

  syntax Types ::= List{Type,&quot;,&quot;}
</code></pre>
<h2>Declarations</h2>
<pre><code class="language-k">  syntax Param ::= Type Id
  syntax Params ::= List{Param,&quot;,&quot;}

  syntax Decl ::= Type Exps &quot;;&quot; [avoid]
                | Type Id &quot;(&quot; Params &quot;)&quot; Block
                | &quot;class&quot; Id Block
                | &quot;class&quot; Id &quot;extends&quot; Id Block
</code></pre>
<h2>Expressions</h2>
<pre><code class="language-k">  syntax FieldReference ::= Exp &quot;.&quot; Id          [strict(1)]
  syntax ArrayReference ::= Exp &quot;[&quot; Exps &quot;]&quot;    [strict]

  syntax Exp ::= Int | Bool | String | Id
               | &quot;this&quot;
               | &quot;super&quot;
               | &quot;(&quot; Exp &quot;)&quot;             [bracket]
               | &quot;++&quot; Exp
               | Exp &quot;instanceOf&quot; Id     [strict(1)]
               | &quot;(&quot; Id &quot;)&quot; Exp          [strict(2)]
               | &quot;new&quot; Id &quot;(&quot; Exps &quot;)&quot;   [strict(2)]
               &gt; Exp &quot;(&quot; Exps &quot;)&quot;        [strict]
               | &quot;-&quot; Exp                 [strict]
               | &quot;sizeOf&quot; &quot;(&quot; Exp &quot;)&quot;    [strict]
               | &quot;read&quot; &quot;(&quot; &quot;)&quot;
               &gt; left:
                 Exp &quot;*&quot; Exp             [strict, left]
               | Exp &quot;/&quot; Exp             [strict, left]
               | Exp &quot;%&quot; Exp             [strict, left]
               &gt; left:
                 Exp &quot;+&quot; Exp             [strict, left]
               | Exp &quot;-&quot; Exp             [strict, left]
               &gt; non-assoc:
                 Exp &quot;&lt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&lt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;&gt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&gt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;==&quot; Exp            [strict, non-assoc]
               | Exp &quot;!=&quot; Exp            [strict, non-assoc]
               &gt; &quot;!&quot; Exp                 [strict]
               &gt; left:
                 Exp &quot;&amp;&amp;&quot; Exp            [strict, left]
               | Exp &quot;||&quot; Exp            [strict, left]
               &gt; &quot;spawn&quot; Block  // not strict: to check return and exceptions
               &gt; Exp &quot;=&quot; Exp             [strict(2), right]

  syntax Exp ::= FieldReference | ArrayReference
  syntax priority _.__KOOL-TYPED-STATIC-SYNTAX &gt; _[_]_KOOL-TYPED-STATIC-SYNTAX &gt; _(_)_KOOL-TYPED-STATIC-SYNTAX

  syntax Exps ::= List{Exp,&quot;,&quot;}          [strict]
</code></pre>
<h2>Statements</h2>
<pre><code class="language-k">  syntax Block ::= &quot;{&quot; &quot;}&quot;
                | &quot;{&quot; Stmts &quot;}&quot;

  syntax Stmt ::= Decl | Block
                | Exp &quot;;&quot;                                 [strict]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block &quot;else&quot; Block     [avoid, strict]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block
                | &quot;while&quot; &quot;(&quot; Exp &quot;)&quot; Block               [strict]
                | &quot;for&quot; &quot;(&quot; Stmts Exp &quot;;&quot; Exp &quot;)&quot; Block
                | &quot;return&quot; Exp &quot;;&quot;                        [strict]
                | &quot;return&quot; &quot;;&quot;
                | &quot;print&quot; &quot;(&quot; Exps &quot;)&quot; &quot;;&quot;                [strict]
                | &quot;try&quot; Block &quot;catch&quot; &quot;(&quot; Param &quot;)&quot; Block [strict(1)]
                | &quot;throw&quot; Exp &quot;;&quot;                         [strict]
                | &quot;join&quot; Exp &quot;;&quot;                          [strict]
                | &quot;acquire&quot; Exp &quot;;&quot;                       [strict]
                | &quot;release&quot; Exp &quot;;&quot;                       [strict]
                | &quot;rendezvous&quot; Exp &quot;;&quot;                    [strict]

  syntax Stmts ::= Stmt
                 | Stmts Stmts                            [seqstrict, right]
</code></pre>
<h2>Desugaring macros</h2>
<pre><code class="language-k">  rule if (E) S =&gt; if (E) S else {}                                     [macro]
  rule for(Start Cond; Step) {S:Stmts} =&gt; {Start while(Cond){S Step;}}  [macro]
  rule T:Type E1:Exp, E2:Exp, Es:Exps; =&gt; T E1; T E2, Es;               [macro-rec]
  rule T:Type X:Id = E; =&gt; T X; X = E;                                  [macro]

  rule class C:Id S =&gt; class C extends Object S

endmodule
</code></pre>
<h2>Static semantics</h2>
<p>We first discuss the configuration, then give the static semantics
taken over unchanged from SIMPLE, then discuss the static semantics of
SIMPLE syntactic constructs that needs to change, and in the end we
discuss the static semantics and additional checks specifically
related to the KOOL proper syntax.</p>
<pre><code class="language-k">module KOOL-TYPED-STATIC
  imports KOOL-TYPED-STATIC-SYNTAX
  imports DOMAINS
</code></pre>
<h2>Configuration</h2>
<p>The configuration of our type system consists of a <code>tasks</code>
cell with the same meaning like in statically typed SIMPLE, of an
<code>out</code> cell streamed to the standard output that will be used to
display typing error messages, and of a cell <code>classes</code> holding
data about each class in a separate <code>class</code> cell.  The
<code>task</code> cells now have two additional optional subcells, namely
<code>ctenvT</code> and <code>inClass</code>.  The former holds a temporary
class type environment; its contents will be transferred into the
<code>ctenv</code> cell of the corresponding class as soon as all the
fields and methods in the task are processed.  In fact, there will be
three types of tasks in the subsequent semantics, each determined by
the subset of cells that it holds:</p>
<ol>
<li>
<p><strong>Main task</strong>, holding only a <code>k</code> cell holding the
original program as a set of classes.  The role of this task is to
process each class, generating a class task (see next) for each.</p>
</li>
<li>
<p><strong>Class task</strong>, holding <code>k</code>, <code>ctenvT</code>, and
<code>inClass</code> subcells.  The role of this task type is to process
a class' contents, generating a class type environment in the
<code>ctenvT</code> cell and a method task (see next) for each method in
the class.  To avoid interference with object member lookup rules
below, it is important to add the class type environment to a class
atomically; this is the reason for which we use <code>ctenvT</code>
temporary cells within class tasks (instead of adding each member
incrementally to the class' type environment).</p>
</li>
<li>
<p><strong>Method task</strong>, holding <code>k</code>, <code>tenv</code> and
<code>return</code> cells.  These tasks are similar to SIMPLE's function
tasks, so we do not discuss them here any further.</p>
</li>
</ol>
<p>Each <code>class</code> cell hods its name (in the <code>className</code>
cell) and the name of the class it extends (in the <code>extends</code>
cell), as well as its type environment (in the <code>ctenv</code> cell)
and the set of all its superclasses (in the <code>extendsAll</code> cell).
The later is useful for example for checking whether there are cycles
in the class extends relation.</p>
<pre><code class="language-k">  configuration &lt;T multiplicity=&quot;?&quot; color=&quot;yellow&quot;&gt;
                  &lt;tasks color=&quot;orange&quot; multiplicity=&quot;?&quot;&gt;
                    &lt;task multiplicity=&quot;*&quot; color=&quot;yellow&quot;&gt;
                      &lt;k color=&quot;green&quot;&gt; $PGM:Stmts &lt;/k&gt;
                      &lt;tenv multiplicity=&quot;?&quot; color=&quot;cyan&quot;&gt; .Map &lt;/tenv&gt;
                      &lt;ctenvT multiplicity=&quot;?&quot; color=&quot;blue&quot;&gt; .Map &lt;/ctenvT&gt;
                      &lt;returnType multiplicity=&quot;?&quot; color=&quot;black&quot;&gt; void &lt;/returnType&gt;
                      &lt;inClass multiplicity=&quot;?&quot; color=&quot;Fuchsia&quot;&gt; .K &lt;/inClass&gt;
                    &lt;/task&gt;
                  &lt;/tasks&gt;
//                  &lt;br/&gt;
                  &lt;classes color=&quot;Fuchsia&quot;&gt;
                    &lt;classData multiplicity=&quot;*&quot;&gt;
                      &lt;className color=&quot;Fuchsia&quot;&gt; Object &lt;/className&gt;
                      &lt;baseClass color=&quot;Fuchsia&quot;&gt; .K &lt;/baseClass&gt;
                      &lt;baseClasses color=&quot;Fuchsia&quot;&gt; .Set &lt;/baseClasses&gt;
                      &lt;ctenv multiplicity=&quot;?&quot; color=&quot;blue&quot;&gt; .Map &lt;/ctenv&gt;
                    &lt;/classData&gt;
                  &lt;/classes&gt;
                &lt;/T&gt;
                &lt;output color=&quot;brown&quot; stream=&quot;stdout&quot;&gt; .List &lt;/output&gt;
</code></pre>
<h2>Unchanged semantics from statically typed SIMPLE</h2>
<p>The syntax and rules below are borrowed unchanged from statically
typed SIMPLE, so we do not discuss them much here.</p>
<pre><code class="language-k">  syntax Exp ::= Type
  syntax Exps ::= Types
  syntax BlockOrStmtType ::= &quot;block&quot; | &quot;stmt&quot;
  syntax Type ::= BlockOrStmtType
  syntax Block ::= BlockOrStmtType
  syntax KResult ::= Type
                   | Types  // TODO: should not be needed


  context _:Type _::Exp[HOLE::Exps];

  rule T:Type E:Exp[int,Ts:Types]; =&gt; T[] E[Ts];  [structural]
  rule T:Type E:Exp[.Types]; =&gt; T E;          [structural]


  rule &lt;task&gt;... &lt;k&gt; _:BlockOrStmtType &lt;/k&gt; &lt;tenv&gt; _ &lt;/tenv&gt; ...&lt;/task&gt; =&gt; .Bag


  rule _:Int =&gt; int
  rule _:Bool =&gt; bool
  rule _:String =&gt; string


  rule &lt;k&gt; X:Id =&gt; T ...&lt;/k&gt; &lt;tenv&gt;... X |-&gt; T ...&lt;/tenv&gt;


  context ++(HOLE =&gt; ltype(HOLE))
  rule ++ int =&gt; int
  rule int + int =&gt; int
  rule string + string =&gt; string
  rule int - int =&gt; int
  rule int * int =&gt; int
  rule int / int =&gt; int
  rule int % int =&gt; int
  rule - int =&gt; int
  rule int &lt; int =&gt; bool
  rule int &lt;= int =&gt; bool
  rule int &gt; int =&gt; bool
  rule int &gt;= int =&gt; bool
  rule T:Type == T =&gt; bool
  rule T:Type != T =&gt; bool
  rule bool &amp;&amp; bool =&gt; bool
  rule bool || bool =&gt; bool
  rule ! bool =&gt; bool


  rule (T[])[int, Ts:Types] =&gt; T[Ts]
  rule T:Type[.Types] =&gt; T

  rule sizeOf(T[]) =&gt; int


  rule read() =&gt; int

  rule print(T:Type, Ts =&gt; Ts); when T ==K int orBool T ==K string
  rule print(.Types); =&gt; stmt


  context (HOLE =&gt; ltype(HOLE)) = _


  rule &lt;k&gt; return; =&gt; stmt ...&lt;/k&gt; &lt;returnType&gt; _ &lt;/returnType&gt;


  rule {} =&gt; block

  rule &lt;task&gt; &lt;k&gt; {S:Stmts} =&gt; block ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt; &lt;k&gt; S &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;)

  rule _:Type; =&gt; stmt
  rule if (bool) block else block =&gt; stmt
  rule while (bool) block =&gt; stmt

  rule join int; =&gt; stmt
  rule acquire _:Type; =&gt; stmt
  rule release _:Type; =&gt; stmt
  rule rendezvous _:Type; =&gt; stmt

  syntax Stmt ::= BlockOrStmtType
  rule _:BlockOrStmtType _:BlockOrStmtType =&gt; stmt
</code></pre>
<h2>Unchanged auxiliary operations from dynamically typed SIMPLE</h2>
<pre><code class="language-k">  syntax Stmts ::= mkDecls(Params)  [function]
  rule mkDecls(T:Type X:Id, Ps:Params) =&gt; T X; mkDecls(Ps)
  rule mkDecls(.Params) =&gt; {}

  syntax LValue ::= Id
                  | FieldReference
                  | ArrayReference
  syntax Exp ::= LValue

  syntax Exp ::= ltype(Exp)
// We would like to say:
//  context ltype(HOLE:LValue)
// but we currently cannot type the HOLE
  context ltype(HOLE) when isLValue(HOLE)

// OLD approach:
//  syntax Exp ::= ltype(Exp)  [function]
//  rule ltype(X:Id) =&gt; X
//  rule ltype(E:Exp [Es:Exps]) =&gt; E[Es]

  syntax Types ::= getTypes(Params)  [function]
  rule getTypes(T:Type _:Id) =&gt; T, .Types
  rule getTypes(T:Type _:Id, P, Ps) =&gt; T, getTypes(P,Ps)
  rule getTypes(.Params) =&gt; void, .Types
</code></pre>
<h2>Changes to the existing statically typed SIMPLE semantics</h2>
<p>Below we give the new static semantics for language constructs that
come from SIMPLE, but whose SIMPLE static semantics was too
restrictive or too permissive and thus had to change.</p>
<h2>Local variable declaration</h2>
<p>Since we can define new types in KOOL (corresponding to classes), the
variable declaration needs to now check that the claimed types exist.
The operation <code>checkType</code>, defined at the end of this module,
checks whether the argument type is correct (it actually works with
lists of types as well).</p>
<pre><code class="language-k">  rule &lt;k&gt; T:Type X:Id; =&gt; checkType(T) ~&gt; stmt ...&lt;/k&gt;
       &lt;tenv&gt; Rho =&gt; Rho[X &lt;- T] &lt;/tenv&gt;
</code></pre>
<h2>Class member declaration</h2>
<p>In class tasks, variable declarations mean class member declarations.
Since we reduce method declarations to variable declarations (see
below), a variable declaration in a class task can mean either a field
or a method declaration.  Unlike local variable declarations, which
can shadow previous homonymous local or member declarations, member
declarations are regarded as a set, so we disallow multiple
declarations for the same member (one could improve upon this, like in
Java, by treating members with different types or number of arguments
as different, etc., but we do not do it here).  We also issue an error
message if one attempts to redeclare the same class member.  The
framed variable declaration in the second rule below should be read
&quot;stuck&quot;.  In fact, it is nothing but a unary operation called
<code>stuck</code>, which takes a <strong>K</strong>-term as argument and does nothing
with it; this <code>stuck</code> operation is displayed as a frame in this
PDF document because of its latex attribute (see the ASCII .k file,
at the end of this module).</p>
<pre><code class="language-k">  rule &lt;k&gt; T:Type X:Id; =&gt; checkType(T) ~&gt; stmt ...&lt;/k&gt;
       &lt;ctenvT&gt; Rho (.Map =&gt; X |-&gt; T) &lt;/ctenvT&gt;
    when notBool(X in keys(Rho))

  rule &lt;k&gt; T:Type X:Id; =&gt; stuck(T X;) ...&lt;/k&gt;
       &lt;ctenvT&gt;... X |-&gt; _ ...&lt;/ctenvT&gt;
       &lt;inClass&gt; C:Id &lt;/inClass&gt;
//       &lt;br/&gt;
       &lt;output&gt;... .List =&gt; ListItem(&quot;Member \&quot;&quot; +String Id2String(X)
                              +String &quot;\&quot; declared twice in class \&quot;&quot;
                              +String Id2String(C) +String &quot;\&quot;!\n&quot;) &lt;/output&gt;
    [structural]
</code></pre>
<h2>Method declaration</h2>
<p>A method declaration requires two conceptual checks to be performed:
first, that the method's type is consistent with the type of the
homonymous method that it overrides, if any; and second, that its body
types correctly.  At the same time, it should also be added to the
type environment of its class.  The first conceptual task is performed
using the <code>checkMethod</code> operation defined below, and the second
by generating a corresponding method task.  To add it to the class
type environment, we take advantage of the fact that KOOL is higher
order and reduce the problem to a field declaration problem, which we
have already defined.  The role of the <code>ctenvT</code> cell in the
rule below is to structurally ensure that the method declaration takes
place in a class task (we do not want to allow methods to be declared,
for example, inside other methods).</p>
<pre><code class="language-k">  rule &lt;k&gt; T:Type F:Id(Ps:Params) S
        =&gt; checkMethod(F, getTypes(Ps)-&gt;T, C')
           ~&gt; getTypes(Ps)-&gt;T F; ...&lt;/k&gt;
//       &lt;br/&gt;
       &lt;inClass&gt; C &lt;/inClass&gt;
       &lt;ctenvT&gt; _ &lt;/ctenvT&gt; // to ensure we are in a class pass
       &lt;className&gt; C &lt;/className&gt;
       &lt;baseClass&gt; C' &lt;/baseClass&gt;
//       &lt;br/&gt;
       (.Bag =&gt; &lt;task&gt;
               &lt;k&gt; mkDecls(Ps) S &lt;/k&gt;
               &lt;inClass&gt; C &lt;/inClass&gt;
               &lt;tenv&gt; .Map &lt;/tenv&gt;
               &lt;returnType&gt; T &lt;/returnType&gt;
             &lt;/task&gt;)
    [structural]
</code></pre>
<h2>Assignment</h2>
<p>A more concrete value is allowed to be assigned to a more abstract
variable.  The operation <code>checkSubtype</code> is defined at the end
of the module and it also works with pairs of lists of types.</p>
<pre><code class="language-k">  rule T:Type = T':Type =&gt; checkSubtype(T', T) ~&gt; T
</code></pre>
<h2>Method invocation and return</h2>
<p>Methods can be applied on values of more concrete types than their
arguments:</p>
<pre><code class="language-k">  rule (Ts:Types -&gt; T:Type) (Ts':Types) =&gt; checkSubtype(Ts',Ts) ~&gt; T
</code></pre>
<p>Similarly, we allow values of more concrete types to be returned by
methods:</p>
<pre><code class="language-k">  rule &lt;k&gt; return T:Type; =&gt; checkSubtype(T,T') ~&gt; stmt ...&lt;/k&gt;
       &lt;returnType&gt; T':Type &lt;/returnType&gt;
</code></pre>
<h2>Exceptions</h2>
<p>Exceptions can throw and catch values of any types.  Since unlike in Java
KOOL's methods do not declare the exception types that they can throw,
we cannot test the full type safety of exceptions.  Instead, we
only check that the <code>try</code> and the <code>catch</code> statements
type correctly.</p>
<pre><code class="language-k">  rule try block catch(T:Type X:Id) S =&gt; {T X; S}  [structural]
  rule throw T:Type ; =&gt; stmt
</code></pre>
<h2>Spawn</h2>
<p>The spawned cell needs to also be passed the parent's class.</p>
<pre><code class="language-k">// explain why

  rule &lt;k&gt; spawn S:Block =&gt; int ...&lt;/k&gt;
       &lt;tenv&gt; Rho &lt;/tenv&gt;
       &lt;inClass&gt; C &lt;/inClass&gt;
       (.Bag =&gt; &lt;task&gt;
               &lt;k&gt; S &lt;/k&gt;
               &lt;tenv&gt; Rho &lt;/tenv&gt;
               &lt;inClass&gt; C &lt;/inClass&gt;
             &lt;/task&gt;)
</code></pre>
<h2>Semantics of the new KOOL constructs</h2>
<h2>Class declaration</h2>
<p>We process each class in the main task, adding the corresponding data
into its <code>class</code> cell and also adding a class task for it.  We
also perform some well-formedness checks on the class hierarchy.</p>
<p><strong>Initiate class processing</strong><br>
We create a class cell and a class task for each task.  Also, we start
the class task with a check that the class it extends is declared
(this delays the task until that class is processed using another
instance of this rule).</p>
<pre><code class="language-k">// There seems to be some error with the configuration concretization,
// as the rule below does not work when rewriting . to both the task
// and the class cells; I had to include two separate . rewrites

// TODO: the following fails krun; see #2117
  rule &lt;task&gt; &lt;k&gt; class C:Id extends C':Id { S:Stmts } =&gt; stmt ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;classData&gt;...
               &lt;className&gt; C &lt;/className&gt;
               &lt;baseClass&gt; C' &lt;/baseClass&gt;
             ...&lt;/classData&gt;)
//       &lt;br/&gt;
       (.Bag =&gt; &lt;task&gt;
                &lt;k&gt; checkType(class(C')) ~&gt; S &lt;/k&gt;
                &lt;inClass&gt; C &lt;/inClass&gt;
                &lt;ctenvT&gt; .Map &lt;/ctenvT&gt;
             &lt;/task&gt;)
    [structural]

// You may want to try the thing below, but that failed, too
/*
syntax Type ::= &quot;stmtStop&quot;

  rule &lt;tasks&gt;...
       &lt;task&gt; &lt;k&gt; class C:Id extends C':Id { S:Stmts } =&gt; stmtStop ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt;
                &lt;k&gt; checkType(class(C')) ~&gt; S &lt;/k&gt;
                &lt;inClass&gt; C &lt;/inClass&gt;
                &lt;ctenvT&gt; .Map &lt;/ctenvT&gt;
             &lt;/task&gt;)
       ...&lt;/tasks&gt;
       &lt;classes&gt;...
       .Bag =&gt; &lt;classData&gt;...
               &lt;className&gt; C &lt;/className&gt;
               &lt;baseClass&gt; C' &lt;/baseClass&gt;
             ...&lt;/classData&gt;
       ...&lt;/classes&gt;
//       &lt;br/&gt;
  [structural]
*/
</code></pre>
<h2>Check for unique class names</h2>
<pre><code class="language-k">  rule (&lt;T&gt;...
          &lt;className&gt; C &lt;/className&gt;
          &lt;className&gt; C &lt;/className&gt;
        ...&lt;/T&gt; =&gt; .Bag)
       &lt;output&gt;... .List =&gt; ListItem(&quot;Class \&quot;&quot; +String Id2String(C)
                                  +String &quot;\&quot; declared twice!\n&quot;) &lt;/output&gt;
    [structural]
</code></pre>
<p><strong>Check for cycles in class hierarchy</strong><br>
We check for cycles in the class hierarchy by transitively closing the
class extends relation using the <code>extendsAll</code> cells, and
checking that a class will never appear in its own <code>extendsAll</code>
cell.  The first rule below initiates the transitive closure of the
superclass relation, the second transitively closes it, and the third
checks for cycles.</p>
<pre><code class="language-k">  rule &lt;baseClass&gt; C &lt;/baseClass&gt;
       &lt;baseClasses&gt; .Set =&gt; SetItem(C) &lt;/baseClasses&gt;  [structural]

  rule &lt;classData&gt;...
         &lt;baseClasses&gt; SetItem(C) Cs:Set (.Set =&gt; SetItem(C')) &lt;/baseClasses&gt;
       ...&lt;/classData&gt;
       &lt;classData&gt;... &lt;className&gt;C&lt;/className&gt; &lt;baseClass&gt;C'&lt;/baseClass&gt; ...&lt;/classData&gt;
    when notBool(C' in (SetItem(C) Cs))  [structural]

  rule (&lt;T&gt;...
          &lt;className&gt; C &lt;/className&gt;
          &lt;baseClasses&gt;... SetItem(C) ...&lt;/baseClasses&gt;
        ...&lt;/T&gt; =&gt; .Bag)
       &lt;output&gt;... .List =&gt; ListItem(&quot;Class \&quot;&quot; +String Id2String(C)
                                  +String &quot;\&quot; is in a cycle!\n&quot;) &lt;/output&gt;
    [inheritance-cycle]
</code></pre>
<h2>New</h2>
<p>To type <code>new</code> we only need to check that the class constructor
can be called with arguments of the given types, so we initiate a call
to the constructor method in the corresponding class.  If that
succeeds, meaning that it types to <code>stmt</code>, then we discard the
<code>stmt</code> type and produce instead the corresponding class type of
the new object.  The auxiliary <code>discard</code> operation is defined
also at the end of this module.</p>
<pre><code class="language-k">  rule new C:Id(Ts:Types) =&gt; class(C) . C (Ts) ~&gt; discard ~&gt; class(C)
</code></pre>
<h2>Self reference</h2>
<p>The typing rule for <code>this</code> is straightforward: reduce to the
current class type.</p>
<pre><code class="language-k">  rule &lt;k&gt; this =&gt; class(C) ...&lt;/k&gt;
       &lt;inClass&gt; C:Id &lt;/inClass&gt;
</code></pre>
<h2>Super</h2>
<p>Similarly, <code>super</code> types to the parent class type.
Note that for typing concerns, super can be considered as an object
(recall that this was not the case in the dynamic semantics).</p>
<pre><code class="language-k">   rule &lt;k&gt; super =&gt; class(C') ...&lt;/k&gt;
        &lt;inClass&gt; C:Id &lt;/inClass&gt;
        &lt;className&gt; C &lt;/className&gt;
        &lt;baseClass&gt; C':Id &lt;/baseClass&gt;
</code></pre>
<h2>Object member access</h2>
<p>There are several cases to consider here.  First, if we are in a class
task, we should lookup the member into the temporary class type
environemnt in cell <code>ctenvT</code>.  That is because we want to allow
initialized field declarations in classes, such as <code>int x=10;</code>.
This is desugared to a declaration of <code>x</code>, which is added to
<code>ctenvT</code> during the class task processing, followed by an
assignment of <code>x</code> to 10.  In order for the assignment to type
check, we need to know that <code>x</code> has been declared with type
<code>int</code>; this information can only be found in the
<code>ctenvT</code> cell.  Second, we should redirect non-local variable
lookups in method tasks to corresponding member accesses (the
local variables are handled by the rule borrowed from SIMPLE).
This is what the second rule below does.  Third, we should allow
object member accesses as lvalues, which is done by the third rule
below.  These last two rules therefore ensure that each necessary
object member access is explicitly allowed for evaluation.  Recall
from the annotated syntax module above that the member access
operation is strict in the object.  That means that the object is
expected to evaluate to a class type.  The next two rules below define
the actual member lookup operation, moving the search to the
superclass when the member is not found in the current class.  Note
that this works because we create the class type environments
atomically; thus, a class either has its complete type environment
available, in which case these rules can safely apply, or its cell
<code>ctenv</code> is not yet available, in which case these rules have to
wait.  Finally, the sixth rule below reports an error when the
<code>Object</code> class is reached.</p>
<pre><code class="language-k">  rule &lt;k&gt; X:Id =&gt; T ...&lt;/k&gt;
       &lt;ctenvT&gt;... X |-&gt; T ...&lt;/ctenvT&gt;

  rule &lt;k&gt; X:Id =&gt; this . X ...&lt;/k&gt;
       &lt;tenv&gt; Rho &lt;/tenv&gt;
    when notBool(X in keys(Rho))

// OLD approach:
//  rule ltype(E:Exp . X:Id) =&gt; E . X  [structural]

  rule &lt;k&gt; class(C:Id) . X:Id =&gt; T ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;ctenv&gt;... X |-&gt; T:Type ...&lt;/ctenv&gt;

  rule &lt;k&gt; class(C1:Id =&gt; C2) . X:Id ...&lt;/k&gt;
       &lt;className&gt; C1 &lt;/className&gt;
       &lt;baseClass&gt; C2:Id &lt;/baseClass&gt;
       &lt;ctenv&gt; Rho &lt;/ctenv&gt;
    when notBool(X in keys(Rho))  [structural]

  rule &lt;k&gt; class(Object) . X:Id =&gt; stuck(class(Object) . X) ...&lt;/k&gt;
       &lt;inClass&gt; C:Id &lt;/inClass&gt;
//      &lt;br/&gt;
       &lt;output&gt;... .List =&gt; ListItem(&quot;Member \&quot;&quot; +String Id2String(X)
                              +String &quot;\&quot; not declared! (see class \&quot;&quot;
                              +String Id2String(C) +String &quot;\&quot;)\n&quot;) &lt;/output&gt;
    [structural]
</code></pre>
<h2>Instance of and casting</h2>
<p>As it is hard to check statically whether casting is always safe,
the programmer is simply trusted from a typing perspective.  We only
do some basic upcasting and downcasting checks, to reject casts which
will absolutely fail.  However, dynamic semantics or implementations
of the language need to insert runtime checks for downcasting to be safe.</p>
<pre><code class="language-k">  rule class(C1:Id) instanceOf C2:Id =&gt; bool
  rule (C:Id) class(C) =&gt; class(C)
  rule &lt;k&gt; (C2:Id) class(C1:Id) =&gt; class(C2) ...&lt;/k&gt;
       &lt;className&gt; C1 &lt;/className&gt;
       &lt;baseClasses&gt;...SetItem(C2)...&lt;/baseClasses&gt;    // upcast
  rule &lt;k&gt; (C2:Id) class(C1:Id) =&gt; class(C2) ...&lt;/k&gt;
       &lt;className&gt; C2 &lt;/className&gt;
       &lt;baseClasses&gt;...SetItem(C1)...&lt;/baseClasses&gt;    // downcast
  rule &lt;k&gt; (C2) class(C1:Id) =&gt; stuck((C2) class(C1)) ...&lt;/k&gt;
       &lt;classData&gt;...
         &lt;className&gt; C1 &lt;/className&gt;
         &lt;baseClasses&gt; S1 &lt;/baseClasses&gt;
       ...&lt;/classData&gt;
       &lt;classData&gt;...
         &lt;className&gt; C2 &lt;/className&gt;
         &lt;baseClasses&gt; S2 &lt;/baseClasses&gt;
       ...&lt;/classData&gt;
       &lt;output&gt;... .List =&gt; ListItem(&quot;Classes \&quot;&quot; +String Id2String(C1)
                              +String &quot;\&quot; and \&quot;&quot; +String Id2String(C2)
                              +String &quot;\&quot; are incompatible!\n&quot;) &lt;/output&gt;
    when notBool(C1 in S2) andBool notBool(C2 in S1)
    [transition]
    // ugly solution to avoid non-confluence (rule may apply before
    // extendsAll is populated); strategies will solve the problem nicely.
</code></pre>
<h2>Cleanup tasks</h2>
<p>Finally, we need to clean up the terminated tasks.  Each of the three
types of tasks is handled differently.  The main task is replaced by a
method task holding <code>new main();</code>, which will ensure that a
<code>main</code> class with a <code>main()</code> method actually exists
(first rule below).  A class task moves its temporary class type
environment into its class' cell, and then it dissolves itself (second
rule).  A method task simply dissolves when terminated (third rule);
the presence of the <code>tenv</code> cell in that rule ensures that that
task is a method task.
Finally, when all the tasks are cleaned up, we can also remove the
<code>tasks</code> cell, issuing a corresponding message.  Note that
checking for cycles or duplicate methods can still be performed after
the <code>tasks</code> cell has been removed.</p>
<pre><code class="language-k">// discard main task when done, issuing a &quot;new main();&quot; command to
// make sure that the class main and the method main() are declared.

  rule &lt;task&gt; &lt;k&gt; stmt =&gt; new Main(.Exps); &lt;/k&gt;
              (.Bag =&gt; &lt;tenv&gt; .Map &lt;/tenv&gt;
                    &lt;returnType&gt; void &lt;/returnType&gt;
                    &lt;inClass&gt; Main &lt;/inClass&gt;)
       &lt;/task&gt;
    [structural]

// discard class task when done, adding a ctenv in class

  rule (&lt;task&gt;
          &lt;k&gt; stmt &lt;/k&gt;
          &lt;ctenvT&gt; Rho &lt;/ctenvT&gt;
          &lt;inClass&gt; C:Id &lt;/inClass&gt;
        &lt;/task&gt; =&gt; .Bag)
        &lt;className&gt; C &lt;/className&gt;
        (.Bag =&gt; &lt;ctenv&gt; Rho &lt;/ctenv&gt;)
    [structural]

// discard method task when done

  rule &lt;task&gt;...
         &lt;k&gt; stmt &lt;/k&gt;
         &lt;tenv&gt; _ &lt;/tenv&gt;  // only to ensure that this is a method task
       ...&lt;/task&gt; =&gt; .Bag
    [structural]

// cleanup tasks and output a success message when done

  rule (&lt;T&gt;... &lt;tasks&gt; .Bag &lt;/tasks&gt; ...&lt;/T&gt; =&gt; .Bag)
       &lt;output&gt;... .List =&gt; ListItem(&quot;Type checked!\n&quot;) &lt;/output&gt;
    [structural]
</code></pre>
<h2>KOOL-specific auxiliary declarations and operations</h2>
<h2>Subtype checking</h2>
<p>The subclass relation introduces a subtyping relation.</p>
<pre><code class="language-k">  syntax KItem ::= checkSubtype(Types,Types)

  rule checkSubtype(T:Type, T) =&gt; .  [structural]

  rule &lt;k&gt; checkSubtype(class(C:Id), class(C':Id)) =&gt; . ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;baseClasses&gt;... SetItem(C') ...&lt;/baseClasses&gt;  [structural]

  rule checkSubtype(Ts1-&gt;T2,Ts1'-&gt;T2')
    =&gt; checkSubtype(((T2)::Type,Ts1'),((T2')::Type,Ts1))  [structural]

// note that the following rule would be wrong!
//  rule checkSubtype(T[],T'[]) =&gt; checkSubtype(T,T')

  rule checkSubtype((T:Type,Ts),(T':Type,Ts'))
    =&gt; checkSubtype(T,T') ~&gt; checkSubtype(Ts,Ts')
    when Ts =/=K .Types  [structural]

  rule checkSubtype(.Types,.Types) =&gt; .  [structural]
  rule checkSubtype(.Types,void) =&gt; .  [structural]
</code></pre>
<h2>Checking well-formedness of types</h2>
<p>Since now any <em><code>Id</code></em> can be used as the type of a class, we need to
check that the types used in the program actually exists</p>
<pre><code class="language-k">  syntax KItem ::= checkType(Types)

  rule checkType(T:Type,Ts:Types) =&gt; checkType(T) ~&gt; checkType(Ts)
    when Ts =/=K .Types  [structural]
  rule checkType(.Types) =&gt; .  [structural]
  rule checkType(int) =&gt; .  [structural]
  rule checkType(bool) =&gt; .  [structural]
  rule checkType(string) =&gt; .  [structural]
  rule checkType(void) =&gt; .  [structural]
  rule &lt;k&gt; checkType(class(C:Id)) =&gt; . ...&lt;/k&gt; &lt;className&gt; C &lt;/className&gt;
    [structural]
  rule checkType(class(Object)) =&gt; .  [structural]
  rule checkType(Ts:Types -&gt; T:Type) =&gt; checkType(T,Ts)  [structural]
  rule checkType(T:Type[]) =&gt; checkType(T)  [structural]
</code></pre>
<h2>Checking correct  overiding of methods</h2>
<p>The <code>checkMethod</code> operation below searches to see whether
the current method overrides some other method in some superclass.
If yes, then it issues an additional check that the new method's type
is more concrete than the overridden method's.  The types <code>T</code> and <code>T'</code>
below can only be function types.  See the definition of
<code>checkSubtype</code> on function types at the end of this module (it
is co-variant in the codomain and contra-variant in the domain).</p>
<pre><code class="language-k">  syntax KItem ::= checkMethod(Id,Type,Id)

  rule &lt;k&gt; checkMethod(F:Id, T:Type, C:Id) =&gt; checkSubtype(T, T') ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;ctenv&gt;... F |-&gt; T':Type ...&lt;/ctenv&gt;
    [structural]

  rule &lt;k&gt; checkMethod(F:Id, T:Type, (C:Id =&gt; C')) ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;baseClass&gt; C':Id &lt;/baseClass&gt;
       &lt;ctenv&gt; Rho &lt;/ctenv&gt;
    when notBool(F in keys(Rho))  [structural]

  rule checkMethod(_:Id,_,Object) =&gt; .
</code></pre>
<h2>Generic operations which could be part of the <strong>K</strong> framework</h2>
<pre><code class="language-k">  syntax KItem ::= stuck(K)  [latex(\framebox{${#1}$})]

  syntax KItem ::= &quot;discard&quot;
  rule _:KResult ~&gt; discard =&gt; .  [structural]

endmodule
</code></pre>

          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
