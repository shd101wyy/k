<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1>KOOL &#x2014; Typed &#x2014; Static</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2>Abstract</h2>
<p>This is the <strong>K</strong> static semantics of the typed KOOL language.
It extends the static semantics of typed SIMPLE with static semantics
for the object-oriented constructs.  Also, the static semantics of
some of the existing SIMPLE constructs need to change, in order to
become more generous with regards to the set of accepted programs,
mostly due to subtyping.  For example, the assignment construct
<code>x = e</code> required that both the variable <code>x</code> and the
expression <code>e</code> had the same type in SIMPLE.  In KOOL, the type
of <code>e</code> can be a subtype of the type of <code>x</code>.
Specifically, we define the following typing policy for KOOL,
everything else not mentioned below borrowing its semantics from
SIMPLE:</p>
<ul>
<li>
<p>Each class <code>C</code> yields a homonymous type, which can be
explicitly used in programs to type variables and methods, possibly in
combination with other types.</p>
</li>
<li>
<p>Since now we have user-defined types, we check that each type
used in a KOOL program is well-formed, that is, it is constructed only
from primitive and class types corresponding to declared classes.</p>
</li>
<li>
<p>Class members and their types form a <strong>class type
environment</strong>.  Each class will have such a type environment.
Each member in a class is allowed to be declared only once.  Since in
KOOL we allow methods to be assigned to fields, we make no distinction
between field and method members; in other words, we reject programs
declaring both a field and a method with the same name.</p>
</li>
<li>
<p>If an identifier is not found in the local type environment, it
will be searched for in the current class type environment.  If not
there, then it will be searched for in its superclass&apos; type
environment.  And so on and so forth.  If not found until the
<code>Object</code> class is reached, a typing error is reported.</p>
</li>
<li>
<p>The assignment allows variables to be assigned values of
more concrete types.  The result type of the assignment expression
construct will be the (more abstract) type of the assigned variable,
and not the (more concrete) type of the expression, like in Java.</p>
</li>
<li>
<p>Exceptions are changed (from SIMPLE) to allow throwing and
catching only objects, like in Java.  Also, unlike in SIMPLE, we do
not check whether the type of the thrown exception matches the type of
the caught variable, because exceptions can be caught by other
<code>try/catch</code> blocks, even by ones in other methods.  To avoid
having to annotate each method with what exceptions it can throw, we
prefer to not check the type safety of exceptions (although this is an
excellent homework!).  We only check that the <code>try</code> block
type-checks and that the <code>catch</code> block type-checks after we bind
the caught variable to its claimed type.</p>
</li>
<li>
<p>Class declarations are not allowed to have any cycles in their
extends relation.  Such cycles would lead to non-termination of
<code>new</code>, as it actually does in the dynamic semantics of KOOL
where no such circularity checks are performed.</p>
</li>
<li>
<p>Methods overriding other methods should be in the right subtyping
relationship with the overridden methods: co-variant in the codomain
and contra-variant in the domain.</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> KOOL-TYPED-STATIC-SYNTAX<span class="hljs-keyword">
  imports</span> DOMAINS-SYNTAX
</code></pre>
<h2>Syntax</h2>
<p>The syntax of statically typed KOOL is identical to that of
dynamically typed KOOL, they both taking as input the same programs.
What differs is the <strong>K</strong> strictness attributes.  Like in statically
typed SIMPLE, almost all language constructs are strict now, since we
want each to type its arguments almost all the time.  Like in the
other two KOOL definitions, we prefer to copy and then modify/extend
the syntax of statically typed SIMPLE.</p>
<p><strong>Note</strong>: This paragraph is old, now we can do things better.  We keep
it here only for historical reasons, to see how much we used to suffer :)</p>
<p><strong>Annoying K-tool technical problem:</strong>
Currently, the <strong>K</strong> tool treats the &quot;non-terminal&quot; productions (i.e.,
productions consisting of just one non-terminal), also called
&quot;subsorting&quot; production, differently from the other productions.
Specifically, it does not insert a node in the AST for them.  This may
look desirable at first, but it has a big problem: it does not allow
us to treat the subsort differently in different context.  For
example, since we want <em><code>Id</code></em> to be both a type (a class name) and a
program variable, and since we want expressions to reduce to their
types, we are in an impossible situations in which we do not know how
to treat an identifier in the semantics: as a type, i.e., a result of
computations, or as a program variable, i.e., a non-result.  Ideally,
we would like to tag the identifiers at parse-time with their local
interpretation, but that, unfortunately, is not possible with the
current parsing capabilities of the <strong>K</strong> tool, because it requires to
insert additional information in the AST for the subsort productions.
This will be fixed soon.  Until then, unfortunately, we have to do the
job of the parser manually.  Instead of subsorting <em><code>Id</code></em> directly
to <em><code>Type</code></em>, we &quot;wrap&quot; it first, say with a wrapper called
<code>class(...)</code>, exactly how the parser should have done.
The major drawback of this is that all the typed KOOL programs
in <code>kool/typed/programs</code> need to also be modified to always
declare class types accordingly.  The modified programs can be found
in <code>kool/typed/static/programs</code>.  So make sure you execute the
static semantics of KOOL using the modified programs.  To avoid seeing
the wrapper in the generated documentation, we associate it an
&quot;invisibility&quot; latex attribute below.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Id</span> ::= <span class="hljs-string">&quot;Object&quot;</span> [<span class="hljs-literal">token</span>] | <span class="hljs-string">&quot;Main&quot;</span> [<span class="hljs-literal">token</span>]
</code></pre>
<h2>Types</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Type ::= <span class="hljs-string">&quot;void&quot;</span> | <span class="hljs-string">&quot;int&quot;</span> | <span class="hljs-string">&quot;bool&quot;</span> | <span class="hljs-string">&quot;string&quot;</span>
                |<span class="hljs-keyword"> Id</span>                     [klabel(<span class="hljs-string">&quot;class&quot;</span>), <span class="hljs-literal">avoid</span>]  <span class="hljs-comment">// see next</span>
                | class(<span class="hljs-keyword">Id</span>)         <span class="hljs-comment">// explicit KOOL class type</span>
                | Type <span class="hljs-string">&quot;[&quot;</span> <span class="hljs-string">&quot;]&quot;</span>
                &gt; Types <span class="hljs-string">&quot;-&gt;&quot;</span> Type
                | <span class="hljs-string">&quot;(&quot;</span> Type <span class="hljs-string">&quot;)&quot;</span>           [<span class="hljs-literal">bracket</span>]<span class="hljs-keyword">

  syntax</span> Types ::= List{Type,<span class="hljs-string">&quot;,&quot;</span>}
</code></pre>
<h2>Declarations</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Param ::= Type<span class="hljs-keyword"> Id</span><span class="hljs-keyword">
  syntax</span> Params ::= List{Param,<span class="hljs-string">&quot;,&quot;</span>}<span class="hljs-keyword">

  syntax</span> Decl ::= Type Exps <span class="hljs-string">&quot;;&quot;</span> [<span class="hljs-literal">avoid</span>]
                | Type<span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;(&quot;</span> Params <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;class&quot;</span><span class="hljs-keyword"> Id</span> Block
                | <span class="hljs-string">&quot;class&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;extends&quot;</span><span class="hljs-keyword"> Id</span> Block
</code></pre>
<h2>Expressions</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> FieldReference ::= Exp <span class="hljs-string">&quot;.&quot;</span><span class="hljs-keyword"> Id</span>          [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]<span class="hljs-keyword">
  syntax</span> ArrayReference ::= Exp <span class="hljs-string">&quot;[&quot;</span> Exps <span class="hljs-string">&quot;]&quot;</span>    [<span class="hljs-literal">strict</span>]<span class="hljs-keyword">

  syntax</span> Exp ::=<span class="hljs-keyword"> Int</span> |<span class="hljs-keyword"> Bool</span> |<span class="hljs-keyword"> String</span> |<span class="hljs-keyword"> Id</span>
               | <span class="hljs-string">&quot;this&quot;</span>
               | <span class="hljs-string">&quot;super&quot;</span>
               | <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>             [<span class="hljs-literal">bracket</span>]
               | <span class="hljs-string">&quot;++&quot;</span> Exp
               | Exp <span class="hljs-string">&quot;instanceOf&quot;</span><span class="hljs-keyword"> Id</span>     [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]
               | <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;)&quot;</span> Exp          [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]
               | <span class="hljs-string">&quot;new&quot;</span><span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span>   [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>)]
               &gt; Exp <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span>        [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;-&quot;</span> Exp                 [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;sizeOf&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>    [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;)&quot;</span>
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;*&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;/&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;%&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;+&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;-&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-literal">non-assoc</span>:
                 Exp <span class="hljs-string">&quot;&lt;&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&lt;=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&gt;&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&gt;=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;==&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;!=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               &gt; <span class="hljs-string">&quot;!&quot;</span> Exp                 [<span class="hljs-literal">strict</span>]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;&amp;&amp;&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;||&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-string">&quot;spawn&quot;</span> Block  <span class="hljs-comment">// not strict: to check return and exceptions</span>
               &gt; Exp <span class="hljs-string">&quot;=&quot;</span> Exp             [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>), <span class="hljs-literal">right</span>]<span class="hljs-keyword">

  syntax</span> Exp ::= FieldReference | ArrayReference<span class="hljs-keyword">
  syntax</span> priority _.__KOOL-TYPED-STATIC-SYNTAX &gt; _[_]_KOOL-TYPED-STATIC-SYNTAX &gt; _(_)_KOOL-TYPED-STATIC-SYNTAX<span class="hljs-keyword">

  syntax</span> Exps ::= List{Exp,<span class="hljs-string">&quot;,&quot;</span>}          [<span class="hljs-literal">strict</span>]
</code></pre>
<h2>Statements</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Block ::= <span class="hljs-string">&quot;{&quot;</span> <span class="hljs-string">&quot;}&quot;</span>
                | <span class="hljs-string">&quot;{&quot;</span> Stmts <span class="hljs-string">&quot;}&quot;</span><span class="hljs-keyword">

  syntax</span> Stmt ::= Decl | Block
                | Exp <span class="hljs-string">&quot;;&quot;</span>                                 [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block <span class="hljs-string">&quot;else&quot;</span> Block     [<span class="hljs-literal">avoid</span>, <span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;while&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block               [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;for&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Stmts Exp <span class="hljs-string">&quot;;&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;return&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                        [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;return&quot;</span> <span class="hljs-string">&quot;;&quot;</span>
                | <span class="hljs-string">&quot;print&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-string">&quot;;&quot;</span>                [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;try&quot;</span> Block <span class="hljs-string">&quot;catch&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Param <span class="hljs-string">&quot;)&quot;</span> Block [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]
                | <span class="hljs-string">&quot;throw&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                         [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;join&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                          [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;acquire&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                       [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;release&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                       [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;rendezvous&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                    [<span class="hljs-literal">strict</span>]<span class="hljs-keyword">

  syntax</span> Stmts ::= Stmt
                 | Stmts Stmts                            [<span class="hljs-literal">seqstrict</span>, <span class="hljs-literal">right</span>]
</code></pre>
<h2>Desugaring macros</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> if (E) S =&gt; if (E) S else {}                                     [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> for(Start Cond; Step) {S:Stmts} =&gt; {Start while(Cond){S Step;}}  [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> T:Type E1:Exp, E2:Exp, Es:Exps; =&gt; T E1; T E2, Es;               [<span class="hljs-literal">macro</span>-rec]<span class="hljs-keyword">
  rule</span> T:Type X:<span class="hljs-keyword">Id</span> = E; =&gt; T X; X = E;                                  [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">

  rule</span> class C:<span class="hljs-keyword">Id</span> S =&gt; class C extends Object S<span class="hljs-keyword">

endmodule</span>
</code></pre>
<h2>Static semantics</h2>
<p>We first discuss the configuration, then give the static semantics
taken over unchanged from SIMPLE, then discuss the static semantics of
SIMPLE syntactic constructs that needs to change, and in the end we
discuss the static semantics and additional checks specifically
related to the KOOL proper syntax.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> KOOL-TYPED-STATIC<span class="hljs-keyword">
  imports</span> KOOL-TYPED-STATIC-SYNTAX<span class="hljs-keyword">
  imports</span> DOMAINS
</code></pre>
<h2>Configuration</h2>
<p>The configuration of our type system consists of a <code>tasks</code>
cell with the same meaning like in statically typed SIMPLE, of an
<code>out</code> cell streamed to the standard output that will be used to
display typing error messages, and of a cell <code>classes</code> holding
data about each class in a separate <code>class</code> cell.  The
<code>task</code> cells now have two additional optional subcells, namely
<code>ctenvT</code> and <code>inClass</code>.  The former holds a temporary
class type environment; its contents will be transferred into the
<code>ctenv</code> cell of the corresponding class as soon as all the
fields and methods in the task are processed.  In fact, there will be
three types of tasks in the subsequent semantics, each determined by
the subset of cells that it holds:</p>
<ol>
<li>
<p><strong>Main task</strong>, holding only a <code>k</code> cell holding the
original program as a set of classes.  The role of this task is to
process each class, generating a class task (see next) for each.</p>
</li>
<li>
<p><strong>Class task</strong>, holding <code>k</code>, <code>ctenvT</code>, and
<code>inClass</code> subcells.  The role of this task type is to process
a class&apos; contents, generating a class type environment in the
<code>ctenvT</code> cell and a method task (see next) for each method in
the class.  To avoid interference with object member lookup rules
below, it is important to add the class type environment to a class
atomically; this is the reason for which we use <code>ctenvT</code>
temporary cells within class tasks (instead of adding each member
incrementally to the class&apos; type environment).</p>
</li>
<li>
<p><strong>Method task</strong>, holding <code>k</code>, <code>tenv</code> and
<code>return</code> cells.  These tasks are similar to SIMPLE&apos;s function
tasks, so we do not discuss them here any further.</p>
</li>
</ol>
<p>Each <code>class</code> cell hods its name (in the <code>className</code>
cell) and the name of the class it extends (in the <code>extends</code>
cell), as well as its type environment (in the <code>ctenv</code> cell)
and the set of all its superclasses (in the <code>extendsAll</code> cell).
The later is useful for example for checking whether there are cycles
in the class extends relation.</p>
<pre class="hljs"><code><span class="hljs-keyword">  configuration</span> &lt;T multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;yellow&quot;</span>&gt;
                  &lt;tasks color=<span class="hljs-string">&quot;orange&quot;</span> multiplicity=<span class="hljs-string">&quot;?&quot;</span>&gt;
                    &lt;task multiplicity=<span class="hljs-string">&quot;*&quot;</span> color=<span class="hljs-string">&quot;yellow&quot;</span>&gt;
                      &lt;k color=<span class="hljs-string">&quot;green&quot;</span>&gt; $PGM:Stmts &lt;/k&gt;
                      &lt;tenv multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;cyan&quot;</span>&gt; .Map &lt;/tenv&gt;
                      &lt;ctenvT multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;blue&quot;</span>&gt; .Map &lt;/ctenvT&gt;
                      &lt;returnType multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;black&quot;</span>&gt; void &lt;/returnType&gt;
                      &lt;inClass multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; .K &lt;/inClass&gt;
                    &lt;/task&gt;
                  &lt;/tasks&gt;
<span class="hljs-comment">//                  &lt;br/&gt;</span>
                  &lt;classes color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt;
                    &lt;classData multiplicity=<span class="hljs-string">&quot;*&quot;</span>&gt;
                      &lt;className color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; Object &lt;/className&gt;
                      &lt;baseClass color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; .K &lt;/baseClass&gt;
                      &lt;baseClasses color=<span class="hljs-string">&quot;Fuchsia&quot;</span>&gt; .Set &lt;/baseClasses&gt;
                      &lt;ctenv multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;blue&quot;</span>&gt; .Map &lt;/ctenv&gt;
                    &lt;/classData&gt;
                  &lt;/classes&gt;
                &lt;/T&gt;
                &lt;output color=<span class="hljs-string">&quot;brown&quot;</span> stream=<span class="hljs-string">&quot;stdout&quot;</span>&gt; .List &lt;/output&gt;
</code></pre>
<h2>Unchanged semantics from statically typed SIMPLE</h2>
<p>The syntax and rules below are borrowed unchanged from statically
typed SIMPLE, so we do not discuss them much here.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= Type<span class="hljs-keyword">
  syntax</span> Exps ::= Types<span class="hljs-keyword">
  syntax</span> BlockOrStmtType ::= <span class="hljs-string">&quot;block&quot;</span> | <span class="hljs-string">&quot;stmt&quot;</span><span class="hljs-keyword">
  syntax</span> Type ::= BlockOrStmtType<span class="hljs-keyword">
  syntax</span> Block ::= BlockOrStmtType<span class="hljs-keyword">
  syntax</span> KResult ::= Type
                   | Types  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> should not be needed</span><span class="hljs-keyword">


  context</span> _:Type _::Exp[HOLE::Exps];<span class="hljs-keyword">

  rule</span> T:Type E:Exp[int,Ts:Types]; =&gt; T[] E[Ts];  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> T:Type E:Exp[.Types]; =&gt; T E;          [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">


  rule</span> &lt;task&gt;... &lt;k&gt; _:BlockOrStmtType &lt;/k&gt; &lt;tenv&gt; _ &lt;/tenv&gt; ...&lt;/task&gt; =&gt; .Bag<span class="hljs-keyword">


  rule</span> _:<span class="hljs-keyword">Int</span> =&gt; int<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">Bool</span> =&gt; bool<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">String</span> =&gt; string<span class="hljs-keyword">


  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; T ...&lt;/k&gt; &lt;tenv&gt;... X |-&gt; T ...&lt;/tenv&gt;<span class="hljs-keyword">


  context</span> ++(HOLE =&gt; ltype(HOLE))<span class="hljs-keyword">
  rule</span> ++ int =&gt; int<span class="hljs-keyword">
  rule</span> int + int =&gt; int<span class="hljs-keyword">
  rule</span> string + string =&gt; string<span class="hljs-keyword">
  rule</span> int - int =&gt; int<span class="hljs-keyword">
  rule</span> int * int =&gt; int<span class="hljs-keyword">
  rule</span> int / int =&gt; int<span class="hljs-keyword">
  rule</span> int % int =&gt; int<span class="hljs-keyword">
  rule</span> - int =&gt; int<span class="hljs-keyword">
  rule</span> int &lt; int =&gt; bool<span class="hljs-keyword">
  rule</span> int &lt;= int =&gt; bool<span class="hljs-keyword">
  rule</span> int &gt; int =&gt; bool<span class="hljs-keyword">
  rule</span> int &gt;= int =&gt; bool<span class="hljs-keyword">
  rule</span> T:Type == T =&gt; bool<span class="hljs-keyword">
  rule</span> T:Type != T =&gt; bool<span class="hljs-keyword">
  rule</span> bool &amp;&amp; bool =&gt; bool<span class="hljs-keyword">
  rule</span> bool || bool =&gt; bool<span class="hljs-keyword">
  rule</span> ! bool =&gt; bool<span class="hljs-keyword">


  rule</span> (T[])[int, Ts:Types] =&gt; T[Ts]<span class="hljs-keyword">
  rule</span> T:Type[.Types] =&gt; T<span class="hljs-keyword">

  rule</span> sizeOf(T[]) =&gt; int<span class="hljs-keyword">


  rule</span> read() =&gt; int<span class="hljs-keyword">

  rule</span> print(T:Type, Ts =&gt; Ts); when T ==K int orBool T ==K string<span class="hljs-keyword">
  rule</span> print(.Types); =&gt; stmt<span class="hljs-keyword">


  context</span> (HOLE =&gt; ltype(HOLE)) = _<span class="hljs-keyword">


  rule</span> &lt;k&gt; return; =&gt; stmt ...&lt;/k&gt; &lt;returnType&gt; _ &lt;/returnType&gt;<span class="hljs-keyword">


  rule</span> {} =&gt; block<span class="hljs-keyword">

  rule</span> &lt;task&gt; &lt;k&gt; {S:Stmts} =&gt; block ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt; &lt;k&gt; S &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;)<span class="hljs-keyword">

  rule</span> _:Type; =&gt; stmt<span class="hljs-keyword">
  rule</span> if (bool) block else block =&gt; stmt<span class="hljs-keyword">
  rule</span> while (bool) block =&gt; stmt<span class="hljs-keyword">

  rule</span> join int; =&gt; stmt<span class="hljs-keyword">
  rule</span> acquire _:Type; =&gt; stmt<span class="hljs-keyword">
  rule</span> release _:Type; =&gt; stmt<span class="hljs-keyword">
  rule</span> rendezvous _:Type; =&gt; stmt<span class="hljs-keyword">

  syntax</span> Stmt ::= BlockOrStmtType<span class="hljs-keyword">
  rule</span> _:BlockOrStmtType _:BlockOrStmtType =&gt; stmt
</code></pre>
<h2>Unchanged auxiliary operations from dynamically typed SIMPLE</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Stmts ::= mkDecls(Params)  [function]<span class="hljs-keyword">
  rule</span> mkDecls(T:Type X:<span class="hljs-keyword">Id</span>, Ps:Params) =&gt; T X; mkDecls(Ps)<span class="hljs-keyword">
  rule</span> mkDecls(.Params) =&gt; {}<span class="hljs-keyword">

  syntax</span> LValue ::=<span class="hljs-keyword"> Id</span>
                  | FieldReference
                  | ArrayReference<span class="hljs-keyword">
  syntax</span> Exp ::= LValue<span class="hljs-keyword">

  syntax</span> Exp ::= ltype(Exp)
<span class="hljs-comment">// We would like to say:</span>
<span class="hljs-comment">//  context ltype(HOLE:LValue)</span>
<span class="hljs-comment">// but we currently cannot type the HOLE</span><span class="hljs-keyword">
  context</span> ltype(HOLE) when isLValue(HOLE)

<span class="hljs-comment">// OLD approach:</span>
<span class="hljs-comment">//  syntax Exp ::= ltype(Exp)  [function]</span>
<span class="hljs-comment">//  rule ltype(X:Id) =&gt; X</span>
<span class="hljs-comment">//  rule ltype(E:Exp [Es:Exps]) =&gt; E[Es]</span><span class="hljs-keyword">

  syntax</span> Types ::= getTypes(Params)  [function]<span class="hljs-keyword">
  rule</span> getTypes(T:Type _:<span class="hljs-keyword">Id</span>) =&gt; T, .Types<span class="hljs-keyword">
  rule</span> getTypes(T:Type _:<span class="hljs-keyword">Id</span>, P, Ps) =&gt; T, getTypes(P,Ps)<span class="hljs-keyword">
  rule</span> getTypes(.Params) =&gt; void, .Types
</code></pre>
<h2>Changes to the existing statically typed SIMPLE semantics</h2>
<p>Below we give the new static semantics for language constructs that
come from SIMPLE, but whose SIMPLE static semantics was too
restrictive or too permissive and thus had to change.</p>
<h2>Local variable declaration</h2>
<p>Since we can define new types in KOOL (corresponding to classes), the
variable declaration needs to now check that the claimed types exist.
The operation <code>checkType</code>, defined at the end of this module,
checks whether the argument type is correct (it actually works with
lists of types as well).</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; T:Type X:<span class="hljs-keyword">Id</span>; =&gt; checkType(T) ~&gt; stmt ...&lt;/k&gt;
       &lt;tenv&gt; Rho =&gt; Rho[X &lt;- T] &lt;/tenv&gt;
</code></pre>
<h2>Class member declaration</h2>
<p>In class tasks, variable declarations mean class member declarations.
Since we reduce method declarations to variable declarations (see
below), a variable declaration in a class task can mean either a field
or a method declaration.  Unlike local variable declarations, which
can shadow previous homonymous local or member declarations, member
declarations are regarded as a set, so we disallow multiple
declarations for the same member (one could improve upon this, like in
Java, by treating members with different types or number of arguments
as different, etc., but we do not do it here).  We also issue an error
message if one attempts to redeclare the same class member.  The
framed variable declaration in the second rule below should be read
&quot;stuck&quot;.  In fact, it is nothing but a unary operation called
<code>stuck</code>, which takes a <strong>K</strong>-term as argument and does nothing
with it; this <code>stuck</code> operation is displayed as a frame in this
PDF document because of its latex attribute (see the ASCII .k file,
at the end of this module).</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; T:Type X:<span class="hljs-keyword">Id</span>; =&gt; checkType(T) ~&gt; stmt ...&lt;/k&gt;
       &lt;ctenvT&gt; Rho (.Map =&gt; X |-&gt; T) &lt;/ctenvT&gt;
    when notBool(X in keys(Rho))<span class="hljs-keyword">

  rule</span> &lt;k&gt; T:Type X:<span class="hljs-keyword">Id</span>; =&gt; stuck(T X;) ...&lt;/k&gt;
       &lt;ctenvT&gt;... X |-&gt; _ ...&lt;/ctenvT&gt;
       &lt;inClass&gt; C:<span class="hljs-keyword">Id</span> &lt;/inClass&gt;
<span class="hljs-comment">//       &lt;br/&gt;</span>
       &lt;output&gt;... .List =&gt; ListItem(<span class="hljs-string">&quot;Member \&quot;&quot;</span> +<span class="hljs-keyword">String</span> Id2String(X)
                              +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot; declared twice in class \&quot;&quot;</span>
                              +<span class="hljs-keyword">String</span> Id2String(C) +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot;!\n&quot;</span>) &lt;/output&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Method declaration</h2>
<p>A method declaration requires two conceptual checks to be performed:
first, that the method&apos;s type is consistent with the type of the
homonymous method that it overrides, if any; and second, that its body
types correctly.  At the same time, it should also be added to the
type environment of its class.  The first conceptual task is performed
using the <code>checkMethod</code> operation defined below, and the second
by generating a corresponding method task.  To add it to the class
type environment, we take advantage of the fact that KOOL is higher
order and reduce the problem to a field declaration problem, which we
have already defined.  The role of the <code>ctenvT</code> cell in the
rule below is to structurally ensure that the method declaration takes
place in a class task (we do not want to allow methods to be declared,
for example, inside other methods).</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; T:Type F:<span class="hljs-keyword">Id</span>(Ps:Params) S
        =&gt; checkMethod(F, getTypes(Ps)-&gt;T, C&apos;)
           ~&gt; getTypes(Ps)-&gt;T F; ...&lt;/k&gt;
<span class="hljs-comment">//       &lt;br/&gt;</span>
       &lt;inClass&gt; C &lt;/inClass&gt;
       &lt;ctenvT&gt; _ &lt;/ctenvT&gt; <span class="hljs-comment">// to ensure we are in a class pass</span>
       &lt;className&gt; C &lt;/className&gt;
       &lt;baseClass&gt; C&apos; &lt;/baseClass&gt;
<span class="hljs-comment">//       &lt;br/&gt;</span>
       (.Bag =&gt; &lt;task&gt;
               &lt;k&gt; mkDecls(Ps) S &lt;/k&gt;
               &lt;inClass&gt; C &lt;/inClass&gt;
               &lt;tenv&gt; .Map &lt;/tenv&gt;
               &lt;returnType&gt; T &lt;/returnType&gt;
             &lt;/task&gt;)
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Assignment</h2>
<p>A more concrete value is allowed to be assigned to a more abstract
variable.  The operation <code>checkSubtype</code> is defined at the end
of the module and it also works with pairs of lists of types.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> T:Type = T&apos;:Type =&gt; checkSubtype(T&apos;, T) ~&gt; T
</code></pre>
<h2>Method invocation and return</h2>
<p>Methods can be applied on values of more concrete types than their
arguments:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> (Ts:Types -&gt; T:Type) (Ts&apos;:Types) =&gt; checkSubtype(Ts&apos;,Ts) ~&gt; T
</code></pre>
<p>Similarly, we allow values of more concrete types to be returned by
methods:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; return T:Type; =&gt; checkSubtype(T,T&apos;) ~&gt; stmt ...&lt;/k&gt;
       &lt;returnType&gt; T&apos;:Type &lt;/returnType&gt;
</code></pre>
<h2>Exceptions</h2>
<p>Exceptions can throw and catch values of any types.  Since unlike in Java
KOOL&apos;s methods do not declare the exception types that they can throw,
we cannot test the full type safety of exceptions.  Instead, we
only check that the <code>try</code> and the <code>catch</code> statements
type correctly.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> try block catch(T:Type X:<span class="hljs-keyword">Id</span>) S =&gt; {T X; S}  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> throw T:Type ; =&gt; stmt
</code></pre>
<h2>Spawn</h2>
<p>The spawned cell needs to also be passed the parent&apos;s class.</p>
<pre class="hljs"><code><span class="hljs-comment">// explain why</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; spawn S:Block =&gt; int ...&lt;/k&gt;
       &lt;tenv&gt; Rho &lt;/tenv&gt;
       &lt;inClass&gt; C &lt;/inClass&gt;
       (.Bag =&gt; &lt;task&gt;
               &lt;k&gt; S &lt;/k&gt;
               &lt;tenv&gt; Rho &lt;/tenv&gt;
               &lt;inClass&gt; C &lt;/inClass&gt;
             &lt;/task&gt;)
</code></pre>
<h2>Semantics of the new KOOL constructs</h2>
<h2>Class declaration</h2>
<p>We process each class in the main task, adding the corresponding data
into its <code>class</code> cell and also adding a class task for it.  We
also perform some well-formedness checks on the class hierarchy.</p>
<p><strong>Initiate class processing</strong><br>
We create a class cell and a class task for each task.  Also, we start
the class task with a check that the class it extends is declared
(this delays the task until that class is processed using another
instance of this rule).</p>
<pre class="hljs"><code><span class="hljs-comment">// There seems to be some error with the configuration concretization,</span>
<span class="hljs-comment">// as the rule below does not work when rewriting . to both the task</span>
<span class="hljs-comment">// and the class cells; I had to include two separate . rewrites</span>

<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> the following fails krun; see #2117</span><span class="hljs-keyword">
  rule</span> &lt;task&gt; &lt;k&gt; class C:<span class="hljs-keyword">Id</span> extends C&apos;:<span class="hljs-keyword">Id</span> { S:Stmts } =&gt; stmt ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;classData&gt;...
               &lt;className&gt; C &lt;/className&gt;
               &lt;baseClass&gt; C&apos; &lt;/baseClass&gt;
             ...&lt;/classData&gt;)
<span class="hljs-comment">//       &lt;br/&gt;</span>
       (.Bag =&gt; &lt;task&gt;
                &lt;k&gt; checkType(class(C&apos;)) ~&gt; S &lt;/k&gt;
                &lt;inClass&gt; C &lt;/inClass&gt;
                &lt;ctenvT&gt; .Map &lt;/ctenvT&gt;
             &lt;/task&gt;)
    [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">// You may want to try the thing below, but that failed, too</span>
<span class="hljs-comment">/*
syntax Type ::= &quot;stmtStop&quot;

  rule &lt;tasks&gt;...
       &lt;task&gt; &lt;k&gt; class C:Id extends C&apos;:Id { S:Stmts } =&gt; stmtStop ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt;
                &lt;k&gt; checkType(class(C&apos;)) ~&gt; S &lt;/k&gt;
                &lt;inClass&gt; C &lt;/inClass&gt;
                &lt;ctenvT&gt; .Map &lt;/ctenvT&gt;
             &lt;/task&gt;)
       ...&lt;/tasks&gt;
       &lt;classes&gt;...
       .Bag =&gt; &lt;classData&gt;...
               &lt;className&gt; C &lt;/className&gt;
               &lt;baseClass&gt; C&apos; &lt;/baseClass&gt;
             ...&lt;/classData&gt;
       ...&lt;/classes&gt;
//       &lt;br/&gt;
  [structural]
*/</span>
</code></pre>
<h2>Check for unique class names</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> (&lt;T&gt;...
          &lt;className&gt; C &lt;/className&gt;
          &lt;className&gt; C &lt;/className&gt;
        ...&lt;/T&gt; =&gt; .Bag)
       &lt;output&gt;... .List =&gt; ListItem(<span class="hljs-string">&quot;Class \&quot;&quot;</span> +<span class="hljs-keyword">String</span> Id2String(C)
                                  +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot; declared twice!\n&quot;</span>) &lt;/output&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<p><strong>Check for cycles in class hierarchy</strong><br>
We check for cycles in the class hierarchy by transitively closing the
class extends relation using the <code>extendsAll</code> cells, and
checking that a class will never appear in its own <code>extendsAll</code>
cell.  The first rule below initiates the transitive closure of the
superclass relation, the second transitively closes it, and the third
checks for cycles.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;baseClass&gt; C &lt;/baseClass&gt;
       &lt;baseClasses&gt; .Set =&gt; SetItem(C) &lt;/baseClasses&gt;  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> &lt;classData&gt;...
         &lt;baseClasses&gt; SetItem(C) Cs:Set (.Set =&gt; SetItem(C&apos;)) &lt;/baseClasses&gt;
       ...&lt;/classData&gt;
       &lt;classData&gt;... &lt;className&gt;C&lt;/className&gt; &lt;baseClass&gt;C&apos;&lt;/baseClass&gt; ...&lt;/classData&gt;
    when notBool(C&apos; in (SetItem(C) Cs))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> (&lt;T&gt;...
          &lt;className&gt; C &lt;/className&gt;
          &lt;baseClasses&gt;... SetItem(C) ...&lt;/baseClasses&gt;
        ...&lt;/T&gt; =&gt; .Bag)
       &lt;output&gt;... .List =&gt; ListItem(<span class="hljs-string">&quot;Class \&quot;&quot;</span> +<span class="hljs-keyword">String</span> Id2String(C)
                                  +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot; is in a cycle!\n&quot;</span>) &lt;/output&gt;
    [inheritance-cycle]
</code></pre>
<h2>New</h2>
<p>To type <code>new</code> we only need to check that the class constructor
can be called with arguments of the given types, so we initiate a call
to the constructor method in the corresponding class.  If that
succeeds, meaning that it types to <code>stmt</code>, then we discard the
<code>stmt</code> type and produce instead the corresponding class type of
the new object.  The auxiliary <code>discard</code> operation is defined
also at the end of this module.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> new C:<span class="hljs-keyword">Id</span>(Ts:Types) =&gt; class(C) . C (Ts) ~&gt; discard ~&gt; class(C)
</code></pre>
<h2>Self reference</h2>
<p>The typing rule for <code>this</code> is straightforward: reduce to the
current class type.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; this =&gt; class(C) ...&lt;/k&gt;
       &lt;inClass&gt; C:<span class="hljs-keyword">Id</span> &lt;/inClass&gt;
</code></pre>
<h2>Super</h2>
<p>Similarly, <code>super</code> types to the parent class type.
Note that for typing concerns, super can be considered as an object
(recall that this was not the case in the dynamic semantics).</p>
<pre class="hljs"><code><span class="hljs-keyword">   rule</span> &lt;k&gt; super =&gt; class(C&apos;) ...&lt;/k&gt;
        &lt;inClass&gt; C:<span class="hljs-keyword">Id</span> &lt;/inClass&gt;
        &lt;className&gt; C &lt;/className&gt;
        &lt;baseClass&gt; C&apos;:<span class="hljs-keyword">Id</span> &lt;/baseClass&gt;
</code></pre>
<h2>Object member access</h2>
<p>There are several cases to consider here.  First, if we are in a class
task, we should lookup the member into the temporary class type
environemnt in cell <code>ctenvT</code>.  That is because we want to allow
initialized field declarations in classes, such as <code>int x=10;</code>.
This is desugared to a declaration of <code>x</code>, which is added to
<code>ctenvT</code> during the class task processing, followed by an
assignment of <code>x</code> to 10.  In order for the assignment to type
check, we need to know that <code>x</code> has been declared with type
<code>int</code>; this information can only be found in the
<code>ctenvT</code> cell.  Second, we should redirect non-local variable
lookups in method tasks to corresponding member accesses (the
local variables are handled by the rule borrowed from SIMPLE).
This is what the second rule below does.  Third, we should allow
object member accesses as lvalues, which is done by the third rule
below.  These last two rules therefore ensure that each necessary
object member access is explicitly allowed for evaluation.  Recall
from the annotated syntax module above that the member access
operation is strict in the object.  That means that the object is
expected to evaluate to a class type.  The next two rules below define
the actual member lookup operation, moving the search to the
superclass when the member is not found in the current class.  Note
that this works because we create the class type environments
atomically; thus, a class either has its complete type environment
available, in which case these rules can safely apply, or its cell
<code>ctenv</code> is not yet available, in which case these rules have to
wait.  Finally, the sixth rule below reports an error when the
<code>Object</code> class is reached.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; T ...&lt;/k&gt;
       &lt;ctenvT&gt;... X |-&gt; T ...&lt;/ctenvT&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; this . X ...&lt;/k&gt;
       &lt;tenv&gt; Rho &lt;/tenv&gt;
    when notBool(X in keys(Rho))

<span class="hljs-comment">// OLD approach:</span>
<span class="hljs-comment">//  rule ltype(E:Exp . X:Id) =&gt; E . X  [structural]</span><span class="hljs-keyword">

  rule</span> &lt;k&gt; class(C:<span class="hljs-keyword">Id</span>) . X:<span class="hljs-keyword">Id</span> =&gt; T ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;ctenv&gt;... X |-&gt; T:Type ...&lt;/ctenv&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; class(C1:<span class="hljs-keyword">Id</span> =&gt; C2) . X:<span class="hljs-keyword">Id</span> ...&lt;/k&gt;
       &lt;className&gt; C1 &lt;/className&gt;
       &lt;baseClass&gt; C2:<span class="hljs-keyword">Id</span> &lt;/baseClass&gt;
       &lt;ctenv&gt; Rho &lt;/ctenv&gt;
    when notBool(X in keys(Rho))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> &lt;k&gt; class(Object) . X:<span class="hljs-keyword">Id</span> =&gt; stuck(class(Object) . X) ...&lt;/k&gt;
       &lt;inClass&gt; C:<span class="hljs-keyword">Id</span> &lt;/inClass&gt;
<span class="hljs-comment">//      &lt;br/&gt;</span>
       &lt;output&gt;... .List =&gt; ListItem(<span class="hljs-string">&quot;Member \&quot;&quot;</span> +<span class="hljs-keyword">String</span> Id2String(X)
                              +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot; not declared! (see class \&quot;&quot;</span>
                              +<span class="hljs-keyword">String</span> Id2String(C) +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot;)\n&quot;</span>) &lt;/output&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Instance of and casting</h2>
<p>As it is hard to check statically whether casting is always safe,
the programmer is simply trusted from a typing perspective.  We only
do some basic upcasting and downcasting checks, to reject casts which
will absolutely fail.  However, dynamic semantics or implementations
of the language need to insert runtime checks for downcasting to be safe.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> class(C1:<span class="hljs-keyword">Id</span>) instanceOf C2:<span class="hljs-keyword">Id</span> =&gt; bool<span class="hljs-keyword">
  rule</span> (C:<span class="hljs-keyword">Id</span>) class(C) =&gt; class(C)<span class="hljs-keyword">
  rule</span> &lt;k&gt; (C2:<span class="hljs-keyword">Id</span>) class(C1:<span class="hljs-keyword">Id</span>) =&gt; class(C2) ...&lt;/k&gt;
       &lt;className&gt; C1 &lt;/className&gt;
       &lt;baseClasses&gt;...SetItem(C2)...&lt;/baseClasses&gt;    <span class="hljs-comment">// upcast</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; (C2:<span class="hljs-keyword">Id</span>) class(C1:<span class="hljs-keyword">Id</span>) =&gt; class(C2) ...&lt;/k&gt;
       &lt;className&gt; C2 &lt;/className&gt;
       &lt;baseClasses&gt;...SetItem(C1)...&lt;/baseClasses&gt;    <span class="hljs-comment">// downcast</span><span class="hljs-keyword">
  rule</span> &lt;k&gt; (C2) class(C1:<span class="hljs-keyword">Id</span>) =&gt; stuck((C2) class(C1)) ...&lt;/k&gt;
       &lt;classData&gt;...
         &lt;className&gt; C1 &lt;/className&gt;
         &lt;baseClasses&gt; S1 &lt;/baseClasses&gt;
       ...&lt;/classData&gt;
       &lt;classData&gt;...
         &lt;className&gt; C2 &lt;/className&gt;
         &lt;baseClasses&gt; S2 &lt;/baseClasses&gt;
       ...&lt;/classData&gt;
       &lt;output&gt;... .List =&gt; ListItem(<span class="hljs-string">&quot;Classes \&quot;&quot;</span> +<span class="hljs-keyword">String</span> Id2String(C1)
                              +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot; and \&quot;&quot;</span> +<span class="hljs-keyword">String</span> Id2String(C2)
                              +<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;\&quot; are incompatible!\n&quot;</span>) &lt;/output&gt;
    when notBool(C1 in S2) andBool notBool(C2 in S1)
    [transition]
    <span class="hljs-comment">// ugly solution to avoid non-confluence (rule may apply before</span>
    <span class="hljs-comment">// extendsAll is populated); strategies will solve the problem nicely.</span>
</code></pre>
<h2>Cleanup tasks</h2>
<p>Finally, we need to clean up the terminated tasks.  Each of the three
types of tasks is handled differently.  The main task is replaced by a
method task holding <code>new main();</code>, which will ensure that a
<code>main</code> class with a <code>main()</code> method actually exists
(first rule below).  A class task moves its temporary class type
environment into its class&apos; cell, and then it dissolves itself (second
rule).  A method task simply dissolves when terminated (third rule);
the presence of the <code>tenv</code> cell in that rule ensures that that
task is a method task.
Finally, when all the tasks are cleaned up, we can also remove the
<code>tasks</code> cell, issuing a corresponding message.  Note that
checking for cycles or duplicate methods can still be performed after
the <code>tasks</code> cell has been removed.</p>
<pre class="hljs"><code><span class="hljs-comment">// discard main task when done, issuing a &quot;new main();&quot; command to</span>
<span class="hljs-comment">// make sure that the class main and the method main() are declared.</span><span class="hljs-keyword">

  rule</span> &lt;task&gt; &lt;k&gt; stmt =&gt; new Main(.Exps); &lt;/k&gt;
              (.Bag =&gt; &lt;tenv&gt; .Map &lt;/tenv&gt;
                    &lt;returnType&gt; void &lt;/returnType&gt;
                    &lt;inClass&gt; Main &lt;/inClass&gt;)
       &lt;/task&gt;
    [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">// discard class task when done, adding a ctenv in class</span><span class="hljs-keyword">

  rule</span> (&lt;task&gt;
          &lt;k&gt; stmt &lt;/k&gt;
          &lt;ctenvT&gt; Rho &lt;/ctenvT&gt;
          &lt;inClass&gt; C:<span class="hljs-keyword">Id</span> &lt;/inClass&gt;
        &lt;/task&gt; =&gt; .Bag)
        &lt;className&gt; C &lt;/className&gt;
        (.Bag =&gt; &lt;ctenv&gt; Rho &lt;/ctenv&gt;)
    [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">// discard method task when done</span><span class="hljs-keyword">

  rule</span> &lt;task&gt;...
         &lt;k&gt; stmt &lt;/k&gt;
         &lt;tenv&gt; _ &lt;/tenv&gt;  <span class="hljs-comment">// only to ensure that this is a method task</span>
       ...&lt;/task&gt; =&gt; .Bag
    [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">// cleanup tasks and output a success message when done</span><span class="hljs-keyword">

  rule</span> (&lt;T&gt;... &lt;tasks&gt; .Bag &lt;/tasks&gt; ...&lt;/T&gt; =&gt; .Bag)
       &lt;output&gt;... .List =&gt; ListItem(<span class="hljs-string">&quot;Type checked!\n&quot;</span>) &lt;/output&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>KOOL-specific auxiliary declarations and operations</h2>
<h2>Subtype checking</h2>
<p>The subclass relation introduces a subtyping relation.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= checkSubtype(Types,Types)<span class="hljs-keyword">

  rule</span> checkSubtype(T:Type, T) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> &lt;k&gt; checkSubtype(class(C:<span class="hljs-keyword">Id</span>), class(C&apos;:<span class="hljs-keyword">Id</span>)) =&gt; . ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;baseClasses&gt;... SetItem(C&apos;) ...&lt;/baseClasses&gt;  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> checkSubtype(Ts1-&gt;T2,Ts1&apos;-&gt;T2&apos;)
    =&gt; checkSubtype(((T2)::Type,Ts1&apos;),((T2&apos;)::Type,Ts1))  [<span class="hljs-literal">structural</span>]

<span class="hljs-comment">// note that the following rule would be wrong!</span>
<span class="hljs-comment">//  rule checkSubtype(T[],T&apos;[]) =&gt; checkSubtype(T,T&apos;)</span><span class="hljs-keyword">

  rule</span> checkSubtype((T:Type,Ts),(T&apos;:Type,Ts&apos;))
    =&gt; checkSubtype(T,T&apos;) ~&gt; checkSubtype(Ts,Ts&apos;)
    when Ts =/=K .Types  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> checkSubtype(.Types,.Types) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkSubtype(.Types,void) =&gt; .  [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Checking well-formedness of types</h2>
<p>Since now any <em><code>Id</code></em> can be used as the type of a class, we need to
check that the types used in the program actually exists</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= checkType(Types)<span class="hljs-keyword">

  rule</span> checkType(T:Type,Ts:Types) =&gt; checkType(T) ~&gt; checkType(Ts)
    when Ts =/=K .Types  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(.Types) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(int) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(bool) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(string) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(void) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> &lt;k&gt; checkType(class(C:<span class="hljs-keyword">Id</span>)) =&gt; . ...&lt;/k&gt; &lt;className&gt; C &lt;/className&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(class(Object)) =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(Ts:Types -&gt; T:Type) =&gt; checkType(T,Ts)  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> checkType(T:Type[]) =&gt; checkType(T)  [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Checking correct  overiding of methods</h2>
<p>The <code>checkMethod</code> operation below searches to see whether
the current method overrides some other method in some superclass.
If yes, then it issues an additional check that the new method&apos;s type
is more concrete than the overridden method&apos;s.  The types <code>T</code> and <code>T&apos;</code>
below can only be function types.  See the definition of
<code>checkSubtype</code> on function types at the end of this module (it
is co-variant in the codomain and contra-variant in the domain).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= checkMethod(<span class="hljs-keyword">Id</span>,Type,<span class="hljs-keyword">Id</span>)<span class="hljs-keyword">

  rule</span> &lt;k&gt; checkMethod(F:<span class="hljs-keyword">Id</span>, T:Type, C:<span class="hljs-keyword">Id</span>) =&gt; checkSubtype(T, T&apos;) ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;ctenv&gt;... F |-&gt; T&apos;:Type ...&lt;/ctenv&gt;
    [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> &lt;k&gt; checkMethod(F:<span class="hljs-keyword">Id</span>, T:Type, (C:<span class="hljs-keyword">Id</span> =&gt; C&apos;)) ...&lt;/k&gt;
       &lt;className&gt; C &lt;/className&gt;
       &lt;baseClass&gt; C&apos;:<span class="hljs-keyword">Id</span> &lt;/baseClass&gt;
       &lt;ctenv&gt; Rho &lt;/ctenv&gt;
    when notBool(F in keys(Rho))  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

  rule</span> checkMethod(_:<span class="hljs-keyword">Id</span>,_,Object) =&gt; .
</code></pre>
<h2>Generic operations which could be part of the <strong>K</strong> framework</h2>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= stuck(K)  [<span class="hljs-literal">latex</span>(\framebox{${#<span class="hljs-number">1</span>}$})]<span class="hljs-keyword">

  syntax</span> KItem ::= <span class="hljs-string">&quot;discard&quot;</span><span class="hljs-keyword">
  rule</span> _:KResult ~&gt; discard =&gt; .  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">

endmodule</span>
</code></pre>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
