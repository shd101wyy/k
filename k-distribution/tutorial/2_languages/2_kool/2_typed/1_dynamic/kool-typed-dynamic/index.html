<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../projects/">Projects</a>
      <a class="bd-toc-link" href="../../../../../../../news/">News</a>
      <a class="bd-toc-link" href="../../../../../../../events/">Events</a>
      <a class="bd-toc-link" href="../../../../../../../funding/">Funding</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <h1>KOOL — Typed — Dynamic</h1>
<p>Author: Grigore Roșu (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin Șerbănuță (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2>Abstract</h2>
<p>This is the <strong>K</strong> dynamic semantics of the typed KOOL language.  It is
very similar to the semantics of the untyped KOOL, the difference
being that we now check the typing policy dynamically.  Since we have
to now declare the types of variables and methods, we adopt a syntax
for those which is close to Java.  Like in the semantics of
untyped KOOL, where we borrowed almost all the semantics of untyped
SIMPLE, we are going to also borrow much of the semantics of
dynamically typed SIMPLE here.  We will highlight the differences
between the dynamically typed and the untyped KOOL as we proceed with
the semantics.  In general, the type policy of the typed KOOL language
is similar to that of Java.  You may find it useful to also read
the discussion in the preamble of the static semantics of typed KOOL
before proceeding.</p>
<pre><code class="language-k">module KOOL-TYPED-DYNAMIC-SYNTAX
  imports DOMAINS-SYNTAX
</code></pre>
<h2>Syntax</h2>
<p>Like for the untyped KOOL language, the syntax of typed KOOL extends
that of typed SIMPLE with object-oriented constructs.
The syntax below was produced by copying and modifying/extending the
syntax of dynamically typed SIMPLE.  In fact, the only change we made
to the existing syntax of dynamically typed SIMPLE was to change the
strictness of the application construct like in untyped KOOL, from
<code>strict</code> to <code>strict(2)</code> (because application is not
strict in the first argument anymore due to dynamic method dispatch).
The KOOL-specific syntactic extensions are identical to those in
untyped KOOL.</p>
<pre><code class="language-k">  syntax Id ::= &quot;Object&quot; [token] | &quot;Main&quot; [token]
</code></pre>
<h2>Types</h2>
<pre><code class="language-k">  syntax Type ::= &quot;void&quot; | &quot;int&quot; | &quot;bool&quot; | &quot;string&quot;
                | Id                              // KOOL class
                | Type &quot;[&quot; &quot;]&quot;
                &gt; Types &quot;-&gt;&quot; Type
                | &quot;(&quot; Type &quot;)&quot;           [bracket]
  // TODO(KORE): drop klabel once issues #1913 are fixed
  syntax Types ::= List{Type,&quot;,&quot;}   [klabel(_,_::Types)]
  /*
  syntax Types ::= List{Type,&quot;,&quot;}
  */
</code></pre>
<h2>Declarations</h2>
<pre><code class="language-k">  syntax Param ::= Type Id
  syntax Params ::= List{Param,&quot;,&quot;}

  syntax Decl ::= Type Exps &quot;;&quot; [avoid]
                | Type Id &quot;(&quot; Params &quot;)&quot; Block    // stays like in typed SIMPLE
                | &quot;class&quot; Id Block                // KOOL
                | &quot;class&quot; Id &quot;extends&quot; Id Block   // KOOL
</code></pre>
<h2>Expressions</h2>
<pre><code class="language-k">  syntax Exp ::= Int | Bool | String | Id
               | &quot;this&quot;                                 // KOOL
               | &quot;super&quot;                                // KOOL
               | &quot;(&quot; Exp &quot;)&quot;             [bracket]
               | &quot;++&quot; Exp
               | Exp &quot;instanceOf&quot; Id     [strict(1)]    // KOOL
               | &quot;(&quot; Id &quot;)&quot; Exp          [strict(2)]    // KOOL  cast
               | &quot;new&quot; Id &quot;(&quot; Exps &quot;)&quot;   [strict(2)]    // KOOL
               | Exp &quot;.&quot; Id                             // KOOL
               &gt; Exp &quot;[&quot; Exps &quot;]&quot;        [strict]
               &gt; Exp &quot;(&quot; Exps &quot;)&quot;        [strict(2)]    // was strict in SIMPLE
               | &quot;-&quot; Exp                 [strict]
               | &quot;sizeOf&quot; &quot;(&quot; Exp &quot;)&quot;    [strict]
               | &quot;read&quot; &quot;(&quot; &quot;)&quot;
               &gt; left:
                 Exp &quot;*&quot; Exp             [strict, left]
               | Exp &quot;/&quot; Exp             [strict, left]
               | Exp &quot;%&quot; Exp             [strict, left]
               &gt; left:
                 Exp &quot;+&quot; Exp             [strict, left]
               | Exp &quot;-&quot; Exp             [strict, left]
               &gt; non-assoc:
                 Exp &quot;&lt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&lt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;&gt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&gt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;==&quot; Exp            [strict, non-assoc]
               | Exp &quot;!=&quot; Exp            [strict, non-assoc]
               &gt; &quot;!&quot; Exp                 [strict]
               &gt; left:
                 Exp &quot;&amp;&amp;&quot; Exp            [strict(1), left]
               | Exp &quot;||&quot; Exp            [strict(1), left]
               &gt; &quot;spawn&quot; Block
               &gt; Exp &quot;=&quot; Exp             [strict(2), right]

  syntax Exps ::= List{Exp,&quot;,&quot;}          [strict, klabel(exps)]
  syntax Val
  syntax Vals ::= List{Val,&quot;,&quot;}          [klabel(exps)]
</code></pre>
<h2>Statements</h2>
<pre><code class="language-k">  syntax Block ::= &quot;{&quot; &quot;}&quot;
                | &quot;{&quot; Stmts &quot;}&quot;

  syntax Stmt ::= Decl | Block
                | Exp &quot;;&quot;                               [strict]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block &quot;else&quot; Block   [avoid, strict(1)]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block
                | &quot;while&quot; &quot;(&quot; Exp &quot;)&quot; Block
                | &quot;for&quot; &quot;(&quot; Stmts Exp &quot;;&quot; Exp &quot;)&quot; Block
                | &quot;print&quot; &quot;(&quot; Exps &quot;)&quot; &quot;;&quot;              [strict]
                | &quot;return&quot; Exp &quot;;&quot;                      [strict]
                | &quot;return&quot; &quot;;&quot;
                | &quot;try&quot; Block &quot;catch&quot; &quot;(&quot; Param &quot;)&quot; Block
                | &quot;throw&quot; Exp &quot;;&quot;                       [strict]
                | &quot;join&quot; Exp &quot;;&quot;                        [strict]
                | &quot;acquire&quot; Exp &quot;;&quot;                     [strict]
                | &quot;release&quot; Exp &quot;;&quot;                     [strict]
                | &quot;rendezvous&quot; Exp &quot;;&quot;                  [strict]

  syntax Stmts ::= Stmt
                 | Stmts Stmts                          [right]
</code></pre>
<h2>Desugaring macros</h2>
<pre><code class="language-k">  rule if (E) S =&gt; if (E) S else {}                                     [macro]
  rule for(Start Cond; Step) {S::Stmts} =&gt; {Start while(Cond){S Step;}} [macro]
  rule T::Type E1::Exp, E2::Exp, Es::Exps; =&gt; T E1; T E2, Es;           [macro-rec]
  rule T::Type X::Id = E; =&gt; T X; X = E;                                [macro]

  rule class C:Id S =&gt; class C extends Object S                     // KOOL

endmodule
</code></pre>
<h2>Semantics</h2>
<p>We first discuss the new configuration, then we include the semantics of
the constructs borrowed from SIMPLE which stay unchanged, then those
whose semantics had to change, and finally the semantics of the
KOOL-specific constructs.</p>
<pre><code class="language-k">module KOOL-TYPED-DYNAMIC
  imports KOOL-TYPED-DYNAMIC-SYNTAX
  imports DOMAINS
</code></pre>
<h2>Configuration</h2>
<p>The configuration of dynamically typed KOOL is almost identical to
that of its untyped variant.  The only difference is the cell
<code>return</code>, inside the <code>control</code> cell, whose role is to
hold the expected return type of the invoked method.  That is because
we want to dynamically check that the value that a method returns has
the expected type.</p>
<pre><code class="language-k">  // the syntax declarations below are required because the sorts are
  // referenced directly by a production and, because of the way KIL to KORE
  // is implemented, the configuration syntax is not available yet
  // should simply work once KIL is removed completely
  // check other definitions for this hack as well
  syntax EnvCell
  syntax ControlCellFragment
  syntax EnvStackCell
  syntax CrntObjCellFragment

  configuration &lt;T color=&quot;red&quot;&gt;
                  &lt;threads color=&quot;orange&quot;&gt;
                    &lt;thread multiplicity=&quot;*&quot; type=&quot;Set&quot; color=&quot;yellow&quot;&gt;
                      &lt;k color=&quot;green&quot;&gt; ($PGM:Stmts ~&gt; execute) &lt;/k&gt;
                    //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                      &lt;control color=&quot;cyan&quot;&gt;
                        &lt;fstack color=&quot;blue&quot;&gt; .List &lt;/fstack&gt;
                        &lt;xstack color=&quot;purple&quot;&gt; .List &lt;/xstack&gt;
                        &lt;returnType color=&quot;LimeGreen&quot;&gt; void &lt;/returnType&gt;  // KOOL
                      //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                        &lt;crntObj color=&quot;Fuchsia&quot;&gt;  // KOOL
                           &lt;crntClass&gt; Object &lt;/crntClass&gt;
                           &lt;envStack&gt; .List &lt;/envStack&gt;
                           &lt;location multiplicity=&quot;?&quot;&gt; .K &lt;/location&gt;
                        &lt;/crntObj&gt;
                      &lt;/control&gt;
                    //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                      &lt;env color=&quot;violet&quot;&gt; .Map &lt;/env&gt;
                      &lt;holds color=&quot;black&quot;&gt; .Map &lt;/holds&gt;
                      &lt;id color=&quot;pink&quot;&gt; 0 &lt;/id&gt;
                    &lt;/thread&gt;
                  &lt;/threads&gt;
                //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                  &lt;store color=&quot;white&quot;&gt; .Map &lt;/store&gt;
                  &lt;busy color=&quot;cyan&quot;&gt;.Set &lt;/busy&gt;
                  &lt;terminated color=&quot;red&quot;&gt; .Set &lt;/terminated&gt;
                  &lt;input color=&quot;magenta&quot; stream=&quot;stdin&quot;&gt; .List &lt;/input&gt;
                  &lt;output color=&quot;brown&quot; stream=&quot;stdout&quot;&gt; .List &lt;/output&gt;
                  &lt;nextLoc color=&quot;gray&quot;&gt; 0 &lt;/nextLoc&gt;
                //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                  &lt;classes color=&quot;Fuchsia&quot;&gt;        // KOOL
                     &lt;classData multiplicity=&quot;*&quot; type=&quot;Map&quot; color=&quot;Fuchsia&quot;&gt;
                        &lt;className color=&quot;Fuchsia&quot;&gt; Main &lt;/className&gt;
                        &lt;baseClass color=&quot;Fuchsia&quot;&gt; Object &lt;/baseClass&gt;
                        &lt;declarations color=&quot;Fuchsia&quot;&gt; .K &lt;/declarations&gt;
                     &lt;/classData&gt;
                  &lt;/classes&gt;
                &lt;/T&gt;
</code></pre>
<h2>Unchanged semantics from dynamically typed SIMPLE</h2>
<p>The semantics below is taken over from dynamically typed SIMPLE
unchanged.  Like for untyped KOOL, the semantics of function/method
declaration and invocation, and of program initialization needs to
change.  Moreover, due to subtyping, the semantics of several imported
SIMPLE constructs can be made more general, such as that of the
return statement, that of the assignment, and that of the exceptions.
We removed all these from the imported semantics of SIMPLE below and
gave their modified semantics right after, together with the extended
semantics of thread spawning (which is identical to that of untyped
KOOL).</p>
<pre><code class="language-k">  syntax Val ::= Int | Bool | String
               | array(Type,Int,Int)
  syntax Exp ::= Val
  syntax Exps ::= Vals
  syntax KResult ::= Val
  syntax KResult ::= Vals


  syntax KItem ::= undefined(Type)  [latex(\bot_{#1})]

  rule &lt;k&gt; T:Type X:Id; =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; Env[X &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; undefined(T) ...&lt;/store&gt;
       &lt;nextLoc&gt; L:Int =&gt; L +Int 1 &lt;/nextLoc&gt;


  rule &lt;k&gt; T:Type X:Id[N:Int]; =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; Env[X &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; array(T, L +Int 1, N)
                          (L +Int 1)...(L +Int N) |-&gt; undefined(T) ...&lt;/store&gt;
       &lt;nextLoc&gt; L:Int =&gt; L +Int 1 +Int N &lt;/nextLoc&gt;
    requires N &gt;=Int 0

  context _:Type _::Exp[HOLE::Exps];


  syntax Id ::= &quot;$1&quot; | &quot;$2&quot;
  rule T:Type X:Id[N1:Int, N2:Int, Vs:Vals];
    =&gt; T[]&lt;Vs&gt; X[N1];
       {
         T[][]&lt;Vs&gt; $1=X;
         for(int $2=0; $2 &lt;= N1 - 1; ++$2) {
           T X[N2,Vs];
           $1[$2] = X;
         }
       }
    [structural]


  rule &lt;k&gt; X:Id =&gt; V ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]


  context ++(HOLE =&gt; lvalue(HOLE))
  rule &lt;k&gt; ++loc(L) =&gt; I +Int 1 ...&lt;/k&gt;
       &lt;store&gt;... L |-&gt; (I:Int =&gt; I +Int 1) ...&lt;/store&gt;  [increment]


  rule I1 + I2 =&gt; I1 +Int I2
  rule Str1 + Str2 =&gt; Str1 +String Str2
  rule I1 - I2 =&gt; I1 -Int I2
  rule I1 * I2 =&gt; I1 *Int I2
  rule I1 / I2 =&gt; I1 /Int I2 requires I2 =/=K 0
  rule I1 % I2 =&gt; I1 %Int I2 requires I2 =/=K 0
  rule - I =&gt; 0 -Int I
  rule I1 &lt; I2 =&gt; I1 &lt;Int I2
  rule I1 &lt;= I2 =&gt; I1 &lt;=Int I2
  rule I1 &gt; I2 =&gt; I1 &gt;Int I2
  rule I1 &gt;= I2 =&gt; I1 &gt;=Int I2
  rule V1:Val == V2:Val =&gt; V1 ==K V2
  rule V1:Val != V2:Val =&gt; V1 =/=K V2
  rule ! T =&gt; notBool(T)
  rule true  &amp;&amp; E =&gt; E
  rule false &amp;&amp; _ =&gt; false
  rule true  || _ =&gt; true
  rule false || E =&gt; E


  rule V:Val[N1:Int, N2:Int, Vs:Vals] =&gt; V[N1][N2, Vs]
    [structural, anywhere]

  rule array(_:Type, L:Int, M:Int)[N:Int] =&gt; lookup(L +Int N)
    requires N &gt;=Int 0 andBool N &lt;Int M  [structural, anywhere]

  rule sizeOf(array(_,_,N)) =&gt; N


  syntax Val ::= nothing(Type)
  rule &lt;k&gt; return; =&gt; return nothing(T); ...&lt;/k&gt; &lt;returnType&gt; T &lt;/returnType&gt;
    [structural]


  rule &lt;k&gt; read() =&gt; I ...&lt;/k&gt; &lt;input&gt; ListItem(I:Int) =&gt; .List ...&lt;/input&gt;  [read]


  context (HOLE =&gt; lvalue(HOLE)) = _


  rule {} =&gt; .  [structural]
  rule &lt;k&gt; { S } =&gt; S ~&gt; setEnv(Env) ...&lt;/k&gt;  &lt;env&gt; Env &lt;/env&gt;  [structural]


  rule S1:Stmts S2:Stmts =&gt; S1 ~&gt; S2  [structural]


  rule _:Val; =&gt; .


  rule if ( true) S else _ =&gt; S
  rule if (false) _ else S =&gt; S


  rule while (E) S =&gt; if (E) {S while(E)S}  [structural]


  rule &lt;k&gt; print(V:Val, Es =&gt; Es); ...&lt;/k&gt; &lt;output&gt;... .List =&gt; ListItem(V) &lt;/output&gt;
    requires typeOf(V) ==K int orBool typeOf(V) ==K string  [print]
  rule print(.Vals); =&gt; .  [structural]


  rule (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .Bag)
       &lt;busy&gt; Busy =&gt; Busy -Set keys(H) &lt;/busy&gt;
       &lt;terminated&gt;... .Set =&gt; SetItem(T) ...&lt;/terminated&gt;

  rule &lt;k&gt; join T:Int; =&gt; . ...&lt;/k&gt;
       &lt;terminated&gt;... SetItem(T) ...&lt;/terminated&gt;

  rule &lt;k&gt; acquire V:Val; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... .Map =&gt; V |-&gt; 0 ...&lt;/holds&gt;
       &lt;busy&gt; Busy (.Set =&gt; SetItem(V)) &lt;/busy&gt;
    requires (notBool(V in Busy:Set))  [acquire]

  rule &lt;k&gt; acquire V; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... V:Val |-&gt; (N:Int =&gt; N +Int 1) ...&lt;/holds&gt;

  rule &lt;k&gt; release V:Val; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... V |-&gt; (N =&gt; N:Int -Int 1) ...&lt;/holds&gt;
    requires N &gt;Int 0

  rule &lt;k&gt; release V; =&gt; . ...&lt;/k&gt; &lt;holds&gt;... V:Val |-&gt; 0 =&gt; .Map ...&lt;/holds&gt;
       &lt;busy&gt;... SetItem(V) =&gt; .Set ...&lt;/busy&gt;

  rule &lt;k&gt; rendezvous V:Val; =&gt; . ...&lt;/k&gt;
       &lt;k&gt; rendezvous V; =&gt; . ...&lt;/k&gt;  [rendezvous]
</code></pre>
<h2>Unchanged auxiliary operations from dynamically typed SIMPLE</h2>
<pre><code class="language-k">  syntax Stmts ::= mkDecls(Params,Vals)  [function]
  rule mkDecls((T:Type X:Id, Ps:Params), (V:Val, Vs:Vals))
    =&gt; T X=V; mkDecls(Ps,Vs)
  rule mkDecls(.Params,.Vals) =&gt; {}

  syntax Exp ::= lookup(Int)
  rule &lt;k&gt; lookup(L) =&gt; V ...&lt;/k&gt; &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]

  syntax KItem ::= setEnv(Map)
  rule &lt;k&gt; setEnv(Env) =&gt; . ...&lt;/k&gt;  &lt;env&gt; _ =&gt; Env &lt;/env&gt;  [structural]
  rule (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [structural]

  syntax Exp ::= lvalue(K)
  syntax Val ::= loc(Int)
  rule &lt;k&gt; lvalue(X:Id =&gt; loc(L)) ...&lt;/k&gt;  &lt;env&gt;... X |-&gt; L:Int ...&lt;/env&gt;
    [structural]

  context lvalue(_::Exp[HOLE::Exps])
  context lvalue(HOLE::Exp[_::Exps])

  rule lvalue(lookup(L:Int) =&gt; loc(L))  [structural]

  syntax Type ::= Type &quot;&lt;&quot; Vals &quot;&gt;&quot;  [function]
  rule T:Type&lt;_,Vs:Vals&gt; =&gt; T[]&lt;Vs&gt;
  rule T:Type&lt;.Vals&gt; =&gt; T

  syntax Map ::= Int &quot;...&quot; Int &quot;|-&gt;&quot; K
    [function, latex({#1}\ldots{#2}\mapsto{#3})]
  rule N...M |-&gt; _ =&gt; .Map  requires N &gt;Int M
  rule N...M |-&gt; K =&gt; N |-&gt; K (N +Int 1)...M |-&gt; K  requires N &lt;=Int M

  syntax Type ::= typeOf(K)  [function]
  rule typeOf(_:Int) =&gt; int
  rule typeOf(_:Bool) =&gt; bool
  rule typeOf(_:String) =&gt; string
  rule typeOf(array(T,_,_)) =&gt; (T[])
  rule typeOf(undefined(T)) =&gt; T
  rule typeOf(nothing(T)) =&gt; T

  syntax Types ::= getTypes(Params)  [function]
  rule getTypes(T:Type _:Id) =&gt; T, .Types
  rule getTypes(T:Type _:Id, P, Ps) =&gt; T, getTypes(P,Ps)
  rule getTypes(.Params) =&gt; void, .Types
</code></pre>
<h2>Changes to the existing dynamically typed SIMPLE semantics</h2>
<p>We extend/change the semantics of several SIMPLE constructs in order
to take advantage of the richer KOOL semantic infrastructure and thus
get more from the existing SIMPLE constructs.</p>
<h2>Program initialization</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  syntax KItem ::= &quot;execute&quot;
  rule &lt;k&gt; execute =&gt; new Main(.Exps); &lt;/k&gt; &lt;env&gt; .Map &lt;/env&gt;  [structural]
</code></pre>
<h2>Method application</h2>
<p>The only change to untyped KOOL's values is that method closures are
now typed (their first argument holds their type):</p>
<pre><code class="language-k"> syntax Val ::= objectClosure(Id,List)
              | methodClosure(Type,Id,Int,Params,Stmt)
</code></pre>
<p>The type held by a method clossure will be the entire type of the
method, not only its result type like the lambda-closure of typed
SIMPLE.  The reason for this change comes from the the need to
dynamically upcast values when passed to contexts where values of
superclass types are expected; since we want method closures to be
first-class-citizen values in our language, we have to be able to
dynamically upcast them, and in order to do that elegantly it is
convenient to store the entire ``current type'' of the method closure
instead of just its result type.  Note that this was unnecessary in
the semantics of the dynamically typed SIMPLE language.</p>
<p>Method closure application needs to also set a new return type in
the <code>return</code> cell, like in dynamically typed SIMPLE, in order
for the values returned by its body to be checked against the return
type of the method.  To do this correctly, we also need to stack the
current status of the <code>return</code> cell and then pop it when the
method returns.  We have to do the same with the current object
environment, so we group them together in the stack frame.</p>
<pre><code class="language-k">  syntax KItem ::= fstackFrame(Map, K, List, Type, K)

  rule &lt;k&gt; methodClosure(_-&gt;T,Class,OL,Ps,S)(Vs:Vals) ~&gt; K
           =&gt; mkDecls(Ps,Vs) S return; &lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;store&gt;... OL |-&gt; objectClosure(_, EStack)...&lt;/store&gt;
     //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
       &lt;control&gt;
          &lt;fstack&gt; .List =&gt; ListItem(fstackFrame(Env, K, XS, T', &lt;crntObj&gt; Obj' &lt;/crntObj&gt;)) ...&lt;/fstack&gt;
          &lt;xstack&gt; XS &lt;/xstack&gt;
          &lt;returnType&gt; T' =&gt; T &lt;/returnType&gt;
          &lt;crntObj&gt; Obj' =&gt; &lt;crntClass&gt; Class &lt;/crntClass&gt; &lt;envStack&gt; EStack &lt;/envStack&gt; &lt;/crntObj&gt;
       &lt;/control&gt;
</code></pre>
<p>At method return, we have to check that the type of the returned
value is a subtype of the expected return type.  Moreover, if that is
the case, then we also upcast the returned value to one of the
expected type.  The computation item <code>unsafeCast(V,T)</code> changes
the typeof <code>V</code> to <code>T</code> without any additional checks; however, it only
does it when <code>V</code> is an object or a method, otherwise it returns <code>V</code>
unchanged.</p>
<pre><code class="language-k">  rule &lt;k&gt; return V:Val; ~&gt; _
           =&gt; subtype(typeOf(V), T) ~&gt; true? ~&gt; unsafeCast(V, T) ~&gt; K
       &lt;/k&gt;
       &lt;control&gt;
         &lt;fstack&gt; ListItem(fstackFrame(Env, K, XS, RT, &lt;crntObj&gt; CO &lt;/crntObj&gt;)) =&gt; .List ...&lt;/fstack&gt;
         &lt;xstack&gt; _ =&gt; XS &lt;/xstack&gt;
         &lt;returnType&gt; T:Type =&gt; RT &lt;/returnType&gt;
         &lt;crntObj&gt; _ =&gt; CO &lt;/crntObj&gt;
       &lt;/control&gt;
       &lt;env&gt; _ =&gt; Env &lt;/env&gt;
</code></pre>
<h2>Assignment</h2>
<p>Typed KOOL allows to assign subtype instance values to supertype
lvalues.  The semantics of assignment below is similar in spirit to
dynamically typed SIMPLE's, but a check is performed that the assigned
value's type is a subtype of the location's type.  If that is the
case, then the assigned value is returned as a result and stored, but
it is upcast appropriately first, so the context will continue to see
a value of the expected type of the location.  Note that the type of a
location is implicit in the type of its contents and it never changes
during the execution of a program; its type is assigned when the
location is allocated and initialized, and then only type-preserving
values are allowed to be stored in each location.</p>
<pre><code class="language-k">  rule &lt;k&gt; loc(L) = V:Val
           =&gt; subtype(typeOf(V),typeOf(V')) ~&gt; true?
              ~&gt; unsafeCast(V, typeOf(V')) ...&lt;/k&gt;
       &lt;store&gt;... L |-&gt; (V' =&gt; unsafeCast(V, typeOf(V'))) ...&lt;/store&gt;
    [assignment]
</code></pre>
<h2>Typed exceptions</h2>
<p>Exceptions are propagated now until a catch that can handle them is
encountered.</p>
<pre><code class="language-k">  syntax KItem ::= xstackFrame(Param, Stmt, K, Map, K)
  syntax KItem ::= &quot;popx&quot;

  rule &lt;k&gt; (try S1 catch(P) S2 =&gt; S1 ~&gt; popx) ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;xstack&gt; .List =&gt; ListItem(xstackFrame(P, S2, K, Env, C)) ...&lt;/xstack&gt;
         C
       &lt;/control&gt;
       &lt;env&gt; Env &lt;/env&gt;

  rule &lt;k&gt; popx =&gt; . ...&lt;/k&gt;
       &lt;xstack&gt; ListItem(_) =&gt; .List ...&lt;/xstack&gt;

  rule &lt;k&gt; throw V:Val; ~&gt; _
        =&gt; if (subtype(typeOf(V),T)) { T X = V; S2 } else { throw V; } ~&gt; K
       &lt;/k&gt;
       &lt;control&gt;
         &lt;xstack&gt; ListItem(xstackFrame(T:Type X:Id, S2, K, Env, C)) =&gt; .List ...&lt;/xstack&gt;
         (_ =&gt; C)
       &lt;/control&gt;
       &lt;env&gt; _ =&gt; Env &lt;/env&gt;
</code></pre>
<h2>Spawn</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  rule &lt;thread&gt;...
         &lt;k&gt; spawn S =&gt; !T:Int ...&lt;/k&gt;
         &lt;env&gt; Env &lt;/env&gt;
         &lt;crntObj&gt; Obj &lt;/crntObj&gt;
       ...&lt;/thread&gt;
       (.Bag =&gt; &lt;thread&gt;...
               &lt;k&gt; S &lt;/k&gt;
               &lt;env&gt; Env &lt;/env&gt;
               &lt;id&gt; !T &lt;/id&gt;
               &lt;crntObj&gt; Obj &lt;/crntObj&gt;
             ...&lt;/thread&gt;)
</code></pre>
<h2>Semantics of the new KOOL constructs</h2>
<h2>Class declaration</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  rule &lt;k&gt; class Class1 extends Class2 { S } =&gt; . ...&lt;/k&gt;
       &lt;classes&gt;... (.Bag =&gt; &lt;classData&gt;
                            &lt;className&gt; Class1 &lt;/className&gt;
                            &lt;baseClass&gt; Class2 &lt;/baseClass&gt;
                            &lt;declarations&gt; S &lt;/declarations&gt;
                        &lt;/classData&gt;)
       ...&lt;/classes&gt;  [structural]
</code></pre>
<h2>Method declaration</h2>
<p>Methods are now typed and we need to store their types in their
closures, so that their type contract can be checked at invocation
time.  The rule below is conceptually similar to that of untyped KOOL;
the only difference is the addition of the types.</p>
<pre><code class="language-k">  rule &lt;k&gt; T:Type F:Id(Ps:Params) S =&gt; . ...&lt;/k&gt;
       &lt;crntClass&gt; C &lt;/crntClass&gt;
       &lt;location&gt; OL &lt;/location&gt;
       &lt;env&gt; Env =&gt; Env[F &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L|-&gt;methodClosure(getTypes(Ps)-&gt;T,C,OL,Ps,S) ...&lt;/store&gt;
       &lt;nextLoc&gt; L =&gt; L +Int 1 &lt;/nextLoc&gt;
</code></pre>
<h2>New</h2>
<p>The semantics of <code>new</code> in dynamically typed KOOL is also
similar to that in untyped KOOL, the main difference being the
management of the return types.  Indeed, when a new object is created
we also have to stack the current type in the <code>return</code> cell in
order to be recovered after the creation of the new object.  Only the
first rule below needs to be changed; the others are identical to
those in untyped KOOL.</p>
<pre><code class="language-k">  syntax KItem ::= envStackFrame(Id, Map)

  rule &lt;k&gt; new Class:Id(Vs:Vals) ~&gt; K
           =&gt; create(Class) ~&gt; (storeObj ~&gt; ((Class(Vs)); return this;)) &lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;nextLoc&gt; L:Int =&gt; L +Int 1 &lt;/nextLoc&gt;
     //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
       &lt;control&gt;
         &lt;xstack&gt; XS &lt;/xstack&gt;
         &lt;crntObj&gt; Obj
                   =&gt; &lt;crntClass&gt; Object &lt;/crntClass&gt;
                      &lt;envStack&gt; ListItem(envStackFrame(Object, .Map)) &lt;/envStack&gt;
                      &lt;location&gt; L &lt;/location&gt;
         &lt;/crntObj&gt;
         &lt;returnType&gt; T =&gt; Class &lt;/returnType&gt;
         &lt;fstack&gt; .List =&gt; ListItem(fstackFrame(Env, K, XS, T, &lt;crntObj&gt;Obj&lt;/crntObj&gt;)) ...&lt;/fstack&gt;
       &lt;/control&gt;

  syntax KItem ::= create(Id)

  rule &lt;k&gt; create(Class:Id)
           =&gt; create(Class1) ~&gt; setCrntClass(Class) ~&gt; S ~&gt; addEnvLayer ...&lt;/k&gt;
       &lt;className&gt; Class &lt;/className&gt;
       &lt;baseClass&gt; Class1:Id &lt;/baseClass&gt;
       &lt;declarations&gt; S &lt;/declarations&gt;  [structural]

  rule &lt;k&gt; create(Object) =&gt; . ...&lt;/k&gt;  [structural]

  syntax KItem ::= setCrntClass(Id)

  rule &lt;k&gt; setCrntClass(C) =&gt; . ...&lt;/k&gt;
       &lt;crntClass&gt; _ =&gt; C &lt;/crntClass&gt;  [structural]

  syntax KItem ::= &quot;addEnvLayer&quot;

  rule &lt;k&gt; addEnvLayer =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; .List =&gt; ListItem(envStackFrame(Class, Env)) ...&lt;/envStack&gt;
    [structural]

  syntax KItem ::= &quot;storeObj&quot;

  rule &lt;k&gt; storeObj =&gt; . ...&lt;/k&gt;
       &lt;crntObj&gt;
         &lt;crntClass&gt; Class &lt;/crntClass&gt;
         &lt;envStack&gt; EStack &lt;/envStack&gt;
         (&lt;location&gt; L:Int &lt;/location&gt; =&gt; .Bag)
       &lt;/crntObj&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; objectClosure(Class, EStack) ...&lt;/store&gt;
</code></pre>
<h2>Self reference</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  rule &lt;k&gt; this =&gt; objectClosure(Class, EStack) ...&lt;/k&gt;
       &lt;crntObj&gt;
         &lt;crntClass&gt; Class &lt;/crntClass&gt;
         &lt;envStack&gt; EStack &lt;/envStack&gt;
         ...
       &lt;/crntObj&gt;
</code></pre>
<h2>Object member access</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  rule &lt;k&gt; X:Id =&gt; this . X ...&lt;/k&gt; &lt;env&gt; Env:Map &lt;/env&gt;
    requires notBool(X in keys(Env))  [structural]

  context HOLE . _::Id requires (HOLE =/=K super)

/*  rule objectClosure(&lt;crntObj&gt; &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
                     &lt;envStack&gt;... ListItem((Class,EnvC:EnvCell)) EStack &lt;/envStack&gt; &lt;/crntObj&gt;)
       . X:Id
    =&gt; lookupMember(&lt;envStack&gt; ListItem((Class,EnvC)) EStack &lt;/envStack&gt;, X)
    [structural]*/
  rule objectClosure(Class:Id,
                     ListItem(envStackFrame(Class,Env)) EStack)
       . X:Id
    =&gt; lookupMember(ListItem(envStackFrame(Class,Env)) EStack, X)
    [structural]
  rule objectClosure(Class:Id,
                     (ListItem(envStackFrame(Class':Id,_)) =&gt; .List) EStack)
       . X:Id
    requires Class =/=K Class' [structural]

/*  rule &lt;k&gt; super . X =&gt; lookupMember(&lt;envStack&gt;EStack&lt;/envStack&gt;, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... ListItem((Class,EnvC:EnvCell)) EStack &lt;/envStack&gt;
    [structural]*/
  rule &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class,_)) EStack &lt;/envStack&gt;
    [structural]
  rule &lt;k&gt; super . X ...&lt;/k&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; (ListItem(envStackFrame(Class':Id,_)) =&gt; .List) EStack &lt;/envStack&gt;
    requires Class =/=K Class' [structural]
</code></pre>
<h2>Method invocation</h2>
<p>The method lookup is the same as in untyped KOOL.</p>
<pre><code class="language-k">  rule &lt;k&gt; (X:Id =&gt; V)(_:Exps) ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]

  rule &lt;k&gt; (X:Id =&gt; this . X)(_:Exps) ...&lt;/k&gt;
       &lt;env&gt; Env &lt;/env&gt;
    requires notBool(X in keys(Env))  [structural]

  context HOLE._::Id(_) requires HOLE =/=K super

  rule (objectClosure(_, EStack) . X
    =&gt; lookupMember(EStack, X:Id))(_:Exps)  [structural]

/*  rule &lt;k&gt; (super . X
            =&gt; lookupMember(&lt;envStack&gt;EStack&lt;/envStack&gt;,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... ListItem((Class,_)) EStack &lt;/envStack&gt;
    [structural]*/
  rule &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class,_)) EStack &lt;/envStack&gt;
    [structural]
  rule &lt;k&gt; (super . X)(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; (ListItem(envStackFrame(Class':Id,_)) =&gt; .List) EStack &lt;/envStack&gt;
    requires Class =/=K Class' [structural]

  // TODO(KORE): fix getKLabel #1801
  rule (A:Exp(B:Exps))(C:Exps) =&gt; A(B) ~&gt; #freezerFunCall(C)
  rule (A:Exp[B:Exps])(C:Exps) =&gt; A[B] ~&gt; #freezerFunCall(C)
  rule V:Val ~&gt; #freezerFunCall(C:Exps) =&gt; V(C)
  syntax KItem ::= &quot;#freezerFunCall&quot; &quot;(&quot; K &quot;)&quot;
  /*
  context HOLE(_:Exps)
    requires getKLabel HOLE ==KLabel '_`(_`) orBool getKLabel HOLE ==KLabel '_`[_`]
  */

  rule &lt;k&gt; (lookup(L) =&gt; V)(_:Exps) ...&lt;/k&gt;  &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;
    [lookup]
</code></pre>
<h2>Instance of</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  rule objectClosure(_, ListItem(envStackFrame(C,_)) _)
       instanceOf C =&gt; true

  rule objectClosure(_, (ListItem(envStackFrame(C::Id,_)) =&gt; .List) _)
       instanceOf C'  requires C =/=K C'  [structural]

  rule objectClosure(_, .List) instanceOf _ =&gt; false
</code></pre>
<h2>Cast</h2>
<p>Unlike in untyped KOOL, in typed KOOL we actually check that the object
can indeed be cast to the claimed type.</p>
<pre><code class="language-k">  rule (C:Id) objectClosure(Irrelevant, EStack)
    =&gt; objectClosure(Irrelevant, EStack) instanceOf C ~&gt; true?
       ~&gt; objectClosure(C, EStack)
</code></pre>
<h2>KOOL-specific auxiliary declarations and operations</h2>
<h2>Objects as lvalues</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  rule &lt;k&gt; lvalue(X:Id =&gt; this . X) ...&lt;/k&gt;  &lt;env&gt; Env &lt;/env&gt;
    requires notBool(X in keys(Env))  [structural]

  context lvalue((HOLE . _)::Exp)

/*  rule lvalue(objectClosure(&lt;crntObj&gt; &lt;crntClass&gt; C &lt;/crntClass&gt;
                            &lt;envStack&gt;... ListItem((C,EnvC:EnvCell)) EStack &lt;/envStack&gt; &lt;/crntObj&gt;)
              . X
              =&gt; lookupMember(&lt;envStack&gt; ListItem((C,EnvC)) EStack &lt;/envStack&gt;,
                              X))  [structural]*/
  rule lvalue(objectClosure(C:Id,
                            ListItem(envStackFrame(C,Env)) EStack)
              . X
              =&gt; lookupMember(ListItem(envStackFrame(C,Env)) EStack,
                              X))  [structural]
  rule lvalue(objectClosure(C,
                            (ListItem(envStackFrame(C',_)) =&gt; .List) EStack)
              . X)
    requires C =/=K C' [structural]
</code></pre>
<h2>Lookup member</h2>
<p>Like in untyped KOOL.</p>
<pre><code class="language-k">  syntax Exp ::= lookupMember(List,Id)  [function]

  rule lookupMember(ListItem(envStackFrame(_, X |-&gt; L _)) _, X) =&gt; lookup(L)

  // TODO: fix rule below as shown once we support functions with deep rewrites
  // rule lookupMember(&lt;envStack&gt; ListItem((_, &lt;env&gt; Env &lt;/env&gt;)) =&gt; .List
  //                     ...&lt;/envStack&gt;, X)
  //   requires notBool(X in keys(Env))
  rule lookupMember(ListItem(envStackFrame(_, Env)) L, X)
    =&gt; lookupMember(L, X)
    requires notBool(X in keys(Env))
</code></pre>
<h2><code>typeOf</code> for the additional values}</h2>
<pre><code class="language-k">  rule typeOf(objectClosure(C,_)) =&gt; C
  rule typeOf(methodClosure(T:Type,_,_,Ps:Params,_)) =&gt; T
</code></pre>
<h2>Subtype checking</h2>
<p>The subclass relation induces a subtyping relation.</p>
<pre><code class="language-k">  syntax Exp ::= subtype(Types,Types)

  rule subtype(T:Type, T) =&gt; true  [structural]

  rule &lt;k&gt; subtype(C1:Id, C:Id) =&gt; subtype(C2, C) ...&lt;/k&gt;
       &lt;className&gt; C1 &lt;/className&gt;
       &lt;baseClass&gt; C2:Id &lt;/baseClass&gt;
    requires C1 =/=K C  [structural]

  rule subtype(Object,Class:Id) =&gt; false
    requires Class =/=K Object  [structural]

  rule subtype(Ts1-&gt;T2,Ts1'-&gt;T2') =&gt; subtype(((T2)::Type,Ts1'),((T2')::Type,Ts1))  [structural]

// Note that the following rule would be wrong!
//  rule subtype(T[],T'[]) =&gt; subtype(T,T')

  rule subtype((T:Type,Ts),(T':Type,Ts')) =&gt; subtype(T,T') &amp;&amp; subtype(Ts,Ts')
    requires Ts =/=K .Types  [structural]
  rule subtype(.Types,.Types) =&gt; true  [structural]
</code></pre>
<h2>Unsafe Casting</h2>
<p>Performs unsafe casting.  One should only use it in combination with
the subtype relation above.</p>
<pre><code class="language-k">  syntax Val ::= unsafeCast(Val,Type)  [function]

  rule unsafeCast(objectClosure(_,EStack), C:Id)
    =&gt; objectClosure(C,EStack)

  rule unsafeCast(methodClosure(T',C,OL,Ps,S), T) =&gt; methodClosure(T,C,OL,Ps,S)

  rule unsafeCast(V:Val, T:Type) =&gt; V  requires typeOf(V) ==K T
</code></pre>
<h2>Generic guard</h2>
<p>A generic computational guard: it allows the computation to continue
only if a prefix guard evaluates to true.</p>
<pre><code class="language-k">  syntax KItem ::= &quot;true?&quot;
  rule true ~&gt; true? =&gt; .  [structural]

endmodule
</code></pre>
<p>Go to <a href="../2_static/kool-typed-static.md">Lesson 3, KOOL typed static</a>.</p>

          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
