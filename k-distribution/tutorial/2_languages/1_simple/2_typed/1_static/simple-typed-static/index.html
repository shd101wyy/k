<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1>SIMPLE &#x2014; Typed &#x2014; Static</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2>Abstract</h2>
<p>This is the <strong>K</strong> definition of the static semantics of the typed SIMPLE
language, or in other words, a type system for the typed SIMPLE
language in <strong>K</strong>.  We do not re-discuss the various features of the
SIMPLE language here.  The reader is referred to the untyped version of
the language for such discussions.  We here only focus on the new and
interesting problems raised by the addition of type declarations, and
what it takes to devise a type system/checker for the language.</p>
<p>When designing a type system for a language, no matter in what
paradigm, we have to decide upon the intended typing policy.  Note
that we can have multiple type systems for the same language, one for
each typing policy.  For example, should we accept programs which
don&apos;t have a main function?  Or should we allow functions that do not
return explicitly?  Or should we allow functions whose type expects
them to return a value (say an <code>int</code>) to use a plain
<code>return;</code> statement, which returns no value, like in C?
And so on and so forth.  Typically, there are two opposite tensions
when designing a type system.  On the one hand, you want your type
system to be as permissive as possible, that is, to accept as many
programs that do not get stuck when executed with the untyped
semantics as possible; this will keep the programmers using your
language happy.  On the other hand, you want your type system to have
a reasonable performance when implemented; this will keep both the
programmers and the implementers of your language happy.  For example,
a type system for rejecting programs that could perform
division-by-zero is not expected to be feasible in general.  A simple
guideline when designing typing policies is to imagine how the
semantics of the untyped language may get stuck and try to prevent
those situations from happening.</p>
<p>Before we give the <strong>K</strong> type system of SIMPLE formally, we discuss,
informally, the intended typing policy:</p>
<ul>
<li>
<p>Each program should contain a <code>main()</code> function.  Indeed,
the untyped SIMPLE semantics will get stuck on any program which does
not have a <code>main</code> function.</p>
</li>
<li>
<p>Each primitive value has its own type, which can be <code>int</code>
<code>bool</code>, or <code>string</code>.  There is also a type <code>void</code>
for nonexistent values, for example for the result of a function meant
to return no value (but only be used for its side effects, like a
procedure).</p>
</li>
<li>
<p>The syntax of untyped SIMPLE is extended to allow type
declarations for all the variables, including array variables.  This is
done in a C/Java-style.  For example, <code>int x;</code> or
<code>int x=7, y=x+3;</code>, or <code>int[][][] a[10,20];</code>
(the latter defines a <code>10 &#xD7; 20</code> matrix of arrays of integers).
Recall from untyped SIMPLE that, unlike in C/Java, our multi-dimensional
arrays use comma-separated arguments, although they have the array-of-array
semantics.</p>
</li>
<li>
<p>Functions are also typed in a C/Java style.  However, since in SIMPLE
we allow functions to be passed to and returned by other functions, we also
need function types.  We will use the conventional higher-order arrow-notation
for function types, but will separate the argument types with commas.  For
example, a function returning an array of <code>bool</code> elements and
taking as argument an array <code>x</code> of two-integer-argument functions
returning an integer, is declared using a syntax of the form
<code>bool[] f(((int,int)-&gt;int)[] x) { ... }</code>
and has the type <code>((int,int)-&gt;int)[] -&gt; bool[]</code>.</p>
</li>
<li>
<p>We allow any variable declarations at the top level.  Functions
can only be declared at the top level.  Each function can only access the
other functions and variables declared at the top level, or its own locally
declared variables.  SIMPLE has static scoping.</p>
</li>
<li>
<p>The various expression and statement constructs take only elements of
the expected types.</p>
</li>
<li>
<p>Increment and assignment can operate both on variables and on array
elements.  For example, if <code>f</code> has type <code>int-&gt;int[][]</code> and
function <code>g</code> has the type <code>int-&gt;int</code>, then the
increment expression <code>++f(7)[g(2),g(3)]</code> is valid.</p>
</li>
<li>
<p>Functions should only return values of their declared result
type.  To give the programmers more flexibility, we allow functions to
use <code>return;</code> statements to terminate without returning an
actual value, or to not explicitly use any return statement,
regardless of their declared return type.  This flexibility can be
handy when writing programs using certain functions only for their
side effects.  Nevertheless, as the dynamic semantics shows, a return
value is automatically generated when an explicit <code>return</code>
statement is not encountered.</p>
</li>
<li>
<p>For simplicity, we here limit exceptions to only throw and catch
integer values.  We let it as an exercise to the reader to extend the
semantics to allow throwing and catching arbitrary-type exceptions.
Like in programming languages like Java, one can go even further and
define a semantics where thrown exceptions are propagated through
try-catch statements until one of the corresponding type is found.
We will do this when we define the KOOL language, not here.
To keep the definition if SIMPLE simple, here we do not attempt to
reject programs which throw uncaught exceptions.</p>
</li>
</ul>
<p>Like in untyped SIMPLE, some constructs can be desugared into a
smaller set of basic constructs.  In general, it should be clear why a
program does not type by looking at the top of the <code>k</code> cells in
its stuck configuration.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> SIMPLE-TYPED-STATIC-SYNTAX<span class="hljs-keyword">
  imports</span> DOMAINS-SYNTAX
</code></pre>
<h2>Syntax</h2>
<p>The syntax of typed SIMPLE extends that of untyped SIMPLE with support
for declaring types to variables and functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Id</span> ::= <span class="hljs-string">&quot;main&quot;</span> [<span class="hljs-literal">token</span>]
</code></pre>
<h2>Types</h2>
<p>Primitive, array and function types, as well as lists (or tuples) of types.
The lists of types are useful for function arguments.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Type ::= <span class="hljs-string">&quot;void&quot;</span> | <span class="hljs-string">&quot;int&quot;</span> | <span class="hljs-string">&quot;bool&quot;</span> | <span class="hljs-string">&quot;string&quot;</span>
                | Type <span class="hljs-string">&quot;[&quot;</span> <span class="hljs-string">&quot;]&quot;</span>
                &gt; Types <span class="hljs-string">&quot;-&gt;&quot;</span> Type
                | <span class="hljs-string">&quot;(&quot;</span> Type <span class="hljs-string">&quot;)&quot;</span>             [<span class="hljs-literal">bracket</span>]<span class="hljs-keyword">

  syntax</span> Types ::= List{Type,<span class="hljs-string">&quot;,&quot;</span>}
</code></pre>
<h2>Declarations</h2>
<p>Variable and function declarations have the expected syntax.  For variables,
we basically just replaced the <code>var</code> keyword of untyped SIMPLE with a
type.  For functions, besides replacing the <code>function</code> keyword with a
type, we also introduce a new syntactic category for typed variables,
<code>Param</code>, and lists over it.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Param ::= Type<span class="hljs-keyword"> Id</span><span class="hljs-keyword">
  syntax</span> Params ::= List{Param,<span class="hljs-string">&quot;,&quot;</span>}<span class="hljs-keyword">

  syntax</span> Decl ::= Type Exps <span class="hljs-string">&quot;;&quot;</span>
                | Type<span class="hljs-keyword"> Id</span> <span class="hljs-string">&quot;(&quot;</span> Params <span class="hljs-string">&quot;)&quot;</span> Block
</code></pre>
<h2>Expressions</h2>
<p>The syntax of expressions is identical to that in untyped SIMPLE,
except for the logical conjunction and disjunction which have
different strictness attributes, because they now have different
evaluation strategies.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::=<span class="hljs-keyword"> Int</span> |<span class="hljs-keyword"> Bool</span> |<span class="hljs-keyword"> String</span> |<span class="hljs-keyword"> Id</span>
               | <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>             [<span class="hljs-literal">bracket</span>]
               | <span class="hljs-string">&quot;++&quot;</span> Exp
               &gt; Exp <span class="hljs-string">&quot;[&quot;</span> Exps <span class="hljs-string">&quot;]&quot;</span>        [<span class="hljs-literal">strict</span>]
               &gt; Exp <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span>        [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;-&quot;</span> Exp                 [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;sizeOf&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span>    [<span class="hljs-literal">strict</span>]
               | <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;)&quot;</span>
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;*&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;/&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;%&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;+&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;-&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-literal">non-assoc</span>:
                 Exp <span class="hljs-string">&quot;&lt;&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&lt;=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&gt;&quot;</span> Exp             [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;&gt;=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;==&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               | Exp <span class="hljs-string">&quot;!=&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">non-assoc</span>]
               &gt; <span class="hljs-string">&quot;!&quot;</span> Exp                 [<span class="hljs-literal">strict</span>]
               &gt; <span class="hljs-literal">left</span>:
                 Exp <span class="hljs-string">&quot;&amp;&amp;&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               | Exp <span class="hljs-string">&quot;||&quot;</span> Exp            [<span class="hljs-literal">strict</span>, <span class="hljs-literal">left</span>]
               &gt; <span class="hljs-string">&quot;spawn&quot;</span> Block
               &gt; Exp <span class="hljs-string">&quot;=&quot;</span> Exp             [<span class="hljs-literal">strict</span>(<span class="hljs-number">2</span>), <span class="hljs-literal">right</span>]
</code></pre>
<p>Note that <code>spawn</code> has not been declared strict.  This may
seem unexpected,  because the child thread shares the same environment
with the parent thread, so from a typing perspective the spawned
statement makes the same sense in a child thread as it makes in the
parent thread.  The reason for not declaring it strict is because we
want to disallow programs where the spawned thread calls the
<code>return</code> statement, because those programs would get stuck in
the dynamic semantics.  The type semantics of spawn below will reject
such programs.</p>
<p>We still need lists of expressions, defined below, but note that we do
not need lists of identifiers anymore.  They have been replaced by the lists
of parameters.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exps ::= List{Exp,<span class="hljs-string">&quot;,&quot;</span>}          [<span class="hljs-literal">strict</span>]
</code></pre>
<h2>Statements</h2>
<p>The statements have the same syntax as in untyped SIMPLE, except for
the exceptions, which now type their parameter.  Note that, unlike in untyped
SIMPLE, all statement constructs which have arguments and are not desugared
are strict, including the conditional and the <code>while</code>.  Indeed, from a
typing perspective, they are all strict: first type their arguments and then
type the actual construct.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Block ::= <span class="hljs-string">&quot;{&quot;</span> <span class="hljs-string">&quot;}&quot;</span>
                | <span class="hljs-string">&quot;{&quot;</span> Stmts <span class="hljs-string">&quot;}&quot;</span><span class="hljs-keyword">

  syntax</span> Stmt ::= Decl | Block
                | Exp <span class="hljs-string">&quot;;&quot;</span>                                  [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block <span class="hljs-string">&quot;else&quot;</span> Block      [<span class="hljs-literal">avoid</span>, <span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;if&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;while&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block                [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;for&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Stmts Exp <span class="hljs-string">&quot;;&quot;</span> Exp <span class="hljs-string">&quot;)&quot;</span> Block
                | <span class="hljs-string">&quot;return&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                         [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;return&quot;</span> <span class="hljs-string">&quot;;&quot;</span>
                | <span class="hljs-string">&quot;print&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Exps <span class="hljs-string">&quot;)&quot;</span> <span class="hljs-string">&quot;;&quot;</span>                 [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;try&quot;</span> Block <span class="hljs-string">&quot;catch&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Param <span class="hljs-string">&quot;)&quot;</span> Block  [<span class="hljs-literal">strict</span>(<span class="hljs-number">1</span>)]
                | <span class="hljs-string">&quot;throw&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                          [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;join&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                           [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;acquire&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                        [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;release&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                        [<span class="hljs-literal">strict</span>]
                | <span class="hljs-string">&quot;rendezvous&quot;</span> Exp <span class="hljs-string">&quot;;&quot;</span>                     [<span class="hljs-literal">strict</span>]
</code></pre>
<p>Note that the sequential composition is now sequentially strict,
because, unlike in the dynamic semantics where statements dissolved,
they now reduce to the <code>stmt</code> type, which is a result.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Stmts ::= Stmt
                |  Stmts Stmts                             [<span class="hljs-literal">seqstrict</span>, <span class="hljs-literal">right</span>]
</code></pre>
<h2>Desugaring macros</h2>
<p>We use the same desugaring macros like in untyped SIMPLE, but, of
course, including the types of the involved variables.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> if (E) S =&gt; if (E) S else {}                                     [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> for(Start Cond; Step) {S:Stmts} =&gt; {Start while(Cond){S Step;}}  [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> for(Start Cond; Step) {} =&gt; {Start while(Cond){Step;}}           [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">
  rule</span> T:Type E1:Exp, E2:Exp, Es:Exps; =&gt; T E1; T E2, Es;               [<span class="hljs-literal">macro</span>-rec]<span class="hljs-keyword">
  rule</span> T:Type X:<span class="hljs-keyword">Id</span> = E; =&gt; T X; X = E;                                  [<span class="hljs-literal">macro</span>]<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">


module</span> SIMPLE-TYPED-STATIC<span class="hljs-keyword">
  imports</span> SIMPLE-TYPED-STATIC-SYNTAX<span class="hljs-keyword">
  imports</span> DOMAINS
</code></pre>
<h2>Static semantics</h2>
<p>Here we define the type system of SIMPLE.  Like concrete semantics,
type systems defined in <strong>K</strong> are also executable.  However, <strong>K</strong> type
systems turn into type checkers instead of interpreters when executed.</p>
<p>The typing process is done in two (overlapping) phases.  In the first
phase the global environment is built, which contains type bindings
for all the globally declared variables and functions.  For functions,
the declared types will be ``trusted&apos;&apos; during the first phase and
simply bound to their corresponding function names and placed in the
global type environment.  At the same time, type-checking tasks that
the function bodies indeed respect their claimed types are generated.
All these tasks are (concurrently) verified during the second phase.
This way, all the global variable and function declarations are
available in the global type environment and can be used in order to
type-check each function code.  This is consistent with the semantics
of untyped SIMPLE, where functions can access all the global variables
and can call any other function declared in the same program.  The
two phases may overlap because of the <strong>K</strong> concurrent semantics.  For
example, a function task can be started while the first phase is still
running; moreover, it may even complete before the first phase does,
namely when all the global variables and functions that it needs have
already been processed and made available in the global environment by
the first phase task.</p>
<h2>Extended syntax and results</h2>
<p>The idea is to start with a configuration holding the program to type
in one of its cells, then apply rewrite rules on it mixing types and
language syntax, and eventually obtain a type instead of the original
program.  In other words, the program reduces to its type using
the <strong>K</strong> rules giving the type system of the language.  In doing so,
additional typing tasks for function bodies are generated and solved
the same way.  If this rewriting process gets stuck, then we say that
the program is not well-typed.  Otherwise the program is well-typed
(by definition).  We did not need types for statements and for blocks
as part of the typed SIMPLE syntax, because programmers are not allowed
to use such types explicitly.  However, we are going to need them in the
type system, because blocks and statements reduce to them.</p>
<p>We start by allowing types to be used inside expressions and statements in
our language.  This way, types can be used together with language syntax in
subsequent <strong>K</strong> rules without any parsing errors.  Like in the type system of
IMP++ in the <strong>K</strong> tutorial, we prefer to group the block and statement types
under one syntactic sub-category of types, because this allows us to more
compactly state that certain terms can be either blocks or statements.  Also,
since programs and fragments of program will reduce to their types, in order
for the strictness and context declarations to be executable we state that
types are results (same like we did in the IMP++ tutorial).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Exp ::= Type<span class="hljs-keyword">
  syntax</span> Exps ::= Types<span class="hljs-keyword">
  syntax</span> BlockOrStmtType ::= <span class="hljs-string">&quot;block&quot;</span> | <span class="hljs-string">&quot;stmt&quot;</span><span class="hljs-keyword">
  syntax</span> Type ::= BlockOrStmtType<span class="hljs-keyword">
  syntax</span> Block ::= BlockOrStmtType<span class="hljs-keyword">
  syntax</span> KResult ::= Type
                   | Types    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> remove this, eventually</span>
</code></pre>
<h2>Configuration</h2>
<p>The configuration of our type system consists of a <code>tasks</code> cell
holding various typing <code>task</code> cells, and a global type environment.
Each task includes a <code>k</code> cell holding the code to type, a <code>tenv</code>
cell holding the local type environment, and a <code>return</code> cell holding
the return type of the currently checked function.  The latter is needed in
order to check whether return statements return values of the expected type.
Initially, the program is placed in a <code>k</code> cell inside a
<code>task</code> cell.  Since the cells with multiplicity <code>?</code> are not
included in the initial configuration, the <code>task</code> cell holding
the original program in its <code>k</code> cell will contain no other
subcells.</p>
<pre class="hljs"><code><span class="hljs-keyword">  configuration</span> &lt;T color=<span class="hljs-string">&quot;yellow&quot;</span>&gt;
                  &lt;tasks color=<span class="hljs-string">&quot;orange&quot;</span>&gt;
                    &lt;task multiplicity=<span class="hljs-string">&quot;*&quot;</span> color=<span class="hljs-string">&quot;yellow&quot;</span>&gt;
                      &lt;k color=<span class="hljs-string">&quot;green&quot;</span>&gt; $PGM:Stmts &lt;/k&gt;
                      &lt;tenv multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;cyan&quot;</span>&gt; .Map &lt;/tenv&gt;
                      &lt;returnType multiplicity=<span class="hljs-string">&quot;?&quot;</span> color=<span class="hljs-string">&quot;black&quot;</span>&gt; void &lt;/returnType&gt;
                    &lt;/task&gt;
                  &lt;/tasks&gt;
<span class="hljs-comment">//                  &lt;br/&gt;</span>
                  &lt;gtenv color=<span class="hljs-string">&quot;blue&quot;</span>&gt; .Map &lt;/gtenv&gt;
                &lt;/T&gt;
</code></pre>
<h2>Variable declarations</h2>
<p>Variable declarations type as statements, that is, they reduce to the
type <code>stmt</code>.  There are only two cases that need to be
considered: when a simple variable is declared and when an array
variable is declared.  The macros at the end of the syntax module
above take care of reducing other variable declarations, including
ones where the declared variables are initialized, to only these two
cases.  The first case has two subcases: when the variable declaration
is global (i.e., the <code>task</code> cell contains only the <code>k</code>
cell), in which case it is added to the global type environment
checking at the same time that the variable has not been already
declared; and when the variable declaration is local (i.e., a
<code>tenv</code> cell is available), in which case it is simply added to
the local type environment, possibly shadowing previous homonymous
variables.  The third case reduces to the second, incrementally moving
the array dimension into the type until the array becomes a simple
variable.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;task&gt; &lt;k&gt; T:Type X:<span class="hljs-keyword">Id</span>; =&gt; stmt ...&lt;/k&gt; &lt;/task&gt;
       &lt;gtenv&gt; Rho (.Map =&gt; X |-&gt; T) &lt;/gtenv&gt;<span class="hljs-keyword">
    requires</span> notBool(X in keys(Rho))<span class="hljs-keyword">
  rule</span> &lt;k&gt; T:Type X:<span class="hljs-keyword">Id</span>; =&gt; stmt ...&lt;/k&gt; &lt;tenv&gt; Rho =&gt; Rho[X &lt;- T] &lt;/tenv&gt;<span class="hljs-keyword">

  context</span> _:Type _::Exp[HOLE::Exps];
<span class="hljs-comment">// The rule below may need to sort E to Exp in the future, if the
// parser gets stricter; without that information, it may not be able</span>
<span class="hljs-comment">// to complete the LHS into T E[int,Ts],.Exps; (and similarly for the RHS)</span><span class="hljs-keyword">
  rule</span> T:Type E:Exp[int,Ts:Types]; =&gt; T[] E[Ts];  [<span class="hljs-literal">structural</span>]
<span class="hljs-comment">// I want to write the rule below as _:Type (E:Exp[.Types] =&gt; E),</span>
<span class="hljs-comment">// but the list completion seems to not work well with that.</span><span class="hljs-keyword">
  rule</span> T:Type E:Exp[.Types]; =&gt; T E;          [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Function declarations</h2>
<p>Functions are allowed to be declared only at the top level (the
<code>task</code> cell holds only its <code>k</code> subcell).  Each function
declaration reduces to a variable declaration (a binding of its name
to its declared function type), but also adds a task into the
<code>tasks</code> cell.  The task consists of a typing of the statement
declaring all the function parameters followed by the function body,
together with the expected return type of the function.  The
<code>getTypes</code> and <code>mkDecls</code> functions, defined at the end of
the file in the section on auxiliary operations, extracts the list of
types and makes a sequence of variable declarations from a list of
function parameters, respectively.  Note that, although in the dynamic
semantics we include a terminating <code>return</code> statement at the
end of the function body to eliminate from the analysis the case when
the function does not provide an explicit return, we do not need to
include such a similar <code>return</code> statement here.  That&apos;s because
the <code>return</code> statements type to <code>stmt</code> anyway, and the
entire code of the function body needs to type anyway.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;task&gt; &lt;k&gt; T:Type F:<span class="hljs-keyword">Id</span>(Ps:Params) S =&gt; getTypes(Ps)-&gt;T F; ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt;
               &lt;k&gt; mkDecls(Ps) S &lt;/k&gt; &lt;tenv&gt; .Map &lt;/tenv&gt; &lt;returnType&gt; T &lt;/returnType&gt;
             &lt;/task&gt;)
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Checking if <code>main()</code> exists}</h2>
<p>Once the entire program is processed (generating appropriate tasks
to type check its function bodies), we can dissolve the main
<code>task</code> cell (the one holding only a <code>k</code> subcell).  Since
we want to enforce that programs include a main function, we also
generate a function task executing <code>main()</code> to ensure that it
types (remove this task creation if you do not want your type system
to reject programs without a <code>main</code> function).</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;task&gt; &lt;k&gt; stmt =&gt; main(.Exps); &lt;/k&gt; (.Bag =&gt; &lt;tenv&gt; .Map &lt;/tenv&gt;) &lt;/task&gt;
    [<span class="hljs-literal">structural</span>]
</code></pre>
<h2>Collecting the terminated tasks</h2>
<p>Similarly, once a non-main task (i.e., one which contains a
<code>tenv</code> subcells) is completed using the subsequent rules (i.e.,
its <code>k</code> cell holds only the <code>block</code> or <code>stmt</code>
type), we can dissolve its corresponding cell.  Note that it is
important to ensure that we only dissolve tasks containing a
<code>tenv</code> cell with the rule below, because the main task should
<code>not</code> dissolve this way!  It should do what the above rule says.
In the end, there should be no task cell left in the configuration
when the program correctly type checks.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;task&gt;... &lt;k&gt; _:BlockOrStmtType &lt;/k&gt; &lt;tenv&gt; _ &lt;/tenv&gt; ...&lt;/task&gt; =&gt; .Bag
</code></pre>
<h2>Basic values</h2>
<p>The first three rewrite rules below reduce the primitive values to
their types, as we typically do when we define type systems in <strong>K</strong>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> _:<span class="hljs-keyword">Int</span> =&gt; int<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">Bool</span> =&gt; bool<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">String</span> =&gt; string
</code></pre>
<h2>Variable lookup</h2>
<p>There are three cases to distinguish for variable lookup: (1) if the
variable is bound in the local type environment, then look its type up
there; (2) if a local environment exists and the variable is not bound
in it, then look its type up in the global environment; (3) finally,
if there is no local environment, meaning that we are executing the
top-level pass, then look the variable&apos;s type up in the global
environment, too.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; T ...&lt;/k&gt; &lt;tenv&gt;... X |-&gt; T ...&lt;/tenv&gt;<span class="hljs-keyword">

  rule</span> &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; T ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;gtenv&gt;... X |-&gt; T ...&lt;/gtenv&gt;<span class="hljs-keyword">
    requires</span> notBool(X in keys(Rho))<span class="hljs-keyword">

  rule</span> &lt;task&gt; &lt;k&gt; X:<span class="hljs-keyword">Id</span> =&gt; T ...&lt;/k&gt; &lt;/task&gt; &lt;gtenv&gt;... X |-&gt; T ...&lt;/gtenv&gt;
</code></pre>
<h2>Increment</h2>
<p>We want the increment operation to apply to any lvalue, including
array elements, not only to variables.  For that reason, we define a
special context extracting the type of the argument of the increment
operation only if that argument is an lvalue.  Otherwise the rewriting
process gets stuck.  The operation <code>ltype</code> is defined at the
end of this file, in the auxiliary operation section.  It essentially
acts as a filter, getting stuck if its argument is not an lvalue and
letting it reduce otherwise.  The type of the lvalue is expected to be
an integer in order to be allowed to be incremented, as seen in the
rule <code>++ int =&gt; int</code> below.</p>
<pre class="hljs"><code><span class="hljs-keyword">  context</span> ++(HOLE =&gt; ltype(HOLE))<span class="hljs-keyword">
  rule</span> ++ int =&gt; int
</code></pre>
<h2>Common expression constructs</h2>
<p>The rules below are straightforward and self-explanatory:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> int + int =&gt; int<span class="hljs-keyword">
  rule</span> string + string =&gt; string<span class="hljs-keyword">
  rule</span> int - int =&gt; int<span class="hljs-keyword">
  rule</span> int * int =&gt; int<span class="hljs-keyword">
  rule</span> int / int =&gt; int<span class="hljs-keyword">
  rule</span> int % int =&gt; int<span class="hljs-keyword">
  rule</span> - int =&gt; int<span class="hljs-keyword">
  rule</span> int &lt; int =&gt; bool<span class="hljs-keyword">
  rule</span> int &lt;= int =&gt; bool<span class="hljs-keyword">
  rule</span> int &gt; int =&gt; bool<span class="hljs-keyword">
  rule</span> int &gt;= int =&gt; bool<span class="hljs-keyword">
  rule</span> T:Type == T =&gt; bool<span class="hljs-keyword">
  rule</span> T:Type != T =&gt; bool<span class="hljs-keyword">
  rule</span> bool &amp;&amp; bool =&gt; bool<span class="hljs-keyword">
  rule</span> bool || bool =&gt; bool<span class="hljs-keyword">
  rule</span> ! bool =&gt; bool
</code></pre>
<h2>Array access and size</h2>
<p>Array access requires each index to type to an integer, and the
array type to be at least as deep as the number of indexes:</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span>
// We used to need parentheses in the RHS, to avoid capturing Ts as rule tag.</span>
<span class="hljs-comment">// Let&apos;s hope that is not a problem anymore.</span><span class="hljs-keyword">

  rule</span> (T[])[int, Ts:Types] =&gt; T[Ts]<span class="hljs-keyword">
  rule</span> T:Type[.Types] =&gt; T
</code></pre>
<p><code>sizeOf</code> only needs to check that its argument is an array:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> sizeOf(T[]) =&gt; int
</code></pre>
<h2>Input/Output</h2>
<p>The read expression construct types to an integer, while print types
to a statement provided that all its arguments type to integers or
strings.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> read() =&gt; int<span class="hljs-keyword">

  rule</span> print(T:Type, Ts =&gt; Ts);<span class="hljs-keyword"> requires</span> T ==K int orBool T ==K string<span class="hljs-keyword">
  rule</span> print(.Types); =&gt; stmt
</code></pre>
<h2>Assignment</h2>
<p>The special context and the rule for assignment below are similar
to those for increment: the LHS of the assignment must be an lvalue
and, in that case, it must have the same type as the RHS, which then
becomes the type of the assignment.</p>
<pre class="hljs"><code><span class="hljs-keyword">  context</span> (HOLE =&gt; ltype(HOLE)) = _<span class="hljs-keyword">
  rule</span> T:Type = T =&gt; T
</code></pre>
<h2>Function application and return</h2>
<p>Function application requires the type of the function and the
types of the passed values to be compatible.  Note that a special case
is needed to handle the no-argument case:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> (Ts:Types -&gt; T)(Ts) =&gt; T<span class="hljs-keyword"> requires</span> Ts =/=K .Types<span class="hljs-keyword">
  rule</span> (void -&gt; T)(.Types) =&gt; T
</code></pre>
<p>The returned value must have the same type as the declared
function return type.  If an empty return is encountered, than
we should check that we are in a function (and not a thread)
context, that is, a <code>return</code> cell must be available:</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; return T:Type; =&gt; stmt ...&lt;/k&gt; &lt;returnType&gt; T &lt;/returnType&gt;<span class="hljs-keyword">
  rule</span> &lt;k&gt; return; =&gt; stmt ...&lt;/k&gt; &lt;returnType&gt; _ &lt;/returnType&gt;
</code></pre>
<h2>Blocks</h2>
<p>To avoid having to recover type environments after blocks, we prefer
to start a new task for block body, making sure that the new task
is passed the same type environment and return cells.  The value
returned by <code>return</code> statements must have the same type as
stated in the <code>return</code> cell.  The <code>print</code> variadic
function is allowed to only print integers and strings.  The thrown
exceptions can only have integer type.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> {} =&gt; block<span class="hljs-keyword">

  rule</span> &lt;task&gt; &lt;k&gt; {S} =&gt; block ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt; &lt;k&gt; S &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;)
</code></pre>
<h2>Expression statement</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> _:Type; =&gt; stmt
</code></pre>
<h2>Conditional and <code>while</code> loop</h2>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> if (bool) block else block =&gt; stmt<span class="hljs-keyword">
  rule</span> while (bool) block =&gt; stmt
</code></pre>
<h2>Exceptions</h2>
<p>We currently force the parameters of exceptions to only be integers.
Moreover, for simplicity, we assume that integer exceptions can be
thrown from anywhere, including from functions which do not define
any try-catch block (with the currently unchecked &#x2012;also for
simplicity&#x2012; expectation that the caller functions would catch those
exceptions).</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> try block catch(int X:<span class="hljs-keyword">Id</span>) {S} =&gt; {int X; S}  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> try block catch(int X:<span class="hljs-keyword">Id</span>) {} =&gt; {int X;}  [<span class="hljs-literal">structural</span>]<span class="hljs-keyword">
  rule</span> throw int; =&gt; stmt
</code></pre>
<h2>Concurrency</h2>
<p>Nothing special about typing the concurrency constructs, except that
we do not want the spawned thread to return, so we do not include any
<code>return</code> cell in the new task cell for the thread statement.
Same like with the functions above, we do not check for thrown
exceptions which are not caught.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> &lt;k&gt; spawn S =&gt; int ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt;
       (.Bag =&gt; &lt;task&gt; &lt;k&gt; S &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;/task&gt;)<span class="hljs-keyword">
  rule</span> join int; =&gt; stmt<span class="hljs-keyword">
  rule</span> acquire _:Type; =&gt; stmt<span class="hljs-keyword">
  rule</span> release _:Type; =&gt; stmt<span class="hljs-keyword">
  rule</span> rendezvous _:Type; =&gt; stmt<span class="hljs-keyword">

  rule</span> _:BlockOrStmtType _:BlockOrStmtType =&gt; stmt
</code></pre>
<h2>Auxiliary constructs</h2>
<p>The function <code>mkDecls</code> turns a list of parameters into a
list of variable declarations.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Stmts ::= mkDecls(Params)  [function]<span class="hljs-keyword">
  rule</span> mkDecls(T:Type X:<span class="hljs-keyword">Id</span>, Ps:Params) =&gt; T X; mkDecls(Ps)<span class="hljs-keyword">
  rule</span> mkDecls(.Params) =&gt; {}
</code></pre>
<p>The <code>ltype</code> context allows only expressions which have an
lvalue to evaluate.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> LValue ::=<span class="hljs-keyword"> Id</span><span class="hljs-keyword">
  rule</span> isLValue(_:Exp[_:Exps]) =&gt; true<span class="hljs-keyword">
  syntax</span> Exp ::= LValue  <span class="hljs-comment">// K should be able to infer this</span>
                         <span class="hljs-comment">// if not added, then it gets stuck with an Id on k cell</span>

<span class="hljs-comment">// Instead of the second LValue production above you can use a rule:</span>
<span class="hljs-comment">//  rule isLValue(_:Exp[_:Exps]) =&gt; true</span><span class="hljs-keyword">

  syntax</span> Exp ::= ltype(Exp)
<span class="hljs-comment">//  context ltype(HOLE:LValue)</span>
<span class="hljs-comment">// The above context does not work due to some error, so we write instead</span><span class="hljs-keyword">
  context</span> ltype(HOLE)<span class="hljs-keyword"> requires</span> isLValue(HOLE)
</code></pre>
<p>The function <code>getTypes</code> is the same as in SIMPLE typed dynamic.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Types ::= getTypes(Params)  [function]<span class="hljs-keyword">
  rule</span> getTypes(T:Type _:<span class="hljs-keyword">Id</span>) =&gt; T, .Types   <span class="hljs-comment">// I would like to not use .Types</span><span class="hljs-keyword">
  rule</span> getTypes(T:Type _:<span class="hljs-keyword">Id</span>, P, Ps) =&gt; T, getTypes(P,Ps)<span class="hljs-keyword">
  rule</span> getTypes(.Params) =&gt; void, .Types<span class="hljs-keyword">

endmodule</span>
</code></pre>
<p>Go to <a href="../../2_dynamic/simple-typed-dynamic/">Lesson 3, SIMPLE typed dynamic</a></p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
