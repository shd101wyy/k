<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1 id="simple-%E2%80%94-typed-%E2%80%94-static">SIMPLE &#x2014; Typed &#x2014; Static</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 id="abstract">Abstract</h2>
<p>This is the <strong>K</strong> definition of the static semantics of the typed SIMPLE<br>
language, or in other words, a type system for the typed SIMPLE<br>
language in <strong>K</strong>.  We do not re-discuss the various features of the<br>
SIMPLE language here.  The reader is referred to the untyped version of<br>
the language for such discussions.  We here only focus on the new and<br>
interesting problems raised by the addition of type declarations, and<br>
what it takes to devise a type system/checker for the language.</p>
<p>When designing a type system for a language, no matter in what<br>
paradigm, we have to decide upon the intended typing policy.  Note<br>
that we can have multiple type systems for the same language, one for<br>
each typing policy.  For example, should we accept programs which<br>
don&apos;t have a main function?  Or should we allow functions that do not<br>
return explicitly?  Or should we allow functions whose type expects<br>
them to return a value (say an <code>int</code>) to use a plain<br>
<code>return;</code> statement, which returns no value, like in C?<br>
And so on and so forth.  Typically, there are two opposite tensions<br>
when designing a type system.  On the one hand, you want your type<br>
system to be as permissive as possible, that is, to accept as many<br>
programs that do not get stuck when executed with the untyped<br>
semantics as possible; this will keep the programmers using your<br>
language happy.  On the other hand, you want your type system to have<br>
a reasonable performance when implemented; this will keep both the<br>
programmers and the implementers of your language happy.  For example,<br>
a type system for rejecting programs that could perform<br>
division-by-zero is not expected to be feasible in general.  A simple<br>
guideline when designing typing policies is to imagine how the<br>
semantics of the untyped language may get stuck and try to prevent<br>
those situations from happening.</p>
<p>Before we give the <strong>K</strong> type system of SIMPLE formally, we discuss,<br>
informally, the intended typing policy:</p>
<ul>
<li>
<p>Each program should contain a <code>main()</code> function.  Indeed,<br>
the untyped SIMPLE semantics will get stuck on any program which does<br>
not have a <code>main</code> function.</p>
</li>
<li>
<p>Each primitive value has its own type, which can be <code>int</code><br>
<code>bool</code>, or <code>string</code>.  There is also a type <code>void</code><br>
for nonexistent values, for example for the result of a function meant<br>
to return no value (but only be used for its side effects, like a<br>
procedure).</p>
</li>
<li>
<p>The syntax of untyped SIMPLE is extended to allow type<br>
declarations for all the variables, including array variables.  This is<br>
done in a C/Java-style.  For example, <code>int x;</code> or<br>
<code>int x=7, y=x+3;</code>, or <code>int[][][] a[10,20];</code><br>
(the latter defines a <code>10 &#xD7; 20</code> matrix of arrays of integers).<br>
Recall from untyped SIMPLE that, unlike in C/Java, our multi-dimensional<br>
arrays use comma-separated arguments, although they have the array-of-array<br>
semantics.</p>
</li>
<li>
<p>Functions are also typed in a C/Java style.  However, since in SIMPLE<br>
we allow functions to be passed to and returned by other functions, we also<br>
need function types.  We will use the conventional higher-order arrow-notation<br>
for function types, but will separate the argument types with commas.  For<br>
example, a function returning an array of <code>bool</code> elements and<br>
taking as argument an array <code>x</code> of two-integer-argument functions<br>
returning an integer, is declared using a syntax of the form<br>
<code>bool[] f(((int,int)-&gt;int)[] x) { ... }</code><br>
and has the type <code>((int,int)-&gt;int)[] -&gt; bool[]</code>.</p>
</li>
<li>
<p>We allow any variable declarations at the top level.  Functions<br>
can only be declared at the top level.  Each function can only access the<br>
other functions and variables declared at the top level, or its own locally<br>
declared variables.  SIMPLE has static scoping.</p>
</li>
<li>
<p>The various expression and statement constructs take only elements of<br>
the expected types.</p>
</li>
<li>
<p>Increment and assignment can operate both on variables and on array<br>
elements.  For example, if <code>f</code> has type <code>int-&gt;int[][]</code> and<br>
function <code>g</code> has the type <code>int-&gt;int</code>, then the<br>
increment expression <code>++f(7)[g(2),g(3)]</code> is valid.</p>
</li>
<li>
<p>Functions should only return values of their declared result<br>
type.  To give the programmers more flexibility, we allow functions to<br>
use <code>return;</code> statements to terminate without returning an<br>
actual value, or to not explicitly use any return statement,<br>
regardless of their declared return type.  This flexibility can be<br>
handy when writing programs using certain functions only for their<br>
side effects.  Nevertheless, as the dynamic semantics shows, a return<br>
value is automatically generated when an explicit <code>return</code><br>
statement is not encountered.</p>
</li>
<li>
<p>For simplicity, we here limit exceptions to only throw and catch<br>
integer values.  We let it as an exercise to the reader to extend the<br>
semantics to allow throwing and catching arbitrary-type exceptions.<br>
Like in programming languages like Java, one can go even further and<br>
define a semantics where thrown exceptions are propagated through<br>
try-catch statements until one of the corresponding type is found.<br>
We will do this when we define the KOOL language, not here.<br>
To keep the definition if SIMPLE simple, here we do not attempt to<br>
reject programs which throw uncaught exceptions.</p>
</li>
</ul>
<p>Like in untyped SIMPLE, some constructs can be desugared into a<br>
smaller set of basic constructs.  In general, it should be clear why a<br>
program does not type by looking at the top of the <code>k</code> cells in<br>
its stuck configuration.</p>
<pre class="language-k"><code><span class="token keyword">module</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</code></pre>
<h2 id="syntax">Syntax</h2>
<p>The syntax of typed SIMPLE extends that of untyped SIMPLE with support<br>
for declaring types to variables and functions.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> <span class="token keyword">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="types">Types</h2>
<p>Primitive, array and function types, as well as lists (or tuples) of types.<br>
The lists of types are useful for function arguments.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;void&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;int&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;bool&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;string&quot;</span>
                <span class="token operator">|</span> Type <span class="token string">&quot;[&quot;</span> <span class="token string">&quot;]&quot;</span>
                <span class="token operator">&gt;</span> Types <span class="token string">&quot;-&gt;&quot;</span> Type
                <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Type <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>

  <span class="token keyword">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Type<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
</code></pre>
<h2 id="declarations">Declarations</h2>
<p>Variable and function declarations have the expected syntax.  For variables,<br>
we basically just replaced the <code>var</code> keyword of untyped SIMPLE with a<br>
type.  For functions, besides replacing the <code>function</code> keyword with a<br>
type, we also introduce a new syntactic category for typed variables,<br>
<code>Param</code>, and lists over it.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Param <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type <span class="token keyword">Id</span>
  <span class="token keyword">syntax</span> Params <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Param<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>

  <span class="token keyword">syntax</span> Decl <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> Type <span class="token keyword">Id</span> <span class="token string">&quot;(&quot;</span> Params <span class="token string">&quot;)&quot;</span> Block
</code></pre>
<h2 id="expressions">Expressions</h2>
<p>The syntax of expressions is identical to that in untyped SIMPLE,<br>
except for the logical conjunction and disjunction which have<br>
different strictness attributes, because they now have different<br>
evaluation strategies.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span> <span class="token operator">|</span> <span class="token keyword">String</span> <span class="token operator">|</span> <span class="token keyword">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token string">&quot;spawn&quot;</span> Block
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</code></pre>
<p>Note that <code>spawn</code> has not been declared strict.  This may<br>
seem unexpected,  because the child thread shares the same environment<br>
with the parent thread, so from a typing perspective the spawned<br>
statement makes the same sense in a child thread as it makes in the<br>
parent thread.  The reason for not declaring it strict is because we<br>
want to disallow programs where the spawned thread calls the<br>
<code>return</code> statement, because those programs would get stuck in<br>
the dynamic semantics.  The type semantics of spawn below will reject<br>
such programs.</p>
<p>We still need lists of expressions, defined below, but note that we do<br>
not need lists of identifiers anymore.  They have been replaced by the lists<br>
of parameters.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="statements">Statements</h2>
<p>The statements have the same syntax as in untyped SIMPLE, except for<br>
the exceptions, which now type their parameter.  Note that, unlike in untyped<br>
SIMPLE, all statement constructs which have arguments and are not desugared<br>
are strict, including the conditional and the <code>while</code>.  Indeed, from a<br>
typing perspective, they are all strict: first type their arguments and then<br>
type the actual construct.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmts <span class="token string">&quot;}&quot;</span>

  <span class="token keyword">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Decl <span class="token operator">|</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block      <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block                <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmts Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                         <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> Param <span class="token string">&quot;)&quot;</span> Block  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                           <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
</code></pre>
<p>Note that the sequential composition is now sequentially strict,<br>
because, unlike in the dynamic semantics where statements dissolved,<br>
they now reduce to the <code>stmt</code> type, which is a result.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt
                <span class="token operator">|</span>  Stmts Stmts                             <span class="token punctuation">[</span><span class="token class-name">seqstrict</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="desugaring-macros">Desugaring macros</h2>
<p>We use the same desugaring macros like in untyped SIMPLE, but, of<br>
course, including the types of the involved variables.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=</span><span class="token operator">&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>                                     <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">:</span>Stmts<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>Start while<span class="token punctuation">(</span>Cond<span class="token punctuation">)</span><span class="token punctuation">{</span>Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>           <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T E1<span class="token punctuation">;</span> T E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>               <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token operator">-</span>rec<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                                  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>

<span class="token keyword">endmodule</span>


<span class="token keyword">module</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC
  <span class="token keyword">imports</span> SIMPLE<span class="token operator">-</span>TYPED<span class="token operator">-</span>STATIC<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> DOMAINS
</code></pre>
<h2 id="static-semantics">Static semantics</h2>
<p>Here we define the type system of SIMPLE.  Like concrete semantics,<br>
type systems defined in <strong>K</strong> are also executable.  However, <strong>K</strong> type<br>
systems turn into type checkers instead of interpreters when executed.</p>
<p>The typing process is done in two (overlapping) phases.  In the first<br>
phase the global environment is built, which contains type bindings<br>
for all the globally declared variables and functions.  For functions,<br>
the declared types will be ``trusted&apos;&apos; during the first phase and<br>
simply bound to their corresponding function names and placed in the<br>
global type environment.  At the same time, type-checking tasks that<br>
the function bodies indeed respect their claimed types are generated.<br>
All these tasks are (concurrently) verified during the second phase.<br>
This way, all the global variable and function declarations are<br>
available in the global type environment and can be used in order to<br>
type-check each function code.  This is consistent with the semantics<br>
of untyped SIMPLE, where functions can access all the global variables<br>
and can call any other function declared in the same program.  The<br>
two phases may overlap because of the <strong>K</strong> concurrent semantics.  For<br>
example, a function task can be started while the first phase is still<br>
running; moreover, it may even complete before the first phase does,<br>
namely when all the global variables and functions that it needs have<br>
already been processed and made available in the global environment by<br>
the first phase task.</p>
<h2 id="extended-syntax-and-results">Extended syntax and results</h2>
<p>The idea is to start with a configuration holding the program to type<br>
in one of its cells, then apply rewrite rules on it mixing types and<br>
language syntax, and eventually obtain a type instead of the original<br>
program.  In other words, the program reduces to its type using<br>
the <strong>K</strong> rules giving the type system of the language.  In doing so,<br>
additional typing tasks for function bodies are generated and solved<br>
the same way.  If this rewriting process gets stuck, then we say that<br>
the program is not well-typed.  Otherwise the program is well-typed<br>
(by definition).  We did not need types for statements and for blocks<br>
as part of the typed SIMPLE syntax, because programmers are not allowed<br>
to use such types explicitly.  However, we are going to need them in the<br>
type system, because blocks and statements reduce to them.</p>
<p>We start by allowing types to be used inside expressions and statements in<br>
our language.  This way, types can be used together with language syntax in<br>
subsequent <strong>K</strong> rules without any parsing errors.  Like in the type system of<br>
IMP++ in the <strong>K</strong> tutorial, we prefer to group the block and statement types<br>
under one syntactic sub-category of types, because this allows us to more<br>
compactly state that certain terms can be either blocks or statements.  Also,<br>
since programs and fragments of program will reduce to their types, in order<br>
for the strictness and context declarations to be executable we state that<br>
types are results (same like we did in the IMP++ tutorial).</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type
  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Types
  <span class="token keyword">syntax</span> BlockOrStmtType <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;block&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;stmt&quot;</span>
  <span class="token keyword">syntax</span> Type <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> BlockOrStmtType
  <span class="token keyword">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Type
                   <span class="token operator">|</span> Types    <span class="token comment">//TODO: remove this, eventually</span>
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>The configuration of our type system consists of a <code>tasks</code> cell<br>
holding various typing <code>task</code> cells, and a global type environment.<br>
Each task includes a <code>k</code> cell holding the code to type, a <code>tenv</code><br>
cell holding the local type environment, and a <code>return</code> cell holding<br>
the return type of the currently checked function.  The latter is needed in<br>
order to check whether return statements return values of the expected type.<br>
Initially, the program is placed in a <code>k</code> cell inside a<br>
<code>task</code> cell.  Since the cells with multiplicity <code>?</code> are not<br>
included in the initial configuration, the <code>task</code> cell holding<br>
the original program in its <code>k</code> cell will contain no other<br>
subcells.</p>
<pre class="language-k"><code>  <span class="token keyword">configuration</span> <span class="token operator">&lt;</span>T color<span class="token operator">=</span><span class="token string">&quot;yellow&quot;</span><span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>tasks color<span class="token operator">=</span><span class="token string">&quot;orange&quot;</span><span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>task multiplicity<span class="token operator">=</span><span class="token string">&quot;*&quot;</span> color<span class="token operator">=</span><span class="token string">&quot;yellow&quot;</span><span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>k color<span class="token operator">=</span><span class="token string">&quot;green&quot;</span><span class="token operator">&gt;</span> $PGM<span class="token punctuation">:</span>Stmts <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>tenv multiplicity<span class="token operator">=</span><span class="token string">&quot;?&quot;</span> color<span class="token operator">=</span><span class="token string">&quot;cyan&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>returnType multiplicity<span class="token operator">=</span><span class="token string">&quot;?&quot;</span> color<span class="token operator">=</span><span class="token string">&quot;black&quot;</span><span class="token operator">&gt;</span> void <span class="token operator">&lt;</span><span class="token operator">/</span>returnType<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span><span class="token operator">/</span>tasks<span class="token operator">&gt;</span>
<span class="token comment">//                  &lt;br/&gt;</span>
                  <span class="token operator">&lt;</span>gtenv color<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>gtenv<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>T<span class="token operator">&gt;</span>
</code></pre>
<h2 id="variable-declarations">Variable declarations</h2>
<p>Variable declarations type as statements, that is, they reduce to the<br>
type <code>stmt</code>.  There are only two cases that need to be<br>
considered: when a simple variable is declared and when an array<br>
variable is declared.  The macros at the end of the syntax module<br>
above take care of reducing other variable declarations, including<br>
ones where the declared variables are initialized, to only these two<br>
cases.  The first case has two subcases: when the variable declaration<br>
is global (i.e., the <code>task</code> cell contains only the <code>k</code><br>
cell), in which case it is added to the global type environment<br>
checking at the same time that the variable has not been already<br>
declared; and when the variable declaration is local (i.e., a<br>
<code>tenv</code> cell is available), in which case it is simply added to<br>
the local type environment, possibly shadowing previous homonymous<br>
variables.  The third case reduces to the second, incrementally moving<br>
the array dimension into the type until the array becomes a simple<br>
variable.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>gtenv<span class="token operator">&gt;</span> Rho <span class="token punctuation">(</span><span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> T<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>gtenv<span class="token operator">&gt;</span>
    <span class="token keyword">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> Rho <span class="token operator">=</span><span class="token operator">&gt;</span> Rho<span class="token punctuation">[</span>X <span class="token operator">&lt;</span><span class="token operator">-</span> T<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span>

  <span class="token keyword">context</span> _<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// The rule below may need to sort E to Exp in the future, if the</span>
<span class="token comment">// parser gets stricter; without that information, it may not be able</span>
<span class="token comment">// to complete the LHS into T E[int,Ts],.Exps; (and similarly for the RHS)</span>
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type E<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>int<span class="token punctuation">,</span>Ts<span class="token punctuation">:</span>Types<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> E<span class="token punctuation">[</span>Ts<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
<span class="token comment">// I want to write the rule below as _:Type (E:Exp[.Types] =&gt; E),</span>
<span class="token comment">// but the list completion seems to not work well with that.</span>
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type E<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span><span class="token punctuation">.</span>Types<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T E<span class="token punctuation">;</span>          <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="function-declarations">Function declarations</h2>
<p>Functions are allowed to be declared only at the top level (the<br>
<code>task</code> cell holds only its <code>k</code> subcell).  Each function<br>
declaration reduces to a variable declaration (a binding of its name<br>
to its declared function type), but also adds a task into the<br>
<code>tasks</code> cell.  The task consists of a typing of the statement<br>
declaring all the function parameters followed by the function body,<br>
together with the expected return type of the function.  The<br>
<code>getTypes</code> and <code>mkDecls</code> functions, defined at the end of<br>
the file in the section on auxiliary operations, extracts the list of<br>
types and makes a sequence of variable declarations from a list of<br>
function parameters, respectively.  Note that, although in the dynamic<br>
semantics we include a terminating <code>return</code> statement at the<br>
end of the function body to eliminate from the analysis the case when<br>
the function does not provide an explicit return, we do not need to<br>
include such a similar <code>return</code> statement here.  That&apos;s because<br>
the <code>return</code> statements type to <code>stmt</code> anyway, and the<br>
entire code of the function body needs to type anyway.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> T<span class="token punctuation">:</span>Type F<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">(</span>Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> S <span class="token operator">=</span><span class="token operator">&gt;</span> getTypes<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>T F<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span>
               <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span> S <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>returnType<span class="token operator">&gt;</span> T <span class="token operator">&lt;</span><span class="token operator">/</span>returnType<span class="token operator">&gt;</span>
             <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span><span class="token punctuation">)</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="checking-if-main()-exists%7D">Checking if <code>main()</code> exists}</h2>
<p>Once the entire program is processed (generating appropriate tasks<br>
to type check its function bodies), we can dissolve the main<br>
<code>task</code> cell (the one holding only a <code>k</code> subcell).  Since<br>
we want to enforce that programs include a main function, we also<br>
generate a function task executing <code>main()</code> to ensure that it<br>
types (remove this task creation if you do not want your type system<br>
to reject programs without a <code>main</code> function).</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> stmt <span class="token operator">=</span><span class="token operator">&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="collecting-the-terminated-tasks">Collecting the terminated tasks</h2>
<p>Similarly, once a non-main task (i.e., one which contains a<br>
<code>tenv</code> subcells) is completed using the subsequent rules (i.e.,<br>
its <code>k</code> cell holds only the <code>block</code> or <code>stmt</code><br>
type), we can dissolve its corresponding cell.  Note that it is<br>
important to ensure that we only dissolve tasks containing a<br>
<code>tenv</code> cell with the rule below, because the main task should<br>
<code>not</code> dissolve this way!  It should do what the above rule says.<br>
In the end, there should be no task cell left in the configuration<br>
when the program correctly type checks.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> _<span class="token punctuation">:</span>BlockOrStmtType <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> _ <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Bag
</code></pre>
<h2 id="basic-values">Basic values</h2>
<p>The first three rewrite rules below reduce the primitive values to<br>
their types, as we typically do when we define type systems in <strong>K</strong>.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> _<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> _<span class="token punctuation">:</span><span class="token keyword">Bool</span> <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> _<span class="token punctuation">:</span><span class="token keyword">String</span> <span class="token operator">=</span><span class="token operator">&gt;</span> string
</code></pre>
<h2 id="variable-lookup">Variable lookup</h2>
<p>There are three cases to distinguish for variable lookup: (1) if the<br>
variable is bound in the local type environment, then look its type up<br>
there; (2) if a local environment exists and the variable is not bound<br>
in it, then look its type up in the global environment; (3) finally,<br>
if there is no local environment, meaning that we are executing the<br>
top-level pass, then look the variable&apos;s type up in the global<br>
environment, too.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>gtenv<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>gtenv<span class="token operator">&gt;</span>
    <span class="token keyword">requires</span> notBool<span class="token punctuation">(</span>X in keys<span class="token punctuation">(</span>Rho<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>gtenv<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> T <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>gtenv<span class="token operator">&gt;</span>
</code></pre>
<h2 id="increment">Increment</h2>
<p>We want the increment operation to apply to any lvalue, including<br>
array elements, not only to variables.  For that reason, we define a<br>
special context extracting the type of the argument of the increment<br>
operation only if that argument is an lvalue.  Otherwise the rewriting<br>
process gets stuck.  The operation <code>ltype</code> is defined at the<br>
end of this file, in the auxiliary operation section.  It essentially<br>
acts as a filter, getting stuck if its argument is not an lvalue and<br>
letting it reduce otherwise.  The type of the lvalue is expected to be<br>
an integer in order to be allowed to be incremented, as seen in the<br>
rule <code>++ int =&gt; int</code> below.</p>
<pre class="language-k"><code>  <span class="token keyword">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">&gt;</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token operator">++</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
</code></pre>
<h2 id="common-expression-constructs">Common expression constructs</h2>
<p>The rules below are straightforward and self-explanatory:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> int <span class="token operator">+</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> string <span class="token operator">+</span> string <span class="token operator">=</span><span class="token operator">&gt;</span> string
  <span class="token keyword">rule</span> int <span class="token operator">-</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> int <span class="token operator">*</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> int <span class="token operator">/</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> int <span class="token operator">%</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> <span class="token operator">-</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> int
  <span class="token keyword">rule</span> int <span class="token operator">&lt;</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> int <span class="token operator">&lt;=</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> int <span class="token operator">&gt;</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> int <span class="token operator">&gt;=</span> int <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">==</span> T <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">!=</span> T <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> bool <span class="token operator">&amp;&amp;</span> bool <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> bool <span class="token operator">||</span> bool <span class="token operator">=</span><span class="token operator">&gt;</span> bool
  <span class="token keyword">rule</span> <span class="token operator">!</span> bool <span class="token operator">=</span><span class="token operator">&gt;</span> bool
</code></pre>
<h2 id="array-access-and-size">Array access and size</h2>
<p>Array access requires each index to type to an integer, and the<br>
array type to be at least as deep as the number of indexes:</p>
<pre class="language-k"><code><span class="token comment">// NOTE:</span>
<span class="token comment">// We used to need parentheses in the RHS, to avoid capturing Ts as rule tag.</span>
<span class="token comment">// Let&apos;s hope that is not a problem anymore.</span>

  <span class="token keyword">rule</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>int<span class="token punctuation">,</span> Ts<span class="token punctuation">:</span>Types<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T<span class="token punctuation">[</span>Ts<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type<span class="token punctuation">[</span><span class="token punctuation">.</span>Types<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T
</code></pre>
<p><code>sizeOf</code> only needs to check that its argument is an array:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> sizeOf<span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> int
</code></pre>
<h2 id="input%2Foutput">Input/Output</h2>
<p>The read expression construct types to an integer, while print types<br>
to a statement provided that all its arguments type to integers or<br>
strings.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> int

  <span class="token keyword">rule</span> print<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type<span class="token punctuation">,</span> Ts <span class="token operator">=</span><span class="token operator">&gt;</span> Ts<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">requires</span> T <span class="token operator">==</span>K int orBool T <span class="token operator">==</span>K string
  <span class="token keyword">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
</code></pre>
<h2 id="assignment">Assignment</h2>
<p>The special context and the rule for assignment below are similar<br>
to those for increment: the LHS of the assignment must be an lvalue<br>
and, in that case, it must have the same type as the RHS, which then<br>
becomes the type of the assignment.</p>
<pre class="language-k"><code>  <span class="token keyword">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">&gt;</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _
  <span class="token keyword">rule</span> T<span class="token punctuation">:</span>Type <span class="token operator">=</span> T <span class="token operator">=</span><span class="token operator">&gt;</span> T
</code></pre>
<h2 id="function-application-and-return">Function application and return</h2>
<p>Function application requires the type of the function and the<br>
types of the passed values to be compatible.  Note that a special case<br>
is needed to handle the no-argument case:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">(</span>Ts<span class="token punctuation">:</span>Types <span class="token operator">-</span><span class="token operator">&gt;</span> T<span class="token punctuation">)</span><span class="token punctuation">(</span>Ts<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T <span class="token keyword">requires</span> Ts <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token punctuation">.</span>Types
  <span class="token keyword">rule</span> <span class="token punctuation">(</span>void <span class="token operator">-</span><span class="token operator">&gt;</span> T<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">.</span>Types<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T
</code></pre>
<p>The returned value must have the same type as the declared<br>
function return type.  If an empty return is encountered, than<br>
we should check that we are in a function (and not a thread)<br>
context, that is, a <code>return</code> cell must be available:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> return T<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>returnType<span class="token operator">&gt;</span> T <span class="token operator">&lt;</span><span class="token operator">/</span>returnType<span class="token operator">&gt;</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> return<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>returnType<span class="token operator">&gt;</span> _ <span class="token operator">&lt;</span><span class="token operator">/</span>returnType<span class="token operator">&gt;</span>
</code></pre>
<h2 id="blocks">Blocks</h2>
<p>To avoid having to recover type environments after blocks, we prefer<br>
to start a new task for block body, making sure that the new task<br>
is passed the same type environment and return cells.  The value<br>
returned by <code>return</code> statements must have the same type as<br>
stated in the <code>return</code> cell.  The <code>print</code> variadic<br>
function is allowed to only print integers and strings.  The thrown<br>
exceptions can only have integer type.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> block

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> block <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span> R <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> S <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span> R <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<h2 id="expression-statement">Expression statement</h2>
<pre class="language-k"><code>  <span class="token keyword">rule</span> _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
</code></pre>
<h2 id="conditional-and-while-loop">Conditional and <code>while</code> loop</h2>
<pre class="language-k"><code>  <span class="token keyword">rule</span> if <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> block else block <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
  <span class="token keyword">rule</span> while <span class="token punctuation">(</span>bool<span class="token punctuation">)</span> block <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
</code></pre>
<h2 id="exceptions">Exceptions</h2>
<p>We currently force the parameters of exceptions to only be integers.<br>
Moreover, for simplicity, we assume that integer exceptions can be<br>
thrown from anywhere, including from functions which do not define<br>
any try-catch block (with the currently unchecked &#x2012;also for<br>
simplicity&#x2012; expectation that the caller functions would catch those<br>
exceptions).</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> try block catch<span class="token punctuation">(</span>int X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>int X<span class="token punctuation">;</span> S<span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> try block catch<span class="token punctuation">(</span>int X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>int X<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> throw int<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
</code></pre>
<h2 id="concurrency">Concurrency</h2>
<p>Nothing special about typing the concurrency constructs, except that<br>
we do not want the spawned thread to return, so we do not include any<br>
<code>return</code> cell in the new task cell for the thread statement.<br>
Same like with the functions above, we do not check for thrown<br>
exceptions which are not caught.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> spawn S <span class="token operator">=</span><span class="token operator">&gt;</span> int <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>task<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> S <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tenv<span class="token operator">&gt;</span> Rho <span class="token operator">&lt;</span><span class="token operator">/</span>tenv<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>task<span class="token operator">&gt;</span><span class="token punctuation">)</span>
  <span class="token keyword">rule</span> join int<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
  <span class="token keyword">rule</span> acquire _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
  <span class="token keyword">rule</span> release _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
  <span class="token keyword">rule</span> rendezvous _<span class="token punctuation">:</span>Type<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> stmt

  <span class="token keyword">rule</span> _<span class="token punctuation">:</span>BlockOrStmtType _<span class="token punctuation">:</span>BlockOrStmtType <span class="token operator">=</span><span class="token operator">&gt;</span> stmt
</code></pre>
<h2 id="auxiliary-constructs">Auxiliary constructs</h2>
<p>The function <code>mkDecls</code> turns a list of parameters into a<br>
list of variable declarations.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> mkDecls<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">,</span> Ps<span class="token punctuation">:</span>Params<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T X<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<p>The <code>ltype</code> context allows only expressions which have an<br>
lvalue to evaluate.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> LValue <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Id</span>
  <span class="token keyword">rule</span> isLValue<span class="token punctuation">(</span>_<span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> LValue  <span class="token comment">// K should be able to infer this</span>
                         <span class="token comment">// if not added, then it gets stuck with an Id on k cell</span>

<span class="token comment">// Instead of the second LValue production above you can use a rule:</span>
<span class="token comment">//  rule isLValue(_:Exp[_:Exps]) =&gt; true</span>

  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> ltype<span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>
<span class="token comment">//  context ltype(HOLE:LValue)</span>
<span class="token comment">// The above context does not work due to some error, so we write instead</span>
  <span class="token keyword">context</span> ltype<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span> <span class="token keyword">requires</span> isLValue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span>
</code></pre>
<p>The function <code>getTypes</code> is the same as in SIMPLE typed dynamic.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Types <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> getTypes<span class="token punctuation">(</span>Params<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types   <span class="token comment">// I would like to not use .Types</span>
  <span class="token keyword">rule</span> getTypes<span class="token punctuation">(</span>T<span class="token punctuation">:</span>Type _<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> Ps<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> T<span class="token punctuation">,</span> getTypes<span class="token punctuation">(</span>P<span class="token punctuation">,</span>Ps<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> getTypes<span class="token punctuation">(</span><span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> void<span class="token punctuation">,</span> <span class="token punctuation">.</span>Types

<span class="token keyword">endmodule</span>
</code></pre>
<p>Go to <a href="../../../2_dynamic/simple-typed-dynamic/">Lesson 3, SIMPLE typed dynamic</a></p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
