<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1 id="simple-%E2%80%94-untyped">SIMPLE &#x2014; Untyped</h1>
<p>Author: Grigore Ro&#x219;u (<a href="mailto:grosu@illinois.edu" target="_blank" rel="noopener">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin &#x218;erb&#x103;nu&#x21B;&#x103; (<a href="mailto:traian.serbanuta@unibuc.ro" target="_blank" rel="noopener">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h2 id="abstract">Abstract</h2>
<p>This is the <strong>K</strong> semantic definition of the untyped SIMPLE language.<br>
SIMPLE is intended to be a pedagogical and research language that captures<br>
the essence of the imperative programming paradigm, extended with several<br>
features often encountered in imperative programming languages.<br>
A program consists of a set of global variable declarations and<br>
function definitions.  Like in C, function definitions cannot be<br>
nested and each program must have one function called <code>main</code>,<br>
which is invoked when the program is executed.  To make it more<br>
interesting and to highlight some of <strong>K</strong>&apos;s strengths, SIMPLE includes<br>
the following features in addition to the conventional imperative<br>
expression and statement constructs:</p>
<ul>
<li>
<p>Multidimensional arrays and array references.  An array evaluates<br>
to an array reference, which is a special value holding a location (where<br>
the elements of the array start) together with the size of the array;<br>
the elements of the array can be array references themselves (particularly<br>
when the array is multi-dimensional).  Array references are ordinary values,<br>
so they can be assigned to variables and passed/received by functions.</p>
</li>
<li>
<p>Functions and function values.  Functions can have zero or<br>
more parameters and can return abruptly using a <code>return</code> statement.<br>
SIMPLE follows a call-by-value parameter passing style, with static scoping.<br>
Function names evaluate to function abstractions, which hereby become ordinary<br>
values in the language, same like the array references.</p>
</li>
<li>
<p>Blocks with locals.  SIMPLE variables can be declared<br>
anywhere, their scope being from the place where they are declared<br>
until the end of the most nested enclosing block.</p>
</li>
<li>
<p>Input/Output.  The expression <code>read()</code> evaluates to the<br>
next value in the input buffer, and the statement <code>write(e)</code><br>
evaluates <code>e</code> and outputs its value to the output buffer.  The<br>
input and output buffers are lists of values.</p>
</li>
<li>
<p>Exceptions.  SIMPLE has parametric exceptions (the value thrown as<br>
an exception can be caught and bound).</p>
</li>
<li>
<p>Concurrency via dynamic thread creation/termination and<br>
synchronization.  One can spawn a thread to execute any statement.<br>
The spawned thread shares with its parent its environment at creation time.<br>
Threads can be synchronized via a join command which blocks the current thread<br>
until the joined thread completes, via re-entrant locks which can be acquired<br>
and released, as well as through rendezvous commands.</p>
</li>
</ul>
<p>Like in many other languages, some of SIMPLE&apos;s constructs can be<br>
desugared into a smaller set of basic constructs.  We do that at the end<br>
of the syntax module, and then we only give semantics to the core constructs.</p>
<p><strong>Note</strong>: This definition is commented slightly more than others, because it is<br>
intended to be one of the first non-trivial definitions that the new<br>
user of <strong>K</strong> sees.  We recommend the beginner user to first check the<br>
language definitions discussed in the <strong>K</strong> tutorial.</p>
<pre class="language-k"><code><span class="token keyword">module</span> SIMPLE<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> DOMAINS<span class="token operator">-</span>SYNTAX
</code></pre>
<h2 id="syntax">Syntax</h2>
<p>We start by defining the SIMPLE syntax.  The language constructs discussed<br>
above have the expected syntax and evaluation strategies.  Recall that in <strong>K</strong><br>
we annotate the syntax with appropriate strictness attributes, thus giving<br>
each language construct the desired evaluation strategy.</p>
<h2 id="identifiers">Identifiers</h2>
<p>Recall from the <strong>K</strong> tutorial that identifiers are builtin and come under the<br>
syntactic category <code>Id</code>.  The special identifier for the function<br>
<code>main</code> belongs to all programs, and plays a special role in the semantics,<br>
so we declare it explicitly.  This would not be necessary if the identifiers<br>
were all included automatically in semantic definitions, but that is not<br>
possible because of parsing reasons (e.g., <strong>K</strong> variables used to match<br>
concrete identifiers would then be ambiguously parsed as identifiers).  They<br>
are only included in the parser generated to parse programs (and used by the<br>
<code>kast</code> tool).  Consequently, we have to explicitly declare all the<br>
concrete identifiers that play a special role in the semantics, like<br>
<code>main</code> below.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> <span class="token keyword">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;main&quot;</span> <span class="token punctuation">[</span><span class="token class-name">token</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="declarations">Declarations</h2>
<p>There are two types of declarations: for variables (including arrays) and<br>
for functions.  We are going to allow declarations of the form<br>
<code>var x=10, a[10,10], y=23;</code>, which is why we allow the <code>var</code><br>
keyword to take a list of expressions.  The non-terminals used in the two<br>
productions below are defined shortly.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Decl <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;var&quot;</span> Exps <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;function&quot;</span> <span class="token keyword">Id</span> <span class="token string">&quot;(&quot;</span> Ids <span class="token string">&quot;)&quot;</span> Block
</code></pre>
<h2 id="expressions">Expressions</h2>
<p>The expression constructs below are standard.  Increment (<code>++</code>) takes<br>
an expression rather than a variable because it can also increment an array<br>
element.  Recall that the syntax we define in <strong>K</strong> is what we call <em>the syntax<br>
of the semantics</em>: while powerful enough to define non-trivial syntaxes<br>
(thanks to the underlying SDF technology that we use), we typically refrain<br>
from defining precise syntaxes, that is, ones which accept precisely the<br>
well-formed programs (that would not be possible anyway in general).  That job<br>
is deferred to type systems, which can also be defined in <strong>K</strong>.  In other words,<br>
we are not making any effort to guarantee syntactically that only variables<br>
or array elements are passed to the increment construct, we allow any<br>
expression.  Nevertheless, we will only give semantics to those, so expressions<br>
of the form <code>++5</code>, which parse (but which will be rejected by our type<br>
system in the typed version of SIMPLE later), will get stuck when executed.<br>
Arrays can be multidimensional and can hold other arrays, so their<br>
lookup operation takes a list of expressions as argument and applies to an<br>
expression (which can in particular be another array lookup), respectively.<br>
The construct <code>sizeOf</code> gives the size of an array in number of elements<br>
of its first dimension.  Note that almost all constructs are strict.  The only<br>
constructs which are not strict are the increment (since its first argument<br>
gets updated, so it cannot be evaluated), the input read which takes no<br>
arguments so strictness is irrelevant for it, the logical and and or constructs<br>
which are short-circuited, the thread spawning construct which creates a new<br>
thread executing the argument expression and return its unique identifier to<br>
the creating thread (so it cannot just evaluate its argument in place), and the<br>
assignment which is only strict in its second argument (for the same reason as<br>
the increment).</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span> <span class="token operator">|</span> <span class="token keyword">String</span> <span class="token operator">|</span> <span class="token keyword">Id</span>
               <span class="token operator">|</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>             <span class="token punctuation">[</span><span class="token class-name">bracket</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;++&quot;</span> Exp
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;[&quot;</span> Exps <span class="token string">&quot;]&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span>        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;-&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;sizeOf&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span>    <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> <span class="token string">&quot;read&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token string">&quot;)&quot;</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;*&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;/&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;%&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;+&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;-&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">non-assoc</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&lt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&lt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;&gt;=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;==&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;!=&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">,</span> <span class="token class-name">non-assoc</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token string">&quot;!&quot;</span> Exp                 <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token class-name">left</span><span class="token punctuation">:</span>
                 Exp <span class="token string">&quot;&amp;&amp;&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">|</span> Exp <span class="token string">&quot;||&quot;</span> Exp            <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">left</span><span class="token punctuation">]</span>
               <span class="token operator">&gt;</span> <span class="token string">&quot;spawn&quot;</span> Block
               <span class="token operator">&gt;</span> Exp <span class="token string">&quot;=&quot;</span> Exp             <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">right</span><span class="token punctuation">]</span>
</code></pre>
<p>We also need comma-separated lists of identifiers and of expressions.<br>
Moreover, we want them to be strict, that is, to evaluate to lists of results<br>
whenever requested (e.g., when they appear as strict arguments of<br>
the constructs above).</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Ids  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span><span class="token keyword">Id</span><span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Exp<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>          <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>  <span class="token comment">// automatically hybrid now</span>
  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Ids
  <span class="token keyword">syntax</span> Val
  <span class="token keyword">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Val<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> Bottom
  <span class="token keyword">syntax</span> Bottoms <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> List<span class="token punctuation">{</span>Bottom<span class="token punctuation">,</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">}</span>
  <span class="token keyword">syntax</span> Ids <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
</code></pre>
<h2 id="statements">Statements</h2>
<p>Most of the statement constructs are standard for imperative languages.<br>
We syntactically distinguish between empty and non-empty blocks, because we<br>
chose <code>Stmts</code> not to be a (<code>;</code>-separated) list of<br>
<code>Stmt</code>.  Variables can be declared anywhere inside a block, their scope<br>
ending with the block.  Expressions are allowed to be used for their side<br>
effects only (followed by a semicolon <code>;</code>).  Functions are allowed<br>
to abruptly return.  The exceptions are parametric, i.e., one can throw a value<br>
which is bound to the variable declared by <code>catch</code>.  Threads can be<br>
dynamically created and terminated, and can synchronize with <code>join</code>,<br>
<code>acquire</code>, <code>release</code> and <code>rendezvous</code>.  Note that the<br>
strictness attributes obey the intended evaluation strategy of the various<br>
constructs.  In particular, the if-then-else construct is strict only in its<br>
first argument (the if-then construct will be desugared into if-then-else),<br>
while the loop constructs are not strict in any arguments.  The <code>print</code><br>
statement construct is variadic, that is, it takes an arbitrary number of<br>
arguments.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Block <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;{&quot;</span> <span class="token string">&quot;}&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;{&quot;</span> Stmts <span class="token string">&quot;}&quot;</span>

  <span class="token keyword">syntax</span> Stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Decl <span class="token operator">|</span> Block
                <span class="token operator">|</span> Exp <span class="token string">&quot;;&quot;</span>                               <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block <span class="token string">&quot;else&quot;</span> Block   <span class="token punctuation">[</span><span class="token class-name">avoid</span><span class="token punctuation">,</span> <span class="token class-name">strict</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;if&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;while&quot;</span> <span class="token string">&quot;(&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;for&quot;</span> <span class="token string">&quot;(&quot;</span> Stmts Exp <span class="token string">&quot;;&quot;</span> Exp <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                      <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;return&quot;</span> <span class="token string">&quot;;&quot;</span>
                <span class="token operator">|</span> <span class="token string">&quot;print&quot;</span> <span class="token string">&quot;(&quot;</span> Exps <span class="token string">&quot;)&quot;</span> <span class="token string">&quot;;&quot;</span>              <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
<span class="token comment">// NOTE: print strict allows non-deterministic evaluation of its arguments</span>
<span class="token comment">// Either keep like this but document, or otherwise make Exps seqstrict.</span>
<span class="token comment">// Of define and use a different expression list here, which is seqstrict.</span>
                <span class="token operator">|</span> <span class="token string">&quot;try&quot;</span> Block <span class="token string">&quot;catch&quot;</span> <span class="token string">&quot;(&quot;</span> <span class="token keyword">Id</span> <span class="token string">&quot;)&quot;</span> Block
                <span class="token operator">|</span> <span class="token string">&quot;throw&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                       <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;join&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                        <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;acquire&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;release&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                     <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
                <span class="token operator">|</span> <span class="token string">&quot;rendezvous&quot;</span> Exp <span class="token string">&quot;;&quot;</span>                  <span class="token punctuation">[</span><span class="token class-name">strict</span><span class="token punctuation">]</span>
</code></pre>
<p>The reason we allow <code>Stmts</code> as the first argument of <code>for</code><br>
instead of <code>Stmt</code> is because we want to allow more than one statement<br>
to be executed when the loop is initialized.  Also, as seens shorly, macros<br>
may expand one statement into more statements; for example, an initialized<br>
variable declaration statement <code>var x=0;</code> desugars into two statements,<br>
namely <code>var x; x=0;</code>, so if we use <code>Stmt</code> instead of <code>Stmts</code><br>
in the production of <code>for</code> above then we risk that the macro expansion<br>
of statement <code>var x=0;</code> happens before the macro expansion of <code>for</code>,<br>
also shown below, in which case the latter would not apply anymore because<br>
of syntactic mismatch.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Stmt
                 <span class="token operator">|</span> Stmts Stmts                          <span class="token punctuation">[</span><span class="token class-name">right</span><span class="token punctuation">]</span>

<span class="token comment">// I wish I were able to write the following instead, but confuses the parser.</span>
<span class="token comment">//</span>
<span class="token comment">// syntax Stmts ::= List{Stmt,&quot;&quot;}</span>
<span class="token comment">// syntax Top ::= Stmt | &quot;function&quot; Id &quot;(&quot; Ids &quot;)&quot; Block</span>
<span class="token comment">// syntax Pgm ::= List{Top,&quot;&quot;}</span>
<span class="token comment">//</span>
<span class="token comment">// With that, I could have also eliminated the empty block</span>
</code></pre>
<h2 id="desugared-syntax">Desugared Syntax</h2>
<p>This part desugars some of SIMPLE&apos;s language constructs into core ones.<br>
We only want to give semantics to core constructs, so we get rid of the<br>
derived ones before we start the semantics.  All desugaring macros below are<br>
straightforward.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=</span><span class="token operator">&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S else <span class="token punctuation">{</span><span class="token punctuation">}</span>                                 <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span>S<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>S Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> for<span class="token punctuation">(</span>Start Cond<span class="token punctuation">;</span> Step<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>Start while <span class="token punctuation">(</span>Cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>Step<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>     <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> var E1<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> E2<span class="token punctuation">:</span>Exp<span class="token punctuation">,</span> Es<span class="token punctuation">:</span>Exps<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> var E1<span class="token punctuation">;</span> var E2<span class="token punctuation">,</span> Es<span class="token punctuation">;</span>          <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token operator">-</span>rec<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> var X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span> E<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> var X<span class="token punctuation">;</span> X <span class="token operator">=</span> E<span class="token punctuation">;</span>                               <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</code></pre>
<p>For the semantics, we can therefore assume from now on that each<br>
conditional has both branches, that there are only <code>while</code> loops, and<br>
that each variable is declared alone and without any initialization as part of<br>
the declaration.</p>
<pre class="language-k"><code><span class="token keyword">endmodule</span>


<span class="token keyword">module</span> SIMPLE<span class="token operator">-</span>UNTYPED
  <span class="token keyword">imports</span> SIMPLE<span class="token operator">-</span>UNTYPED<span class="token operator">-</span>SYNTAX
  <span class="token keyword">imports</span> DOMAINS
</code></pre>
<h2 id="basic-semantic-infrastructure">Basic Semantic Infrastructure</h2>
<p>Before one starts adding semantic rules to a <strong>K</strong> definition, one needs to<br>
define the basic semantic infrastructure consisting of definitions for<br>
<code>values</code> and <code>configuration</code>.  As discussed in the definitions<br>
in the <strong>K</strong> tutorial, the values are needed to know when to stop applying<br>
the heating rules and when to start applying the cooling rules corresponding<br>
to strictness or context declarations.  The configuration serves as a backbone<br>
for the process of configuration abstraction which allows users to only<br>
mention the relevant cells in each semantic rule, the rest of the configuration<br>
context being inferred automatically.  Although in some cases the configuration<br>
could be automatically inferred from the rules, we believe that it is very<br>
useful for language designers/semanticists to actually think of and design<br>
their configuration explicitly, so the current implementation of <strong>K</strong> requires<br>
one to define it.</p>
<h2 id="values">Values</h2>
<p>We here define the values of the language that the various fragments of<br>
programs evaluate to.  First, integers and Booleans are values.  As discussed,<br>
arrays evaluate to special array reference values holding (1) a location from<br>
where the array&apos;s elements are contiguously allocated in the store, and<br>
(2) the size of the array.  Functions evaluate to function values as<br>
&#x3BB;-abstractions (we do not need to evaluate functions to closures<br>
because each function is executed in the fixed global environment and<br>
function definitions cannot be nested).  Like in IMP and other<br>
languages, we finally tell the tool that values are <strong>K</strong> results.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token operator">|</span> <span class="token keyword">Bool</span> <span class="token operator">|</span> <span class="token keyword">String</span>
               <span class="token operator">|</span> array<span class="token punctuation">(</span><span class="token keyword">Int</span><span class="token punctuation">,</span><span class="token keyword">Int</span><span class="token punctuation">)</span>
               <span class="token operator">|</span> lambda<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Stmt<span class="token punctuation">)</span>
  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
  <span class="token keyword">syntax</span> Exps <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Vals
  <span class="token keyword">syntax</span> Vals <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Bottoms
  <span class="token keyword">syntax</span> KResult <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> Val
                   <span class="token operator">|</span> Vals  <span class="token comment">// TODO: should not need this</span>
</code></pre>
<p>The inclusion of values in expressions follows the methodology of<br>
syntactic definitions (like, e.g., in SOS): extend the syntax of the language<br>
to encompass all values and additional constructs needed to give semantics.<br>
In addition to that, it allows us to write the semantic rules using the<br>
original syntax of the language, and to parse them with the same (now extended<br>
with additional values) parser.  If writing the semantics directly on the <strong>K</strong><br>
AST, using the associated labels instead of the syntactic constructs, then one<br>
would not need to include values in expressions.</p>
<h2 id="configuration">Configuration</h2>
<p>The <strong>K</strong> configuration of SIMPLE consists of a top level cell, <code>T</code>,<br>
holding a <code>threads</code> cell, a global environment map cell <code>genv</code><br>
mapping the global variables and function names to their locations, a shared<br>
store map cell <code>store</code> mapping each location to some value, a set cell<br>
<code>busy</code> holding the locks which have been acquired but not yet released<br>
by threads, a set cell <code>terminated</code> holding the unique identifiers of<br>
the threads which already terminated (needed for <code>join</code>), <code>input</code><br>
and <code>output</code> list cells, and a <code>nextLoc</code> cell holding a natural<br>
number indicating the next available location.  Unlike in the small languages<br>
in the <strong>K</strong> tutorial, where we used the fresh predicate to generate fresh<br>
locations, in larger languages, like SIMPLE, we prefer to explicitly manage<br>
memory.  The location counter in <code>nextLoc</code> models an actual physical<br>
location in the store; for simplicity, we assume arbitrarily large memory and<br>
no garbage collection.  The <code>threads</code> cell contains one <code>thread</code><br>
cell for each existing thread in the program.  Note that the thread cell has<br>
multiplicity <code>*</code>, which means that at any given moment there could be zero,<br>
one or more <code>thread</code> cells.  Each <code>thread</code> cell contains a<br>
computation cell <code>k</code>, a <code>control</code> cell holding the various<br>
control structures needed to jump to certain points of interest in the program<br>
execution, a local environment map cell <code>env</code> mapping the thread local<br>
variables to locations in the store, and finally a <code>holds</code> map cell<br>
indicating what locks have been acquired by the thread and not released so far<br>
and how many times (SIMPLE&apos;s locks are re-entrant).  The <code>control</code> cell<br>
currently contains only two subcells, a function stack <code>fstack</code> which<br>
is a list and an exception stack <code>xstack</code> which is also a list.<br>
One can add more control structures in the <code>control</code> cell, such as a<br>
stack for break/continue of loops, etc., if the language is extended with more<br>
control-changing constructs.  Note that all cells except for <code>k</code> are<br>
also initialized, in that they contain a ground term of their corresponding<br>
sort.  The <code>k</code> cell is initialized with the program that will be passed<br>
to the <strong>K</strong> tool, as indicated by the <code>$PGM</code> variable, followed by the<br>
<code>execute</code> task (defined shortly).</p>
<pre class="language-k"><code>  <span class="token comment">// the syntax declarations below are required because the sorts are</span>
  <span class="token comment">// referenced directly by a production and, because of the way KIL to KORE</span>
  <span class="token comment">// is implemented, the configuration syntax is not available yet</span>
  <span class="token comment">// should simply work once KIL is removed completely</span>
  <span class="token comment">// check other definitions for this hack as well</span>

  <span class="token keyword">syntax</span> ControlCell
  <span class="token keyword">syntax</span> ControlCellFragment

  <span class="token keyword">configuration</span> <span class="token operator">&lt;</span>T color<span class="token operator">=</span><span class="token string">&quot;red&quot;</span><span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>threads color<span class="token operator">=</span><span class="token string">&quot;orange&quot;</span><span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>thread multiplicity<span class="token operator">=</span><span class="token string">&quot;*&quot;</span> color<span class="token operator">=</span><span class="token string">&quot;yellow&quot;</span><span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>k color<span class="token operator">=</span><span class="token string">&quot;green&quot;</span><span class="token operator">&gt;</span> $PGM<span class="token punctuation">:</span>Stmts <span class="token operator">~</span><span class="token operator">&gt;</span> execute <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token operator">&lt;</span>control color<span class="token operator">=</span><span class="token string">&quot;cyan&quot;</span><span class="token operator">&gt;</span>
                        <span class="token operator">&lt;</span>fstack color<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">&lt;</span><span class="token operator">/</span>fstack<span class="token operator">&gt;</span>
                        <span class="token operator">&lt;</span>xstack color<span class="token operator">=</span><span class="token string">&quot;purple&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">&lt;</span><span class="token operator">/</span>xstack<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span><span class="token operator">/</span>control<span class="token operator">&gt;</span>
                    <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                      <span class="token operator">&lt;</span>env color<span class="token operator">=</span><span class="token string">&quot;violet&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>holds color<span class="token operator">=</span><span class="token string">&quot;black&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>holds<span class="token operator">&gt;</span>
                      <span class="token operator">&lt;</span>id color<span class="token operator">=</span><span class="token string">&quot;pink&quot;</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span><span class="token operator">/</span>threads<span class="token operator">&gt;</span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token operator">&lt;</span>genv color<span class="token operator">=</span><span class="token string">&quot;pink&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>genv<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>store color<span class="token operator">=</span><span class="token string">&quot;white&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>busy color<span class="token operator">=</span><span class="token string">&quot;cyan&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Set <span class="token operator">&lt;</span><span class="token operator">/</span>busy<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>terminated color<span class="token operator">=</span><span class="token string">&quot;red&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Set <span class="token operator">&lt;</span><span class="token operator">/</span>terminated<span class="token operator">&gt;</span>
                <span class="token comment">//&lt;br/&gt; // TODO(KORE): support latex annotations #1799</span>
                  <span class="token operator">&lt;</span>input color<span class="token operator">=</span><span class="token string">&quot;magenta&quot;</span> stream<span class="token operator">=</span><span class="token string">&quot;stdin&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">&lt;</span><span class="token operator">/</span>input<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>output color<span class="token operator">=</span><span class="token string">&quot;brown&quot;</span> stream<span class="token operator">=</span><span class="token string">&quot;stdout&quot;</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">&lt;</span><span class="token operator">/</span>output<span class="token operator">&gt;</span>
                  <span class="token operator">&lt;</span>nextLoc color<span class="token operator">=</span><span class="token string">&quot;gray&quot;</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span><span class="token operator">/</span>nextLoc<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>T<span class="token operator">&gt;</span>
</code></pre>
<h2 id="declarations-and-initialization">Declarations and Initialization</h2>
<p>We start by defining the semantics of declarations (for variables,<br>
arrays and functions).</p>
<h2 id="variable-declaration">Variable Declaration</h2>
<p>The SIMPLE syntax was desugared above so that each variable is<br>
declared alone and its initialization is done as a separate statement.<br>
The semantic rule below matches resulting variable declarations of the<br>
form <code>var X;</code> on top of the <code>k</code> cell<br>
(indeed, note that the <code>k</code> cell is complete, or round, to the<br>
left, and is torn, or ruptured, to the right), allocates a fresh<br>
location <code>L</code> in the store which is initialized with a special value<br>
<code>&#x22A5;</code> (indeed, the unit <code>.</code>, or nothing, is matched anywhere<br>
in the map &#x2012;note the tears at both sides&#x2012; and replaced with the<br>
mapping <code>L &#x21A6; &#x22A5;</code>), and binds <code>X</code> to <code>L</code> in the local<br>
environment shadowing previous declarations of <code>X</code>, if any.<br>
This possible shadowing of <code>X</code> requires us to therefore update the<br>
entire environment map, which is expensive and can significantly slow<br>
down the execution of larger programs.  On the other hand, since we know<br>
that <code>L</code> is not already bound in the store, we simply add the binding<br>
<code>L &#x21A6; &#x22A5;</code> to the store, thus avoiding a potentially complete<br>
traversal of the the store map in order to update it.  We prefer the approach<br>
used for updating the store whenever possible, because, in addition to being<br>
faster, it offers more true concurrency than the latter; indeed, according<br>
to the concurrent semantics of <code>K</code>, the store is not frozen while<br>
<code>L &#x21A6; &#x22A5;</code> is added to it, while the environment is frozen during the<br>
update operation <code>Env[L/X]</code>.  The variable declaration command is<br>
also removed from the top of the computation cell and the fresh location<br>
counter is incremented.  The undefined symbol <code>&#x22A5;</code> added in the store<br>
is of sort <code>KItem</code>, instead of <code>Val</code>, on purpose; this way, the<br>
store lookup rules will get stuck when one attempts to lookup an<br>
uninitialized location.  All the above happen in one transactional step,<br>
with the rule below.  Note also how configuration abstraction allows us to<br>
only mention the needed cells; indeed, as the configuration above states,<br>
the <code>k</code> and <code>env</code> cells are actually located within a<br>
<code>thread</code> cell within the <code>threads</code> cell, but one needs<br>
not mention these: the configuration context of the rule is<br>
automatically transformed to match the declared configuration<br>
structure.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;undefined&quot;</span>  <span class="token punctuation">[</span><span class="token class-name">latex</span><span class="token punctuation">(</span>\bot<span class="token punctuation">)</span><span class="token punctuation">]</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> var X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">=</span><span class="token operator">&gt;</span> Env<span class="token punctuation">[</span>X <span class="token operator">&lt;</span><span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>nextLoc<span class="token operator">&gt;</span> L <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">/</span>nextLoc<span class="token operator">&gt;</span>
</code></pre>
<h2 id="array-declaration">Array Declaration</h2>
<p>The <strong>K</strong> semantics of the uni-dimensional array declaration is somehow similar<br>
to the above declaration of ordinary variables.  First, note the<br>
context declaration below, which requests the evaluation of the array<br>
dimension.  Once evaluated, say to a natural number <code>N</code>, then<br>
<code>N +Int 1</code> locations are allocated in the store for<br>
an array of size <code>N</code>, the additional location (chosen to be the first<br>
one allocated) holding the array reference value.  The array reference<br>
value <code>array(L,N)</code> states that the array has size <code>N</code> and its<br>
elements are located contiguously in the store starting with location<br>
<code>L</code>.  The operation <code>L &#x2026; L&apos; &#x21A6; V</code>, defined at the end of this<br>
file in the auxiliary operation section, initializes each location in<br>
the list <code>L &#x2026; L&apos;</code> to <code>V</code>.  Note that, since the dimensions of<br>
array declarations can be arbitrary expressions, this virtually means<br>
that we can dynamically allocate memory in SIMPLE by means of array<br>
declarations.</p>
<pre class="language-k"><code>  <span class="token keyword">context</span> var _<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">[</span>HOLE<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> var X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">=</span><span class="token operator">&gt;</span> Env<span class="token punctuation">[</span>X <span class="token operator">&lt;</span><span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> array<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>
                          <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword">Int</span> N<span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> undefined <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>nextLoc<span class="token operator">&gt;</span> L <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span> <span class="token operator">+</span><span class="token keyword">Int</span> N <span class="token operator">&lt;</span><span class="token operator">/</span>nextLoc<span class="token operator">&gt;</span>
    <span class="token keyword">requires</span> N <span class="token operator">&gt;=</span><span class="token keyword">Int</span> <span class="token number">0</span>
</code></pre>
<p>SIMPLE allows multi-dimensional arrays.  For semantic simplicity, we<br>
desugar them all into uni-dimensional arrays by code transformation.<br>
This way, we only need to give semantics to uni-dimensional arrays.<br>
First, note that the context rule above actually evaluates all the array<br>
dimensions (that&apos;s why we defined the expression lists strict!):<br>
Upon evaluating the array dimensions, the code generation rule below<br>
desugars multi-dimensional array declaration to uni-dimensional declarations.<br>
To this aim, we introduce two special unique variable identifiers,<br>
<code>$1</code> and <code>$2</code>.  The first variable, <code>$1</code>, iterates<br>
through and initializes each element of the first dimension with an array<br>
of the remaining dimensions, declared as variable <code>$2</code>:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> <span class="token keyword">Id</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;$1&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;$2&quot;</span>
  <span class="token keyword">rule</span> var X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">=</span><span class="token operator">&gt;</span> var X<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
         for<span class="token punctuation">(</span>var $<span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> $<span class="token number">1</span> <span class="token operator">&lt;=</span> N1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>$<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           var $<span class="token number">2</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span><span class="token punctuation">;</span>
           X<span class="token punctuation">[</span>$<span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> $<span class="token number">2</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<p>Ideally, one would like to perform syntactic desugarings like the one<br>
above before the actual semantics.  Unfortunately, that was not possible in<br>
this case because the dimension expressions of the multi-dimensional array need<br>
to be evaluated first.  Indeed, the desugaring rule above does not work if the<br>
dimensions of the declared array are arbitrary expressions, because they can<br>
have side effects (e.g., <code>a[++x,++x]</code>) and those side effects would be<br>
propagated each time the expression is evaluated in the desugaring code (note<br>
that both the loop condition and the nested multi-dimensional declaration<br>
would need to evaluate the expressions given as array dimensions).</p>
<h2 id="function-declaration">Function declaration</h2>
<p>Functions are evaluated to &#x3BB;-abstractions and stored like any other<br>
values in the store.  A binding is added into the environment for the function<br>
name to the location holding its body.  Similarly to the C language, SIMPLE<br>
only allows function declarations at the top level of the program.  More<br>
precisely, the subsequent semantics of SIMPLE only works well when one<br>
respects this requirement.  Indeed, the simplistic context-free parser<br>
generated by the grammar above is more generous than we may want, in that it<br>
allows function declarations anywhere any declaration is allowed, including<br>
inside arbitrary blocks.  However, as the rule below shows, we are <code>not</code><br>
storing the declaration environment with the &#x3BB;-abstraction value as<br>
closures do.  Instead, as seen shortly, we switch to the global environment<br>
whenever functions are invoked, which is consistent with our requirement that<br>
functions should only be declared at the top.  Thus, if one declares local<br>
functions, then one may see unexpected behaviors (e.g., when one shadows a<br>
global variable before declaring a local function).  The type checker of<br>
SIMPLE, also defined in <strong>K</strong> (see <code>examples/simple/typed/static</code>),<br>
discards programs which do not respect this requirement.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> function F<span class="token punctuation">(</span>Xs<span class="token punctuation">)</span> S <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">=</span><span class="token operator">&gt;</span> Env<span class="token punctuation">[</span>F <span class="token operator">&lt;</span><span class="token operator">-</span> L<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> lambda<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span> S<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>nextLoc<span class="token operator">&gt;</span> L <span class="token operator">=</span><span class="token operator">&gt;</span> L <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">/</span>nextLoc<span class="token operator">&gt;</span>
</code></pre>
<p>When we are done with the first pass (pre-processing), the computation<br>
cell <code>k</code> contains only the token <code>execute</code> (see the configuration<br>
declaration above, where the computation item <code>execute</code> was placed<br>
right after the program in the <code>k</code> cell of the initial configuration)<br>
and the cell <code>genv</code> is empty.  In this case, we have to call<br>
<code>main()</code> and to initialize the global environment by transferring the<br>
contents of the local environment into it.  We prefer to do it this way, as<br>
opposed to processing all the top level declarations directly within the global<br>
environment, because we want to avoid duplication of semantics: the syntax of<br>
the global declarations is identical to that of their corresponding local<br>
declarations, so the semantics of the latter suffices provided that we copy<br>
the local environment into the global one once we are done with the<br>
pre-processing.  We want this separate pre-processing step precisely because<br>
we want to create the global environment.  All (top-level) functions end up<br>
having their names bound in the global environment and, as seen below, they<br>
are executed in that same global environment; all these mean, in particular,<br>
that the functions &quot;see&quot; each other, allowing for mutual recursion, etc.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;execute&quot;</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> execute <span class="token operator">=</span><span class="token operator">&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">.</span>Exps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>genv<span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>genv<span class="token operator">&gt;</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="expressions-1">Expressions</h2>
<p>We next define the <strong>K</strong> semantics of all the expression constructs.</p>
<h2 id="variable-lookup">Variable lookup</h2>
<p>When a variable <code>X</code> is the first computational task, and <code>X</code> is bound to some<br>
location <code>L</code> in the environment, and <code>L</code> is mapped to some value <code>V</code> in the<br>
store, then we rewrite <code>X</code> into <code>V</code>:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> L <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>lookup<span class="token punctuation">]</span>
</code></pre>
<p>Note that the rule above excludes reading <code>&#x22A5;</code>, because <code>&#x22A5;</code> is not<br>
a value and <code>V</code> is checked at runtime to be a value.</p>
<h2 id="variable%2Farray-increment">Variable/Array increment</h2>
<p>This is tricky, because we want to allow both <code>++x</code> and <code>++a[5]</code>.<br>
Therefore, we need to extract the lvalue of the expression to increment.<br>
To do that, we state that the expression to increment should be wrapped<br>
by the auxiliary <code>lvalue</code> operation and then evaluated.  The semantics<br>
of this auxiliary operation is defined at the end of this file.  For now, all<br>
we need to know is that it takes an expression and evaluates to a location<br>
value.  Location values, also defined at the end of the file, are integers<br>
wrapped with the operation <code>loc</code>, to distinguish them from ordinary<br>
integers.</p>
<pre class="language-k"><code>  <span class="token keyword">context</span> <span class="token operator">++</span><span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token operator">++</span>loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>I <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>increment<span class="token punctuation">]</span>
</code></pre>
<h2 id="arithmetic-operators">Arithmetic operators</h2>
<p>There is nothing special about the following rules.  They rewrite the<br>
language constructs to their library counterparts when their arguments<br>
become values of expected sorts:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> I1 <span class="token operator">+</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">+</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> Str1 <span class="token operator">+</span> Str2 <span class="token operator">=</span><span class="token operator">&gt;</span> Str1 <span class="token operator">+</span><span class="token keyword">String</span> Str2
  <span class="token keyword">rule</span> I1 <span class="token operator">-</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">-</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">*</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">*</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">/</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">/</span><span class="token keyword">Int</span> I2 <span class="token keyword">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword">rule</span> I1 <span class="token operator">%</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">%</span><span class="token keyword">Int</span> I2 <span class="token keyword">requires</span> I2 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K <span class="token number">0</span>
  <span class="token keyword">rule</span> <span class="token operator">-</span> I <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token keyword">Int</span> I
  <span class="token keyword">rule</span> I1 <span class="token operator">&lt;</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&lt;</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">&lt;=</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&lt;=</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">&gt;</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&gt;</span><span class="token keyword">Int</span> I2
  <span class="token keyword">rule</span> I1 <span class="token operator">&gt;=</span> I2 <span class="token operator">=</span><span class="token operator">&gt;</span> I1 <span class="token operator">&gt;=</span><span class="token keyword">Int</span> I2
</code></pre>
<p>The equality and inequality constructs reduce to syntactic comparison<br>
of the two argument values (which is what the equality on <code>K</code> terms does).</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">==</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V1 <span class="token operator">==</span>K V2
  <span class="token keyword">rule</span> V1<span class="token punctuation">:</span>Val <span class="token operator">!=</span> V2<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V1 <span class="token operator">=</span><span class="token operator">/</span><span class="token operator">=</span>K V2
</code></pre>
<p>The logical negation is clear, but the logical conjunction and disjunction<br>
are short-circuited:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">!</span> T <span class="token operator">=</span><span class="token operator">&gt;</span> notBool<span class="token punctuation">(</span>T<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token boolean">true</span>  <span class="token operator">&amp;&amp;</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> E
  <span class="token keyword">rule</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>
  <span class="token keyword">rule</span> <span class="token boolean">true</span>  <span class="token operator">||</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
  <span class="token keyword">rule</span> <span class="token boolean">false</span> <span class="token operator">||</span> E <span class="token operator">=</span><span class="token operator">&gt;</span> E
</code></pre>
<h2 id="array-lookup">Array lookup</h2>
<p>Untyped SIMPLE does not check array bounds (the dynamically typed version of<br>
it, in <code>examples/simple/typed/dynamic</code>, does check for array out of<br>
bounds).  The first rule below desugars the multi-dimensional array access to<br>
uni-dimensional array access; recall that the array access operation was<br>
declared strict, so all sub-expressions involved are already values at this<br>
stage.  The second rule rewrites the array access to a lookup operation at a<br>
precise location; we prefer to do it this way to avoid locking the store.<br>
The semantics of the auxiliary <code>lookup</code> operation is straightforward,<br>
and is defined at the end of the file.</p>
<pre class="language-k"><code><span class="token comment">// The [anywhere] feature is underused, because it would only be used</span>
<span class="token comment">// at the top of the computation or inside the lvalue wrapper. So it</span>
<span class="token comment">// may not be worth, or we may need to come up with a special notation</span>
<span class="token comment">// allowing us to enumerate contexts for [anywhere] rules.</span>
  <span class="token keyword">rule</span> V<span class="token punctuation">:</span>Val<span class="token punctuation">[</span>N1<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">,</span> N2<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> V<span class="token punctuation">[</span>N1<span class="token punctuation">]</span><span class="token punctuation">[</span>N2<span class="token punctuation">,</span> Vs<span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">,</span> anywhere<span class="token punctuation">]</span>

  <span class="token keyword">rule</span> array<span class="token punctuation">(</span>L<span class="token punctuation">,</span>_<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> lookup<span class="token punctuation">(</span>L <span class="token operator">+</span><span class="token keyword">Int</span> N<span class="token punctuation">)</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">,</span> anywhere<span class="token punctuation">]</span>
</code></pre>
<h2 id="size-of-an-array">Size of an array</h2>
<p>The size of the array is stored in the array reference value, and the<br>
<code>sizeOf</code> construct was declared strict, so:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> sizeOf<span class="token punctuation">(</span>array<span class="token punctuation">(</span>_<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> N
</code></pre>
<h2 id="function-call">Function call</h2>
<p>Function application was strict in both its arguments, so we can<br>
assume that both the function and its arguments are evaluated to<br>
values (the former expected to be a &#x3BB;-abstraction).  The first<br>
rule below matches a well-formed function application on top of the<br>
computation and performs the following steps atomically: it switches<br>
to the function body followed by <code>return;</code> (for the case in<br>
which the function does not use an explicit return statement); it<br>
pushes the remaining computation, the current environment, and the<br>
current control data onto the function stack (the remaining<br>
computation can thus also be discarded from the computation cell,<br>
because an unavoidable subsequent <code>return</code> statement &#x2012;see<br>
above&#x2012; will always recover it from the stack); it switches the<br>
current environment (which is being pushed on the function stack) to<br>
the global environment, which is where the free variables in the<br>
function body should be looked up; it binds the formal parameters to<br>
fresh locations in the new environment, and stores the actual<br>
arguments to those locations in the store (this latter step is easily<br>
done by reducing the problem to variable declarations, whose semantics<br>
we have already defined; the auxiliary operation <code>mkDecls</code> is<br>
defined at the end of the file).  The second rule pops the<br>
computation, the environment and the control data from the function<br>
stack when a <code>return</code> statement is encountered as the next<br>
computational task, passing the returned value to the popped<br>
computation (the popped computation was the context in which the<br>
returning function was called).  Note that the pushing/popping of the<br>
control data is crucial.  Without it, one may have a function that<br>
contains an exception block with a return statement inside, which<br>
would put the <code>xstack</code> cell in an inconsistent state (since the<br>
exception block modifies it, but that modification should be<br>
irrelevant once the function returns).  We add an artificial<br>
<code>nothing</code> value to the language, which is returned by the<br>
nulary <code>return;</code> statements.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span>  <span class="token punctuation">(</span>Map<span class="token punctuation">,</span>K<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> lambda<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">(</span>Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> K <span class="token operator">=</span><span class="token operator">&gt;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span> S return<span class="token punctuation">;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>control<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>fstack<span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">=</span><span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>fstack<span class="token operator">&gt;</span>
         C
       <span class="token operator">&lt;</span><span class="token operator">/</span>control<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">=</span><span class="token operator">&gt;</span> GEnv <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>genv<span class="token operator">&gt;</span> GEnv <span class="token operator">&lt;</span><span class="token operator">/</span>genv<span class="token operator">&gt;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> return<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">~</span><span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token operator">~</span><span class="token operator">&gt;</span> K <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>control<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>fstack<span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>Env<span class="token punctuation">,</span>K<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>fstack<span class="token operator">&gt;</span>
         <span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">&gt;</span> C<span class="token punctuation">)</span>
       <span class="token operator">&lt;</span><span class="token operator">/</span>control<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>

  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;nothing&quot;</span>
  <span class="token keyword">rule</span> return<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> return nothing<span class="token punctuation">;</span>   <span class="token punctuation">[</span><span class="token class-name">macro</span><span class="token punctuation">]</span>
</code></pre>
<p>Like for division-by-zero, it is left unspecified what happens<br>
when the <code>nothing</code> value is used in domain calculations.  For<br>
example, from the the perspective of the language semantics,<br>
<code>7 +Int nothing</code> can evaluate to anything, or<br>
may not evaluate at all (be undefined).  If one wants to make sure that<br>
such artificial values are never misused, then one needs to define a static<br>
checker (also using <strong>K</strong>, like our the type checker in<br>
<code>examples/simple/typed/static</code>) and reject programs that do.<br>
Note that, unlike the undefined symbol <code>&#x22A5;</code> which had the sort <code>K</code><br>
instead of <code>Val</code>, we defined <code>nothing</code> to be a value.  That<br>
is because, as explained above, we do not want the program to get<br>
stuck when nothing is returned by a function.  Instead, we want the<br>
behavior to be unspecified; in particular, if one is careful to never<br>
use the returned value in domain computation, like it happens when we<br>
call a function for its side effects (e.g., with a statement of the<br>
form <code>f(x);</code>), then the program does not get stuck.</p>
<h2 id="read">Read</h2>
<p>The <code>read()</code> expression construct simply evaluates to the next<br>
input value, at the same time discarding the input value from the<br>
<code>in</code> cell.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> I <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>input<span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span>I<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>input<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>read<span class="token punctuation">]</span>
</code></pre>
<h2 id="assignment">Assignment</h2>
<p>In SIMPLE, like in C, assignments are expression constructs and not statement<br>
constructs.  To make it a statement all one needs to do is to follow it by a<br>
semi-colon <code>;</code> (see the semantics for expression statements below).<br>
Like for the increment, we want to allow assignments not only to variables but<br>
also to array elements, e.g., <code>e1[e2] = e3</code> where <code>e1</code> evaluates<br>
to an array reference, <code>e2</code> to a natural number, and <code>e3</code> to any<br>
value.  Thus, we first compute the lvalue of the left-hand-side expression<br>
that appears in an assignment, and then we do the actual assignment to the<br>
resulting location:</p>
<pre class="language-k"><code>  <span class="token keyword">context</span> <span class="token punctuation">(</span>HOLE <span class="token operator">=</span><span class="token operator">&gt;</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> _

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span> V<span class="token punctuation">:</span>Val <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">&gt;</span> V<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span>assignment<span class="token punctuation">]</span>
</code></pre>
<h2 id="statements-1">Statements</h2>
<p>We next define the <strong>K</strong> semantics of statements.</p>
<h2 id="blocks">Blocks</h2>
<p>Empty blocks are simply discarded, as shown in the first rule below.<br>
For non-empty blocks, we schedule the enclosed statement but we have to<br>
make sure the environment is recovered after the enclosed statement executes.<br>
Recall that we allow local variable declarations, whose scope is the block<br>
enclosing them.  That is the reason for which we have to recover the<br>
environment after the block.  This allows us to have a very simple semantics<br>
for variable declarations, as we did above.  One can make the two rules below<br>
computational if one wants them to count as computational steps.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token punctuation">{</span> S <span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> S <span class="token operator">~</span><span class="token operator">&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<p>The basic definition of environment recovery is straightforward and<br>
given in the section on auxiliary constructs at the end of the file.</p>
<p>There are two common alternatives to the above semantics of blocks.<br>
One is to keep track of the variables which are declared in the block and only<br>
recover those at the end of the block.  This way one does more work for<br>
variable declarations but conceptually less work for environment recovery; we<br>
say <code>conceptually</code> because it is not clear that it is indeed the case that<br>
one does less work when AC matching is involved.  The other alternative is to<br>
work with a stack of environments instead of a flat environment, and push the<br>
current environment when entering a block and pop it when exiting it.  This<br>
way, one does more work when accessing variables (since one has to search the<br>
variable in the environment stack in a top-down manner), but on the other hand<br>
uses smaller environments and the definition gets closer to an implementation.<br>
Based on experience with dozens of language semantics and other <strong>K</strong> definitions,<br>
we have found that our approach above is the best trade-off between elegance<br>
and efficiency (especially since rewrite engines have built-in techniques to<br>
lazily copy terms, by need, thus not creating unnecessary copies),<br>
so it is the one that we follow in general.</p>
<h2 id="sequential-composition">Sequential composition</h2>
<p>Sequential composition is desugared into <strong>K</strong>&apos;s builtin sequentialization<br>
operation (recall that, like in C, the semi-colon <code>;</code> is not a<br>
statement separator in SIMPLE &#x2014; it is either a statement terminator or a<br>
construct for a statement from an expression).  The rule below is<br>
structural, so it does not count as a computational step.  One can make it<br>
computational if one wants it to count as a step.  Note that <strong>K</strong> allows<br>
to define the semantics of SIMPLE in such a way that statements eventually<br>
dissolve from the top of the computation when they are completed; this is in<br>
sharp contrast to (artificially) <code>evaluating</code> them to a special<br>
<code>skip</code> statement value and then getting rid of that special value, as<br>
it is the case in other semantic approaches (where everything must evaluate<br>
to something).  This means that once <code>S&#x2081;</code> completes in the rule below, <code>S&#x2082;</code><br>
becomes automatically the next computation item without any additional<br>
(explicit or implicit) rules.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> S1<span class="token punctuation">:</span>Stmts S2<span class="token punctuation">:</span>Stmts <span class="token operator">=</span><span class="token operator">&gt;</span> S1 <span class="token operator">~</span><span class="token operator">&gt;</span> S2  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<p>A subtle aspect of the rule above is that <code>S&#x2081;</code> is declared to have sort<br>
<code>Stmts</code> and not <code>Stmt</code>.  That is because desugaring macros can indeed<br>
produce left associative sequential composition of statements.  For example,<br>
the code <code>var x=0; x=1;</code> is desugared to<br>
<code>(var x; x=0;) x=1;</code>, so although originally the first term of<br>
the sequential composition had sort <code>Stmt</code>, after desugaring it became<br>
of sort <code>Stmts</code>.  Note that the attribute <code>[right]</code> associated<br>
to the sequential compositon production is an attribute of the syntax, and not<br>
of the semantics: e.g., it tells the parser to parse<br>
<code>var x; x=0; x=1;</code> as <code>var x; (x=0; x=1;)</code>, but it<br>
does not tell the rewrite engine to rewrite <code>(var x; x=0;) x=1;</code> to<br>
<code>var x; (x=0; x=1;)</code>.</p>
<h2 id="expression-statements">Expression statements</h2>
<p>Expression statements are only used for their side effects, so their result<br>
value is simply discarded.  Common examples of expression statements are ones<br>
of the form <code>++x;</code>, <code>x=e;</code>, <code>e1[e2]=e3;</code>, etc.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> _<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>
</code></pre>
<h2 id="conditional">Conditional</h2>
<p>Since the conditional was declared with the <code>strict(1)</code> attribute, we<br>
can assume that its first argument will eventually be evaluated.  The rules<br>
below cover the only two possibilities in which the conditional is allowed to<br>
proceed (otherwise the rewriting process gets stuck).</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> if <span class="token punctuation">(</span> <span class="token boolean">true</span><span class="token punctuation">)</span> S else _ <span class="token operator">=</span><span class="token operator">&gt;</span> S
  <span class="token keyword">rule</span> if <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> _ else S <span class="token operator">=</span><span class="token operator">&gt;</span> S
</code></pre>
<h2 id="while-loop">While loop</h2>
<p>The simplest way to give the semantics of the while loop is by unrolling.<br>
Note, however, that its unrolling is only allowed when the while loop reaches<br>
the top of the computation (to avoid non-termination of unrolling).  We prefer<br>
the rule below to be structural, because we don&apos;t want the unrolling of the<br>
while loop to count as a computational step; this is unavoidable in<br>
conventional semantics, but it is possible in <strong>K</strong> thanks to its distinction<br>
between structural and computational rules.  The simple while loop semantics<br>
below works because our while loops in SIMPLE are indeed very basic.  If we<br>
allowed break/continue of loops then we would need a completely different<br>
semantics, which would also involve the <code>control</code> cell.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> while <span class="token punctuation">(</span>E<span class="token punctuation">)</span> S <span class="token operator">=</span><span class="token operator">&gt;</span> if <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">{</span>S while<span class="token punctuation">(</span>E<span class="token punctuation">)</span>S<span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="print">Print</h2>
<p>The <code>print</code> statement was strict, so all its arguments are now<br>
evaluated (recall that <code>print</code> is variadic).  We append each of<br>
its evaluated arguments to the output buffer, and discard the residual<br>
<code>print</code> statement with an empty list of arguments.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> print<span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Es <span class="token operator">=</span><span class="token operator">&gt;</span> Es<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>output<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>List <span class="token operator">=</span><span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>output<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span>print<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> print<span class="token punctuation">(</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="exceptions">Exceptions</h2>
<p>SIMPLE allows parametric exceptions, in that one can throw and catch a<br>
particular value.  The statement <code>try S&#x2081; catch(X) S&#x2082;</code><br>
proceeds with the evaluation of <code>S&#x2081;</code>.  If <code>S&#x2081;</code> evaluates normally, i.e.,<br>
without any exception thrown, then <code>S&#x2082;</code> is discarded and the execution<br>
continues normally.  If <code>S&#x2081;</code> throws an exception with a statement of the<br>
form <code>throw E</code>, then <code>E</code> is first evaluated to some value <code>V</code><br>
(<code>throw</code> was declared to be strict), then <code>V</code> is bound to <code>X</code>, then<br>
<code>S&#x2082;</code> is evaluated in the new environment while the reminder of <code>S&#x2081;</code> is<br>
discarded, then the environment is recovered and the execution continues<br>
normally with the statement following the <code>try S&#x2081; catch(X) S&#x2082;</code> statement.<br>
Exceptions can be nested and the statements in the<br>
<code>catch</code> part (<code>S&#x2082;</code> in our case) can throw exceptions to the<br>
upper level.  One should be careful with how one handles the control data<br>
structures here, so that the abrupt changes of control due to exception<br>
throwing and to function returns interact correctly with each other.<br>
For example, we want to allow function calls inside the statement <code>S&#x2081;</code> in<br>
a <code>try S&#x2081; catch(X) S&#x2082;</code> block which can throw an exception<br>
that is not caught by the function but instead is propagated to the<br>
<code>try S&#x2081; catch(X) S&#x2082;</code> block that called the function.<br>
Therefore, we have to make sure that the function stack as well as other<br>
potential control structures are also properly modified when the exception<br>
is thrown to correctly recover the execution context.  This can be easily<br>
achieved by pushing/popping the entire current control context onto the<br>
exception stack.  The three rules below modularly do precisely the above.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">Id</span><span class="token punctuation">,</span>Stmts<span class="token punctuation">,</span>K<span class="token punctuation">,</span>Map<span class="token punctuation">,</span>ControlCellFragment<span class="token punctuation">)</span>

  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token string">&quot;popx&quot;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> <span class="token punctuation">(</span>try S1 catch<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">{</span>S2<span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> S1 <span class="token operator">~</span><span class="token operator">&gt;</span> popx<span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> K <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>control<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>xstack<span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token operator">=</span><span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>xstack<span class="token operator">&gt;</span>
         C
       <span class="token operator">&lt;</span><span class="token operator">/</span>control<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> popx <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>xstack<span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>xstack<span class="token operator">&gt;</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> throw V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">~</span><span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> var X <span class="token operator">=</span> V<span class="token punctuation">;</span> S2 <span class="token punctuation">}</span> <span class="token operator">~</span><span class="token operator">&gt;</span> K <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>control<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>xstack<span class="token operator">&gt;</span> ListItem<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> S2<span class="token punctuation">,</span> K<span class="token punctuation">,</span> Env<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>List <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>xstack<span class="token operator">&gt;</span>
         <span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">&gt;</span> C<span class="token punctuation">)</span>
       <span class="token operator">&lt;</span><span class="token operator">/</span>control<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
</code></pre>
<p>The catch statement <code>S&#x2082;</code> needs to be executed in the original environment,<br>
but where the thrown value <code>V</code> is bound to the catch variable <code>X</code>.  We here<br>
chose to rely on two previously defined constructs when giving semantics to<br>
the catch part of the statement: (1) the variable declaration with<br>
initialization, for binding <code>X</code> to <code>V</code>; and (2) the block construct for<br>
preventing <code>X</code> from shadowing variables in the original environment upon the<br>
completion of <code>S&#x2082;</code>.</p>
<h2 id="threads">Threads</h2>
<p>SIMPLE&apos;s threads can be created and terminated dynamically, and can<br>
synchronize by acquiring and releasing re-entrant locks and by rendezvous.<br>
We discuss the seven rules giving the semantics of these operations below.</p>
<h2 id="thread-creation">Thread creation</h2>
<p>Threads can be created by any other threads using the <code>spawn S</code><br>
construct.  The spawn expression construct evaluates to the unique identifier<br>
of the newly created thread and, at the same time, a new thread cell is added<br>
into the configuration, initialized with the <code>S</code> statement and sharing the<br>
same environment with the parent thread.  Note that the newly created<br>
<code>thread</code> cell is torn.  That means that the remaining cells are added<br>
and initialized automatically as described in the definition of SIMPLE&apos;s<br>
configuration.  This is part of <strong>K</strong>&apos;s configuration abstraction mechanism.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
         <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> spawn S <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">!</span>T<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
         <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span>
       <span class="token punctuation">(</span><span class="token punctuation">.</span>Bag <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
               <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> S <span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
               <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
               <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span> <span class="token operator">!</span>T <span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<h2 id="thread-termination">Thread termination</h2>
<p>Dually to the above, when a thread terminates its assigned computation (the<br>
contents of its <code>k</code> cell) is empty, so the thread can be dissolved.<br>
However, since no discipline is imposed on how locks are acquired and released,<br>
it can be the case that a terminating thread still holds locks.  Those locks<br>
must be released, so other threads attempting to acquire them do not deadlock.<br>
We achieve that by removing all the locks held by the terminating thread in its<br>
<code>holds</code> cell from the set of busy locks in the <code>busy</code> cell<br>
(<code>keys(H)</code> returns the domain of the map <code>H</code> as a set, that is, only<br>
the locks themselves ignoring their multiplicity).  As seen below, a lock is<br>
added to the <code>busy</code> cell as soon as it is acquired for the first time<br>
by a thread.  The unique identifier of the terminated thread is also collected<br>
into the <code>terminated</code> cell, so the <code>join</code> construct knows which<br>
threads have terminated.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>holds<span class="token operator">&gt;</span>H<span class="token operator">&lt;</span><span class="token operator">/</span>holds<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>T<span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>thread<span class="token operator">&gt;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Bag<span class="token punctuation">)</span>
       <span class="token operator">&lt;</span>busy<span class="token operator">&gt;</span> Busy <span class="token operator">=</span><span class="token operator">&gt;</span> Busy <span class="token operator">-</span>Set keys<span class="token punctuation">(</span>H<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>busy<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>terminated<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Set <span class="token operator">=</span><span class="token operator">&gt;</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>terminated<span class="token operator">&gt;</span>
</code></pre>
<h2 id="thread-joining">Thread joining</h2>
<p>Thread joining is now straightforward: all we need to do is to check whether<br>
the identifier of the thread to be joined is in the <code>terminated</code> cell.<br>
If yes, then the <code>join</code> statement dissolves and the joining thread<br>
continues normally; if not, then the joining thread gets stuck.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> join T<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>terminated<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>terminated<span class="token operator">&gt;</span>
</code></pre>
<h2 id="acquire-lock">Acquire lock</h2>
<p>There are two cases to distinguish when a thread attempts to acquire a lock<br>
(in SIMPLE any value can be used as a lock):<br>
(1) The thread does not currently have the lock, in which case it has to<br>
take it provided that the lock is not already taken by another thread (see<br>
the side condition of the first rule).<br>
(2) The thread already has the lock, in which case it just increments its<br>
counter for the lock (the locks are re-entrant).  These two cases are captured<br>
by the two rules below:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> acquire V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>holds<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span>Map <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>holds<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>busy<span class="token operator">&gt;</span> Busy <span class="token punctuation">(</span><span class="token punctuation">.</span>Set <span class="token operator">=</span><span class="token operator">&gt;</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">/</span>busy<span class="token operator">&gt;</span>
    <span class="token keyword">requires</span> <span class="token punctuation">(</span>notBool<span class="token punctuation">(</span>V in Busy<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span>acquire<span class="token punctuation">]</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> acquire V<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>holds<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>N <span class="token operator">=</span><span class="token operator">&gt;</span> N <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>holds<span class="token operator">&gt;</span>
</code></pre>
<h2 id="release-lock">Release lock</h2>
<p>Similarly, there are two corresponding cases to distinguish when a thread<br>
releases a lock:<br>
(1) The thread holds the lock more than once, in which case all it needs to do<br>
is to decrement the lock counter.<br>
(2) The thread holds the lock only once, in which case it needs to remove it<br>
from its <code>holds</code> cell and also from the the shared <code>busy</code> cell,<br>
so other threads can acquire it if they need to.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> release V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>holds<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>N <span class="token operator">=</span><span class="token operator">&gt;</span> N <span class="token operator">-</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>holds<span class="token operator">&gt;</span>
    <span class="token keyword">requires</span> N <span class="token operator">&gt;</span><span class="token keyword">Int</span> <span class="token number">0</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> release V<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>holds<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> V<span class="token punctuation">:</span>Val <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>holds<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>busy<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> SetItem<span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Set <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>busy<span class="token operator">&gt;</span>
</code></pre>
<h2 id="rendezvous-synchronization">Rendezvous synchronization</h2>
<p>In addition to synchronization through acquire and release of locks, SIMPLE<br>
also provides a construct for rendezvous synchronization.  A thread whose next<br>
statement to execute is <code>rendezvous(V)</code> gets stuck until another<br>
thread reaches an identical statement; when that happens, the two threads<br>
drop their rendezvous statements and continue their executions.  If three<br>
threads happen to have an identical rendezvous statement as their next<br>
statement, then precisely two of them will synchronize and the other will<br>
remain blocked until another thread reaches a similar rendezvous statement.<br>
The rule below is as simple as it can be.  Note, however, that, again, it is<br>
<strong>K</strong>&apos;s mechanism for configuration abstraction that makes it work as desired:<br>
since the only cell which can multiply containing a <code>k</code> cell inside is<br>
the <code>thread</code> cell, the only way to concretize the rule below to the<br>
actual configuration of SIMPLE is to include each <code>k</code> cell in a<br>
<code>thread</code> cell.</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> rendezvous V<span class="token punctuation">:</span>Val<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>
       <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> rendezvous V<span class="token punctuation">;</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>rendezvous<span class="token punctuation">]</span>
</code></pre>
<h2 id="auxiliary-declarations-and-operations">Auxiliary declarations and operations</h2>
<p>In this section we define all the auxiliary constructs used in the<br>
above semantics.</p>
<h2 id="making-declarations">Making declarations</h2>
<p>The <code>mkDecls</code> auxiliary construct turns a list of identifiers<br>
and a list of values in a sequence of corresponding variable<br>
declarations.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Stmts <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> mkDecls<span class="token punctuation">(</span>Ids<span class="token punctuation">,</span>Vals<span class="token punctuation">)</span>  <span class="token punctuation">[</span>function<span class="token punctuation">]</span>
  <span class="token keyword">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword">Id</span><span class="token punctuation">,</span> Xs<span class="token punctuation">:</span>Ids<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>V<span class="token punctuation">:</span>Val<span class="token punctuation">,</span> Vs<span class="token punctuation">:</span>Vals<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> var X<span class="token operator">=</span>V<span class="token punctuation">;</span> mkDecls<span class="token punctuation">(</span>Xs<span class="token punctuation">,</span>Vs<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> mkDecls<span class="token punctuation">(</span><span class="token punctuation">.</span>Ids<span class="token punctuation">,</span><span class="token punctuation">.</span>Vals<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<h2 id="location-lookup">Location lookup</h2>
<p>The operation below is straightforward.  Note that we tag it with the same<br>
<code>lookup</code> tag as the variable lookup rule defined above.  This way,<br>
both rules will be considered transitions when we include the <code>lookup</code><br>
tag in the transition option of <code>kompile</code>.</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lookup<span class="token punctuation">(</span><span class="token keyword">Int</span><span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> lookup<span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> V <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>store<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> L <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> V<span class="token punctuation">:</span>Val <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>store<span class="token operator">&gt;</span>  <span class="token punctuation">[</span>lookup<span class="token punctuation">]</span>
</code></pre>
<h2 id="environment-recovery">Environment recovery</h2>
<p>We have already discussed the environment recovery auxiliary operation in the<br>
IMP++ tutorial:</p>
<pre class="language-k"><code><span class="token comment">// TODO: eliminate the env wrapper, like we did in IMP++</span>

  <span class="token keyword">syntax</span> KItem <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> setEnv<span class="token punctuation">(</span>Map<span class="token punctuation">)</span>
  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> setEnv<span class="token punctuation">(</span>Env<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> Env <span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<p>While theoretically sufficient, the basic definition for environment<br>
recovery alone is suboptimal.  Consider a loop <code>while (E)S</code>,<br>
whose semantics (see above) was given by unrolling.  <code>S</code><br>
is a block.  Then the semantics of blocks above, together with the<br>
unrolling semantics of the while loop, will yield a computation<br>
structure in the <code>k</code> cell that increasingly grows, adding a new<br>
environment recovery task right in front of the already existing sequence of<br>
similar environment recovery tasks (this phenomenon is similar to the ``tail<br>
recursion&apos;&apos; problem).  Of course, when we have a sequence of environment<br>
recovery tasks, we only need to keep the last one.  The elegant rule below<br>
does precisely that, thus avoiding the unnecessary computation explosion<br>
problem:</p>
<pre class="language-k"><code>  <span class="token keyword">rule</span> <span class="token punctuation">(</span>setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">~</span><span class="token operator">&gt;</span> setEnv<span class="token punctuation">(</span>_<span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<p>In fact, the above follows a common convention in <strong>K</strong> for recovery<br>
operations of cell contents: the meaning of a computation task of the form<br>
<code>cell(C)</code> that reaches the top of the computation is that the current<br>
contents of cell <code>cell</code> is discarded and gets replaced with <code>C</code>.  We<br>
did not add support for these special computation tasks in our current<br>
implementation of <strong>K</strong>, so we need to define them as above.</p>
<h2 id="lvalue-and-loc">lvalue and loc</h2>
<p>For convenience in giving the semantics of constructs like the increment and<br>
the assignment, that we want to operate the same way on variables and on<br>
array elements, we used an auxiliary <code>lvalue(E)</code> construct which was<br>
expected to evaluate to the lvalue of the expression <code>E</code>.  This is only<br>
defined when <code>E</code> has an lvalue, that is, when <code>E</code> is either a variable or<br>
evaluates to an array element.  <code>lvalue(E)</code> evaluates to a value of<br>
the form <code>loc(L)</code>, where <code>L</code> is the location where the value of <code>E</code><br>
can be found; for clarity, we use <code>loc</code> to structurally distinguish<br>
natural numbers from location values.  In giving semantics to <code>lvalue</code><br>
there are two cases to consider.  (1) If <code>E</code> is a variable, then all we need<br>
to do is to grab its location from the environment.  (2) If <code>E</code> is an array<br>
element, then we first evaluate the array and its index in order to identify<br>
the exact location of the element of concern, and then return that location;<br>
the last rule below works because its preceding context declarations ensure<br>
that the array and its index are evaluated, and then the rule for array lookup<br>
(defined above) rewrites the evaluated array access construct to its<br>
corresponding store lookup operation.</p>
<pre class="language-k"><code><span class="token comment">// For parsing reasons, we prefer to allow lvalue to take a K</span>

  <span class="token keyword">syntax</span> Exp <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> lvalue<span class="token punctuation">(</span>K<span class="token punctuation">)</span>
  <span class="token keyword">syntax</span> Val <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> loc<span class="token punctuation">(</span><span class="token keyword">Int</span><span class="token punctuation">)</span>

<span class="token comment">// Local variable</span>

  <span class="token keyword">rule</span> <span class="token operator">&lt;</span>k<span class="token operator">&gt;</span> lvalue<span class="token punctuation">(</span>X<span class="token punctuation">:</span><span class="token keyword">Id</span> <span class="token operator">=</span><span class="token operator">&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>k<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>env<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> X <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> L<span class="token punctuation">:</span><span class="token keyword">Int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>env<span class="token operator">&gt;</span>
    <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>

<span class="token comment">// Array element: evaluate the array and its index;</span>
<span class="token comment">// then the array lookup rule above applies.</span>

  <span class="token keyword">context</span> lvalue<span class="token punctuation">(</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">context</span> lvalue<span class="token punctuation">(</span>HOLE<span class="token punctuation">:</span><span class="token punctuation">:</span>Exp<span class="token punctuation">[</span>_<span class="token punctuation">:</span><span class="token punctuation">:</span>Exps<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// Finally, return the address of the desired object member</span>

  <span class="token keyword">rule</span> lvalue<span class="token punctuation">(</span>lookup<span class="token punctuation">(</span>L<span class="token punctuation">:</span><span class="token keyword">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> loc<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token class-name">structural</span><span class="token punctuation">]</span>
</code></pre>
<h2 id="initializing-multiple-locations">Initializing multiple locations</h2>
<p>The following operation initializes a sequence of locations with the same<br>
value:</p>
<pre class="language-k"><code>  <span class="token keyword">syntax</span> Map <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span> <span class="token keyword">Int</span> <span class="token string">&quot;...&quot;</span> <span class="token keyword">Int</span> <span class="token string">&quot;|-&gt;&quot;</span> K
    <span class="token punctuation">[</span>function<span class="token punctuation">,</span> <span class="token class-name">latex</span><span class="token punctuation">(</span><span class="token punctuation">{</span>#<span class="token number">1</span><span class="token punctuation">}</span>\ldots<span class="token punctuation">{</span>#<span class="token number">2</span><span class="token punctuation">}</span>\mapsto<span class="token punctuation">{</span>#<span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">.</span>Map  <span class="token keyword">requires</span> N <span class="token operator">&gt;</span><span class="token keyword">Int</span> M
  <span class="token keyword">rule</span> N<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> K <span class="token operator">=</span><span class="token operator">&gt;</span> N <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> K <span class="token punctuation">(</span>N <span class="token operator">+</span><span class="token keyword">Int</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>M <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">&gt;</span> K  <span class="token keyword">requires</span> N <span class="token operator">&lt;=</span><span class="token keyword">Int</span> M
</code></pre>
<p>The semantics of SIMPLE is now complete.  Make sure you kompile the<br>
definition with the right options in order to generate the desired model.<br>
No kompile options are needed if you only only want to execute the definition<br>
(and thus get an interpreter), but if you want to search for a different<br>
program behaviors then you need to kompile with the transition option<br>
including rule tags such as lookup, increment, acquire, etc.  See the<br>
IMP++ tutorial for what the transition option means how to use it.</p>
<pre class="language-k"><code><span class="token keyword">endmodule</span>
</code></pre>
<p>Go to <a href="../../../2_typed/1_static/simple-typed-static/">Lesson 2, SIMPLE typed static</a></p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
