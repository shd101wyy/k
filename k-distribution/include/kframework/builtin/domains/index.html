<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../downloads">Downloads</a>
      <a class="bd-toc-link" href="../../../../../k-distribution/tutorial"
        >K Tutorial</a
      >
      <a class="bd-toc-link" href="../../../../../pending-documentation/"
        >User documentation</a
      >
      <a
        class="bd-toc-link"
        href="../../../../../k-distribution/include/kframework/builtin/"
        >Builtins</a
      >
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="introduction markdown-preview">
            <html><head></head><body><h1>Basic Builtin Types in K</h1>
<p>A major piece of the K prelude consists of a series of modules that contain
implementations of basic data types and language features in K. You do not need
to require this file yourself; it is required automatically in every K
definition unless <code>--no-prelude</code> is passed to kompile. K may not work correctly
if some of these modules do not exist or do not declare certain functions.</p>
<pre class="hljs"><code><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;kast.md&quot;</span>
</code></pre>
<h2>Default Modules</h2>
<p>K declares certain modules that contain most of the builtins you usually want
when defining a language in K. In particular, this includes integers, booleans,
strings, identifiers, I/O, lists, maps, and sets. The <code>DOMAINS-SYNTAX</code> module
is designed to be imported by the syntax module of the language and contains
only the program-level syntax of identifiers, integers, booleans, and strings.
The <code>DOMAINS</code> module contains the rest of the syntax, including builtin
functions over those and the remaining types.</p>
<p>Note that not all modules are included in DOMAINS. A few less-common modules
are not, including <code>ARRAY</code>, <code>COLLECTIONS</code>, <code>FLOAT</code>, <code>STRING-BUFFER</code>, <code>BYTES</code>,
<code>K-REFLECTION</code>, <code>MINT</code>, and <code>STRATEGY</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> DOMAINS-SYNTAX<span class="hljs-keyword">
  imports</span> SORT-K<span class="hljs-keyword">
  imports</span> ID-SYNTAX<span class="hljs-keyword">
  imports</span> UNSIGNED-INT-SYNTAX<span class="hljs-keyword">
  imports</span> BOOL-SYNTAX<span class="hljs-keyword">
  imports</span> STRING-SYNTAX<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> DOMAINS<span class="hljs-keyword">
  imports</span> DOMAINS-SYNTAX<span class="hljs-keyword">
  imports</span> INT<span class="hljs-keyword">
  imports</span> BOOL<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">
  imports</span> K-IO<span class="hljs-keyword">
  imports</span> MAP<span class="hljs-keyword">
  imports</span> SET<span class="hljs-keyword">
  imports</span> ID<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Arrays</h2>
<p>Provided here is an implementation for fixed-sized, contiguous maps from <code>Int</code>
to <code>KItem</code>. In some previous versions of K, the <code>Array</code> type was a builtin type
backed by mutable arrays of objects. However, in modern K, the <code>Array</code> type is
implemented by means of the <code>List</code> type; users should not access this interface
directly and should instead make only of the functions listed below. Users of
this module should import only the <code>ARRAY</code> module.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> ARRAY-SYNTAX<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">

  syntax</span> Array [hook(ARRAY.Array), unit(arrayCtor), element(_[_&lt;-_])]
</code></pre>
<h3>Array lookup</h3>
<p>You can look up an element in an <code>Array</code> by its index in O(log(N)) time. Note
that the base of the logarithm is a relatively high number and thus the time is
effectively constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= Array <span class="hljs-string">&quot;[&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;]&quot;</span> [function, hook(ARRAY.lookup)]
</code></pre>
<h3>Array update</h3>
<p>You can create a new <code>Array</code> with a new value for a key in O(log(N)) time, or
effectively constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Array ::= Array <span class="hljs-string">&quot;[&quot;</span> key:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;-&quot;</span> value: KItem <span class="hljs-string">&quot;]&quot;</span> [function, hook(ARRAY.update), klabel(_[_&lt;-_]), symbol]
</code></pre>
<h3>Array reset</h3>
<p>You can create a new <code>Array</code> where a particular key is reset to its default
value in O(log(N)) time, or effectively constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Array ::= Array <span class="hljs-string">&quot;[&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;-&quot;</span> <span class="hljs-string">&quot;undef&quot;</span> <span class="hljs-string">&quot;]&quot;</span> [function, hook(ARRAY.remove)]
</code></pre>
<h3>Multiple array update</h3>
<p>You can create a new <code>Array</code> from a <code>List</code> <code>L</code> of size <code>N</code> where the <code>N</code>
elements starting at <code>index</code> are replaced with the contents of <code>L</code>, in
O(N*log(K)) time (where K is the size of the array), or effectively linear.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Array ::= updateArray(Array, index:<span class="hljs-keyword"> Int</span>, List) [function, hook(ARRAY.updateAll)]
</code></pre>
<h3>Array fill</h3>
<p>You can create a new <code>Array</code> where the <code>length</code> elements starting at <code>index</code>
are replaced with <code>value</code>, in O(length*log(N)) time, or effectively linear.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Array ::= fillArray(Array, index:<span class="hljs-keyword"> Int</span>, length:<span class="hljs-keyword"> Int</span>, value: KItem) [function, hook(ARRAY.fill)]
</code></pre>
<h3>Array range check</h3>
<p>You can test whether an integer is within the bounds of an array in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::=<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;in_keys&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Array <span class="hljs-string">&quot;)&quot;</span> [function, functional, hook(ARRAY.in_keys)]
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">endmodule</span><span class="hljs-keyword">

module</span> ARRAY-IN-K<span class="hljs-keyword">
  imports</span> ARRAY-SYNTAX<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  imports</span> INT
</code></pre>
<h3>Array creation</h3>
<p>You can create an array with <code>length</code> elements where each element is
initialized to <code>value</code> in O(1) time. Note that the array is stored in a manner
where only the highest element that is actually modified is given a value
in its internal representation, which means that subsequent array operations
may incur a one-time O(N) resizing cost, possibly amortized across multiple
operations.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Array ::= makeArray(length:<span class="hljs-keyword"> Int</span>, value: KItem) [function, hook(ARRAY.make)]
</code></pre>
<h3>Implementation of Arrays</h3>
<p>The remainder of this section consists of an implementation in K of the
operations listed above. Users of the <code>ARRAY</code> module should not make use
of any of the syntax defined in any of these modules.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Array ::= arr(List,<span class="hljs-keyword"> Int</span>, KItem)<span class="hljs-keyword">

  rule</span> makeArray(I::<span class="hljs-keyword">Int</span>, D::KItem) =&gt; arr(.List, I, D)<span class="hljs-keyword">

  rule</span> arr(L::List, _, D::KItem) [ IDX::<span class="hljs-keyword">Int</span> ] =&gt; #if IDX &gt;=<span class="hljs-keyword">Int</span> size(L) #then D #else L[IDX] #fi<span class="hljs-keyword">

  syntax</span> List ::= ensureOffsetList(List,<span class="hljs-keyword"> Int</span>, KItem) [function]<span class="hljs-keyword">
  rule</span> ensureOffsetList(L::List, IDX::<span class="hljs-keyword">Int</span>, D::KItem) =&gt; #if IDX &gt;=<span class="hljs-keyword">Int</span> size(L) #then updateList(makeList(IDX +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, D), <span class="hljs-number">0</span>, L) #else L #fi<span class="hljs-keyword">

  rule</span> arr(L::List, I::<span class="hljs-keyword">Int</span>, D::KItem) [ IDX::<span class="hljs-keyword">Int</span> &lt;- VAL::KItem ] =&gt; arr(ensureOffsetList(L, IDX, D) [ IDX &lt;- VAL ], I, D)<span class="hljs-keyword">

  rule</span> arr(L::List, I::<span class="hljs-keyword">Int</span>, D::KItem) [ IDX::<span class="hljs-keyword">Int</span> &lt;- undef ] =&gt; arr(L, I, D) [ IDX &lt;- D ]<span class="hljs-keyword">

  rule</span> updateArray(arr(L::List, I::<span class="hljs-keyword">Int</span>, D::KItem), IDX::<span class="hljs-keyword">Int</span>, L2::List) =&gt; arr(updateList(ensureOffsetList(L, IDX +<span class="hljs-keyword">Int</span> size(L2) -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, D), IDX, L2), I, D)<span class="hljs-keyword">

  rule</span> fillArray(arr(L::List, I::<span class="hljs-keyword">Int</span>, D::KItem), IDX::<span class="hljs-keyword">Int</span>, LEN::<span class="hljs-keyword">Int</span>, VAL::KItem) =&gt; arr(fillList(ensureOffsetList(L, IDX +<span class="hljs-keyword">Int</span> LEN -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, D), IDX, LEN, VAL), I, D)<span class="hljs-keyword">

  rule</span> IDX::<span class="hljs-keyword">Int</span> in_keys(arr(_, I::<span class="hljs-keyword">Int</span>, _)) =&gt; IDX &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span> andBool IDX &lt;<span class="hljs-keyword">Int</span> I<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ARRAY-CONCRETE [concrete, kast]<span class="hljs-keyword">
  imports</span> ARRAY-SYNTAX<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">
  imports</span> STRING-SYNTAX<span class="hljs-keyword">

  syntax</span> Array ::= makeEmptyArray(<span class="hljs-keyword">Int</span>) [function, hook(ARRAY.makeEmpty), impure]
                 | arrayCtor(<span class="hljs-keyword">String</span>,<span class="hljs-keyword"> Int</span>, KItem) [function, hook(ARRAY.ctor), symbol]
                 | makeArray(<span class="hljs-keyword">Int</span>, KItem) [function, hook(ARRAY.make), impure, klabel(makeArrayOcaml)]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ARRAY-SYMBOLIC [symbolic]<span class="hljs-keyword">
  imports</span> ARRAY-IN-K<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ARRAY-KORE [kore]<span class="hljs-keyword">
  imports</span> ARRAY-IN-K<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ARRAY<span class="hljs-keyword">
  imports</span> ARRAY-CONCRETE<span class="hljs-keyword">
  imports</span> ARRAY-SYMBOLIC<span class="hljs-keyword">
  imports</span> ARRAY-KORE<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Maps</h2>
<p>Provided here is the syntax of an implementation of immutable, associative,
commutative maps from <code>KItem</code> to <code>KItem</code>. This type is hooked to an
implementation of maps provided by the backend. For more information on
matching on maps and allowable patterns for doing so, refer to K&apos;s
<a href="pending-documentation/">user documentation</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> MAP<span class="hljs-keyword">
  imports</span> BOOL-SYNTAX<span class="hljs-keyword">
  imports</span> INT-SYNTAX<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">
  imports</span> SET<span class="hljs-keyword">

  syntax</span> Map [hook(MAP.Map)]
</code></pre>
<h3>Map concatenation</h3>
<p>The <code>Map</code> sort represents a generalized associative array. Each key can be
paired with an arbitrary value, and can be used to reference its associated
value. Multiple bindings for the same key are not allowed.</p>
<p>You can construct a new Map consisting of key/value pairs of two Maps. The
result is <code>#False</code> if the maps have keys in common (in particular, this will
yield an exception during concrete execution). This operation is O(N<em>log(M))
where N is the size of the smaller map, when it appears on the right hand side.
When it appears on the left hand side and all variables are bound, it is
O(N</em>log(M)) where M is the size of the map it is matching and N is the number
of elements being matched. When it appears on the left hand side containing
variables not bound elsewhere in the term, it is O(N^K) where N is the size of
the map it is matching and K is the number of unbound keys being matched. In
other words, one unbound variable is linear, two is quadratic, three is cubic,
etc.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= Map Map                        [<span class="hljs-literal">left</span>, function, hook(MAP.concat), klabel(_Map_), symbol, assoc, comm, unit(.Map), element(_|-&gt;_), index(<span class="hljs-number">0</span>), format(%<span class="hljs-number">1</span>%n%<span class="hljs-number">2</span>)]
</code></pre>
<h3>Map unit</h3>
<p>The map with zero elements is represented by <code>.Map</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= <span class="hljs-string">&quot;.Map&quot;</span>                         [function, functional, hook(MAP.unit), klabel(.Map), symbol, <span class="hljs-literal">latex</span>(\dotCt{Map})]
</code></pre>
<h3>Map elements</h3>
<p>An element of a <code>Map</code> is constructed via the <code>|-&gt;</code> operator. The key is on the
left and the value is on the right.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= KItem <span class="hljs-string">&quot;|-&gt;&quot;</span> KItem                      [function, functional, hook(MAP.element), klabel(_|-&gt;_), symbol, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mapsto{#<span class="hljs-number">2</span>})]<span class="hljs-keyword">

  syntax</span> priorities _|-&gt;_ &gt; _Map_ .Map<span class="hljs-keyword">
  syntax</span> <span class="hljs-literal">non-assoc</span> _|-&gt;_
</code></pre>
<h3>Map lookup</h3>
<p>You can look up the value associated with the key of a map in O(log(N)) time.
Note that the base of the logarithm is a relatively high number and thus the
time is effectively constant. The value is <code>#False</code> if the key is not in the
map (in particular, this will yield an exception during concrete execution).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= Map <span class="hljs-string">&quot;[&quot;</span> KItem <span class="hljs-string">&quot;]&quot;</span>                    [function, hook(MAP.lookup), klabel(Map:lookup), symbol]
</code></pre>
<h3>Map lookup with default</h3>
<p>You can also look up the value associated with the key of a map using a
total function that assigns a specific default value if the key is not present
in the map. This operation is also O(log(N)), or effectively constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= Map <span class="hljs-string">&quot;[&quot;</span> KItem <span class="hljs-string">&quot;]&quot;</span> <span class="hljs-string">&quot;orDefault&quot;</span> KItem      [function, functional, hook(MAP.lookupOrDefault), klabel(Map:lookupOrDefault)]
</code></pre>
<h3>Map update</h3>
<p>You can insert a key/value pair into a map in O(log(N)) time, or effectively
constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= Map <span class="hljs-string">&quot;[&quot;</span> key: KItem <span class="hljs-string">&quot;&lt;-&quot;</span> value: KItem <span class="hljs-string">&quot;]&quot;</span>           [function, functional, klabel(Map:update), symbol, hook(MAP.update), <span class="hljs-literal">prefer</span>]
</code></pre>
<h3>Map delete</h3>
<p>You can remove a key/value pair from a map via its key in O(log(N)) time, or
effectively constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= Map <span class="hljs-string">&quot;[&quot;</span> KItem <span class="hljs-string">&quot;&lt;-&quot;</span> <span class="hljs-string">&quot;undef&quot;</span> <span class="hljs-string">&quot;]&quot;</span>     [function, functional, hook(MAP.remove), klabel(_[_&lt;-undef]), symbol]
</code></pre>
<h3>Map difference</h3>
<p>You can remove the key/value pairs in a map that are present in another map in
O(N*log(M)) time (where M is the size of the first map and N is the size of the
second), or effectively linear. Note that only keys whose value is the same
in both maps are removed. To remove all the keys in one map from another map,
you can say <code>removeAll(M1, keys(M2))</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= Map <span class="hljs-string">&quot;-Map&quot;</span> Map                 [function, functional, hook(MAP.difference), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}-_{\it Map}{#<span class="hljs-number">2</span>})]
</code></pre>
<h3>Multiple map update</h3>
<p>You can update a map by adding all the key/value pairs in the second map in
O(N*log(M)) time (where M is the size of the first map and N is the size of the
second map), or effectively linear. If any keys are present in both maps, the
value from the second map overwrites the value in the first. This function is
total, which is distinct from map concatenation, a partial function only
defined on maps with disjoint keys.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= updateMap(Map, Map)            [function, functional, hook(MAP.updateAll)]
</code></pre>
<h3>Multiple map removal</h3>
<p>You can remove a <code>Set</code> of keys from a map in O(N*log(M)) time (where M is the
size of the <code>Map</code> and <code>N</code> is the size of the <code>Set</code>), or effectively linear.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Map ::= removeAll(Map, Set)            [function, functional, hook(MAP.removeAll)]
</code></pre>
<h3>Map keys (as <code>Set</code>)</h3>
<p>You can get a <code>Set</code> of all the keys in a Map in O(N) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= keys(Map)                      [function, functional, hook(MAP.keys)]
</code></pre>
<h3>Map keys (as <code>List</code>)</h3>
<p>You can get a <code>List</code> of all the keys in a Map in O(N) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= <span class="hljs-string">&quot;keys_list&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Map <span class="hljs-string">&quot;)&quot;</span>       [function, hook(MAP.keys_list)]
</code></pre>
<h3>Map key membership</h3>
<p>You can check whether a key is present in a map in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= KItem <span class="hljs-string">&quot;in_keys&quot;</span> <span class="hljs-string">&quot;(&quot;</span> Map <span class="hljs-string">&quot;)&quot;</span>       [function, functional, hook(MAP.in_keys)]
</code></pre>
<h3>Map values (as <code>List</code>)</h3>
<p>You can get a <code>List</code> of all the values in a map in O(N) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= values(Map)                   [function, hook(MAP.values)]
</code></pre>
<h3>Map size</h3>
<p>You can get the number of key/value pairs in a map in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= size(Map)                      [function, functional, hook(MAP.size), klabel(sizeMap)]
</code></pre>
<h3>Map inclusion</h3>
<p>You can determine whether a <code>Map</code> is a strict subset of another <code>Map</code> in O(N)
time (where N is the size of the first map). Only keys that are bound to the
same value are considered equal.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= Map <span class="hljs-string">&quot;&lt;=Map&quot;</span> Map               [function, functional, hook(MAP.inclusion)]
</code></pre>
<h3>Map choice</h3>
<p>You can get an arbitrarily chosen key of a <code>Map</code> in O(1) time. The same key
will always be returned for the same map, but no guarantee is given that two
different maps will return the same element, even if they are similar.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= choice(Map)                      [function, hook(MAP.choice), klabel(Map:choice)]
</code></pre>
<h3>Implementation of Maps</h3>
<p>The remainder of this section contains lemmas used by the Java and Haskell
backend to simplify expressions of sort <code>Map</code>. They do not affect the semantics
of maps, merely describing additional rules that the backend can use to
simplify terms.</p>
<pre class="hljs"><code><span class="hljs-keyword">endmodule</span><span class="hljs-keyword">

module</span> MAP-KORE-SYMBOLIC [kore,symbolic]<span class="hljs-keyword">
  imports</span> MAP<span class="hljs-keyword">

   rule</span> #Ceil(@M:Map [@K:KItem]) =&gt; {(@K in_keys(@M)) #Equals true} #And #Ceil(@M) #And #Ceil(@K) [anywhere, simplification]

<span class="hljs-comment">/*
// The rules below are automatically generated by the frontend.
// They are left here to serve as documentation.

  rule K:KItem in_keys(M:Map K |-&gt; _) =&gt; true
  rule K:KItem in_keys(_:Map)         =&gt; false [owise]

  rule #Ceil(@M:Map (@K:KItem |-&gt; @V:KItem)) =&gt; {(@K in_keys(@M)) #Equals false} #And #Ceil(@M) #And #Ceil(@K) #And #Ceil(@V)
  [anywhere, simplification]
*/</span><span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> MAP-JAVA-SYMBOLIC [kast, symbolic]<span class="hljs-keyword">
  imports</span> MAP<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  rule</span> .Map [ K1 &lt;- V1 ] =&gt; K1 |-&gt; V1<span class="hljs-keyword">

  rule</span> ((K1 |-&gt; V1) MAP) [ K2 ] =&gt; V1<span class="hljs-keyword">         requires</span> K1  ==K K2<span class="hljs-keyword">
  rule</span> ((K1 |-&gt; V1) MAP) [ K2 ] =&gt; MAP [ K2 ]<span class="hljs-keyword"> requires</span> K1 =/=K K2<span class="hljs-keyword">

  rule</span> (MAP:Map [ K1 &lt;- V1 ]) [ K2 ] =&gt; V1<span class="hljs-keyword">         requires</span> K1  ==K K2<span class="hljs-keyword">
  rule</span> (MAP:Map [ K1 &lt;- V1 ]) [ K2 ] =&gt; MAP [ K2 ]<span class="hljs-keyword"> requires</span> K1 =/=K K2<span class="hljs-keyword">

  rule</span> ((K1 |-&gt; V1) MAP) [ K2 &lt;- V2 ] =&gt; (K1 |-&gt; V2) MAP<span class="hljs-keyword">                requires</span> K1  ==K K2<span class="hljs-keyword">
  rule</span> ((K1 |-&gt; V1) MAP) [ K2 &lt;- V2 ] =&gt; (K1 |-&gt; V1) (MAP [ K2 &lt;- V2 ])<span class="hljs-keyword"> requires</span> K1 =/=K K2<span class="hljs-keyword">

  rule</span> (MAP:Map [ K1 &lt;- V1 ]) [ K2 &lt;- V2 ] =&gt; MAP              [ K1 &lt;- V2 ]<span class="hljs-keyword"> requires</span> K1  ==K K2

  <span class="hljs-comment">// potential infinite loop</span>
  <span class="hljs-comment">// rule (MAP:Map [ K1 &lt;- V1 ]) [ K2 &lt;- V2 ] =&gt; MAP [ K2 &lt;- V2 ] [ K1 &lt;- V1 ] requires K1 =/=K K2</span><span class="hljs-keyword">

  rule</span> K1 in_keys(M K2 |-&gt; _) =&gt; true<span class="hljs-keyword">          requires</span> K1  ==K K2 orBool K1 in_keys(M) [simplification]<span class="hljs-keyword">
  rule</span> K1 in_keys(M K2 |-&gt; _) =&gt; K1 in_keys(M)<span class="hljs-keyword"> requires</span> K1 =/=K K2 [simplification]<span class="hljs-keyword">

  rule</span> K1 in_keys(M [ K2 &lt;- _ ]) =&gt; true<span class="hljs-keyword">          requires</span> K1  ==K K2 orBool K1 in_keys(M) [simplification]<span class="hljs-keyword">
  rule</span> K1 in_keys(M [ K2 &lt;- _ ]) =&gt; K1 in_keys(M)<span class="hljs-keyword"> requires</span> K1 =/=K K2 [simplification]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> MAP-SYMBOLIC<span class="hljs-keyword">
  imports</span> MAP-JAVA-SYMBOLIC<span class="hljs-keyword">
  imports</span> MAP-KORE-SYMBOLIC<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Sets</h2>
<p>Provided here is the syntax of an implementation of immutable, associative,
commutative sets of <code>KItem</code>. This type is hooked to an implementation of sets
provided by the backend. For more information on matching on sets and allowable
patterns for doing so, refer to K&apos;s
<a href="pending-documentation/">user documentation</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> SET<span class="hljs-keyword">
  imports</span> INT-SYNTAX<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">

  syntax</span> Set [hook(SET.Set)]
</code></pre>
<h3>Set concatenation</h3>
<p>The <code>Set</code> sort represents a mathematical set (A collection of unique items).
The sets are nilpotent, i.e., the concatenation of two sets containing elements
in common is <code>#False</code> (note however, this may be silently allowed during
concrete execution). If you intend to add an element to a set that might
already be present in the set, use the <code>|Set</code> operator instead.</p>
<p>The concatenation operator is O(N<em>log(M)) where N is the size of the smaller
set, when it appears on the right hand side. When it appears on the left hand
side and all variables are bound, it is O(N</em>log(M)) where M is the size of the
set it is matching and N is the number of elements being matched. When it
appears on the left hand side containing variables not bound elsewhere in the
term, it is O(N^K) where N is the size of the set it is matching and K is the
number of unbound keys being mached. In other words, one unbound variable is
linear, two is quadratic, three is cubic, etc.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= Set Set                  [<span class="hljs-literal">left</span>, function, functional, hook(SET.concat), klabel(_Set_), symbol, assoc, comm, unit(.Set), idem, element(SetItem), format(%<span class="hljs-number">1</span>%n%<span class="hljs-number">2</span>)]
</code></pre>
<h3>Set unit</h3>
<p>The set with zero elements is represented by <code>.Set</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= <span class="hljs-string">&quot;.Set&quot;</span>                   [function, functional, hook(SET.unit), klabel(.Set), symbol, <span class="hljs-literal">latex</span>(\dotCt{Set})]
</code></pre>
<h3>Set elements</h3>
<p>An element of a <code>Set</code> is constructed via the <code>SetItem</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= SetItem(KItem)               [function, functional, hook(SET.element), klabel(SetItem), symbol]
</code></pre>
<h3>Set union</h3>
<p>You can compute the union of two sets in O(N*log(M)) time (Where N is the size
of the smaller set). Note that the base of the logarithm is a relatively high
number and thus the time is effectively linear. The union consists of all the
elements present in either set.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= Set <span class="hljs-string">&quot;|Set&quot;</span> Set            [<span class="hljs-literal">left</span>, function, functional, hook(SET.union)]<span class="hljs-keyword">
  rule</span> S1:Set |Set S2:Set =&gt; S1 (S2 -Set S1)
</code></pre>
<h3>Set intersection</h3>
<p>You can compute the intersection of two sets in O(N*log(M)) time (where N
is the size of the smaller set), or effectively linear. The intersection
consists of all the elements present in both sets.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= intersectSet(Set, Set)   [function, functional, hook(SET.intersection)]
</code></pre>
<h3>Set complement</h3>
<p>You can compute the relative complement of two sets in O(N*log(M)) time (where
N is the size of the second set), or effectively linear. This is the set of
elements in the first set that are not present in the second set.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Set ::= Set <span class="hljs-string">&quot;-Set&quot;</span> Set           [function, functional, hook(SET.difference), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}-_{\it Set}{#<span class="hljs-number">2</span>}), klabel(Set:difference), symbol]
</code></pre>
<h3>Set membership</h3>
<p>You can compute whether an element is a member of a set in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= KItem <span class="hljs-string">&quot;in&quot;</span> Set              [function, functional, hook(SET.in), klabel(Set:in), symbol]
</code></pre>
<h3>Set inclusion</h3>
<p>You can determine whether a <code>Set</code> is a strict subset of another <code>Set</code> in O(N)
time (where N is the size of the first set).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= Set <span class="hljs-string">&quot;&lt;=Set&quot;</span> Set         [function, functional, hook(SET.inclusion)]
</code></pre>
<h3>Set size</h3>
<p>You can get the number of elements (the cardinality) of a set in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= size(Set)                [function, functional, hook(SET.size)]
</code></pre>
<h3>Set choice</h3>
<p>You can get an arbitrarily chosen element of a <code>Set</code> in O(1) time. The same
element will always be returned for the same set, but no guarantee is given
that two different sets will return the same element, even if they are similar.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= choice(Set)                [function, hook(SET.choice), klabel(Set:choice)]
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">endmodule</span>
</code></pre>
<h2>Lists</h2>
<p>Provided here is the syntax of an implementation of immutable, associative
lists of <code>KItem</code>. This type is hooked to an implementation of lists provided
by the backend. For more information on matching on lists and allowable
patterns for doing so, refer to K&apos;s
<a href="pending-documentation">user documentation</a>.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> LIST<span class="hljs-keyword">
  imports</span> INT-SYNTAX<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">

  syntax</span> List [hook(LIST.List)]
</code></pre>
<h3>List concatenation</h3>
<p>The <code>List</code> sort is an ordered collection that may contain duplicate elements.
They are backed by relaxed radix balanced trees, which means that they support
efficiently adding elements to both sides of the list, concatenating two lists,
indexing, and updating elements.</p>
<p>The concatenation operator is O(log(N)) (where N is the size of the longer
list) when it appears on the right hand side. When it appears on the left hand
side, it is O(N), where N is the number of elements matched on the front and
back of the list.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= List List               [<span class="hljs-literal">left</span>, function, functional, hook(LIST.concat), klabel(_List_), symbol, smtlib(smt_seq_concat), assoc, unit(.List), element(ListItem), format(%<span class="hljs-number">1</span>%n%<span class="hljs-number">2</span>)]
</code></pre>
<h3>List unit</h3>
<p>The list with zero elements is represented by <code>.List</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= <span class="hljs-string">&quot;.List&quot;</span>                 [function, functional, hook(LIST.unit), klabel(.List), symbol, smtlib(smt_seq_nil), <span class="hljs-literal">latex</span>(\dotCt{List})]
</code></pre>
<h3>List elements</h3>
<p>An element of a <code>List</code> is constucted via the <code>ListItem</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= ListItem(KItem)             [function, functional, hook(LIST.element), klabel(ListItem), symbol, smtlib(smt_seq_elem)]
</code></pre>
<h3>List indexing</h3>
<p>You can get an element of a list by its integer offset in O(log(N)) time, or
effectively constant. Positive indices are 0-indexed from the beginning of the
list, and negative indices are -1-indexed from the end of the list. In other
words, 0 is the first element and -1 is the last element.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= List <span class="hljs-string">&quot;[&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;]&quot;</span>           [function, hook(LIST.get), klabel(List:get), symbol]
</code></pre>
<h3>List update</h3>
<p>You can create a new <code>List</code> with a new value at a particular index in
O(log(N)) time, or effectively constant.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= List <span class="hljs-string">&quot;[&quot;</span> index:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;-&quot;</span> value: KItem <span class="hljs-string">&quot;]&quot;</span> [function, hook(LIST.update), klabel(List:set)]
</code></pre>
<h3>List of identical elements</h3>
<p>You can create a list with <code>length</code> elements, each containing <code>value</code>, in O(N)
time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= makeList(length:<span class="hljs-keyword"> Int</span>, value: KItem) [function, hook(LIST.make)]
</code></pre>
<h3>Multiple list update</h3>
<p>You can create a new <code>List</code> which is equal to <code>dest</code> except the <code>N</code> elements
starting at <code>index</code> are replaced with the contents of <code>src</code> in O(N*log(K)) time
(where K is the size of <code>dest</code>), or effectively linear.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= updateList(dest: List, index:<span class="hljs-keyword"> Int</span>, src: List) [function, hook(LIST.updateAll)]
</code></pre>
<h3>List fill</h3>
<p>You can create a new <code>List</code> where the <code>length</code> elements starting at <code>index</code>
are replaced with <code>value</code>, in O(length*log(N)) time, or effectively linear.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= fillList(List, index:<span class="hljs-keyword"> Int</span>, length:<span class="hljs-keyword"> Int</span>, value: KItem) [function, hook(LIST.fill)]
</code></pre>
<h3>List slicing</h3>
<p>You can compute a new <code>List</code> by removing <code>fromFront</code> elements from the front
of the list and <code>fromBack</code> elements from the back of the list in
O((fromFront+fromBack)*log(N)) time, or effectively linear.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> List ::= range(List, fromFront:<span class="hljs-keyword"> Int</span>, fromBack:<span class="hljs-keyword"> Int</span>)   [function, hook(LIST.range), klabel(List:range), symbol]
</code></pre>
<h3>List membership</h3>
<p>You can compute whether an element is in a list in O(N) time. For repeated
comparisons, it is much better to first convert to a set using <code>List2Set</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= KItem <span class="hljs-string">&quot;in&quot;</span> List             [function, functional, hook(LIST.in), klabel(_inList_)]
</code></pre>
<h3>List size</h3>
<p>You can get the number of elements of a list in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= size(List)               [function, functional, hook(LIST.size), klabel (sizeList), smtlib(smt_seq_len)]
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">endmodule</span>
</code></pre>
<h2>Collection Conversions</h2>
<p>It is possible to convert from a <code>List</code> to a <code>Set</code> or from a <code>Set</code> to a list.
Converting from a <code>List</code> to a <code>Set</code> and back will not provide the same list;
duplicates will have been removed and the list may be reordered. Converting
from a <code>Set</code> to a <code>List</code> and back will generate the same set.</p>
<p>Note that because sets are unordered and lists are ordered, converting from a
Set to a List will generate some arbitrary ordering of elements, which may
be different from the natural ordering you might assume, or may not. Two
equal sets are guaranteed to generate the same ordering, but no guarantee is
otherwise provided about what the ordering will be. In particular, adding an
element to a set may completely reorder the elements already in the set, when
it is converted to a list.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> COLLECTIONS<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">
  imports</span> SET<span class="hljs-keyword">
  imports</span> MAP<span class="hljs-keyword">

  syntax</span> List ::= Set2List(Set) [function, functional, hook(SET.set2list)]<span class="hljs-keyword">
  syntax</span> Set ::= List2Set(List) [function, functional, hook(SET.list2set)]<span class="hljs-keyword">

endmodule</span>
</code></pre>
<h2>Booleans</h2>
<p>Provided here is the syntax of an implementation of boolean algebra in K.
This type is hooked to an implementation of booleans provided by the backend.
Note that this algebra is different from the builtin truth in matching logic.
You can, however, convert from the truth of the <code>Bool</code> sort to the truth in
matching logic via the expression <code>{B #Equals true}</code>.</p>
<p>The boolean values are <code>true</code> and <code>false</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> BOOL-SYNTAX<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Bool</span> [hook(BOOL.<span class="hljs-keyword">Bool</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Bool</span> ::= <span class="hljs-string">&quot;true&quot;</span>  [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Bool</span> ::= <span class="hljs-string">&quot;false&quot;</span> [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> BOOL<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">
  imports</span> BOOL-SYNTAX
</code></pre>
<h3>Basic boolean arithmetic</h3>
<p>You can:</p>
<ul>
<li>Negate a boolean value.</li>
<li>AND two boolean values.</li>
<li>XOR two boolean values.</li>
<li>OR two boolean values.</li>
<li>IMPLIES two boolean values (i.e., <code>P impliesBool Q</code> is the same as
<code>notBool P orBool Q</code>)</li>
<li>Check equality of two boolean values.</li>
<li>Check inequality of two boolean values.</li>
</ul>
<p>Note that only <code>andThenBool</code> and <code>orElseBool</code> are short-circuiting. <code>andBool</code>
and <code>orBool</code> may be short-circuited in concrete backends, but in symbolic
ackends, both arguments will be evaluated.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= <span class="hljs-string">&quot;notBool&quot;</span><span class="hljs-keyword"> Bool</span>          [function, functional, klabel(notBool_), symbol, smt-hook(not), boolOperation, <span class="hljs-literal">latex</span>(\neg_{\scriptstyle\it<span class="hljs-keyword"> Bool</span>}{#<span class="hljs-number">1</span>}), hook(BOOL.not)]
                &gt;<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;andBool&quot;</span><span class="hljs-keyword"> Bool</span>     [function, functional, klabel(_andBool_), symbol, <span class="hljs-literal">left</span>, smt-hook(and), boolOperation, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\wedge_{\scriptstyle\it<span class="hljs-keyword"> Bool</span>}{#<span class="hljs-number">2</span>}), hook(BOOL.and)]
                |<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;andThenBool&quot;</span><span class="hljs-keyword"> Bool</span> [function, functional, klabel(_andThenBool_), symbol, <span class="hljs-literal">left</span>, smt-hook(and), boolOperation, hook(BOOL.andThen)]
                |<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;xorBool&quot;</span><span class="hljs-keyword"> Bool</span>     [function, functional, klabel(_xorBool_), symbol, <span class="hljs-literal">left</span>, smt-hook(xor), boolOperation, hook(BOOL.xor)]
                |<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;orBool&quot;</span><span class="hljs-keyword"> Bool</span>      [function, functional, klabel(_orBool_), <span class="hljs-literal">left</span>, smt-hook(or), boolOperation, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\vee_{\scriptstyle\it<span class="hljs-keyword"> Bool</span>}{#<span class="hljs-number">2</span>}), hook(BOOL.or)]
                |<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;orElseBool&quot;</span><span class="hljs-keyword"> Bool</span>  [function, functional, klabel(_orElseBool_), symbol, <span class="hljs-literal">left</span>, smt-hook(or), boolOperation, hook(BOOL.orElse)]
                |<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;impliesBool&quot;</span><span class="hljs-keyword"> Bool</span> [function, functional, klabel(_impliesBool_), symbol, <span class="hljs-literal">left</span>, smt-hook(=&gt;), boolOperation, hook(BOOL.implies)]
                &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                  Bool</span> <span class="hljs-string">&quot;==Bool&quot;</span><span class="hljs-keyword"> Bool</span>      [function, functional, klabel(_==Bool_), symbol, <span class="hljs-literal">left</span>, smt-hook(=), hook(BOOL.eq)]
                |<span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;=/=Bool&quot;</span><span class="hljs-keyword"> Bool</span>     [function, functional, klabel(_=/=Bool_), symbol, <span class="hljs-literal">left</span>, smt-hook(distinct), hook(BOOL.ne)]
</code></pre>
<h3>Implementation of Booleans</h3>
<p>The remainder of this section consists of an implementation in K of the
operations listed above.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> notBool true =&gt; false<span class="hljs-keyword">
  rule</span> notBool false =&gt; true<span class="hljs-keyword">

  rule</span> true andBool B:<span class="hljs-keyword">Bool</span> =&gt; B:<span class="hljs-keyword">Bool</span><span class="hljs-keyword">
  rule</span> B:<span class="hljs-keyword">Bool</span> andBool true =&gt; B:<span class="hljs-keyword">Bool</span><span class="hljs-keyword">
  rule</span> false andBool _:<span class="hljs-keyword">Bool</span> =&gt; false<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">Bool</span> andBool false =&gt; false<span class="hljs-keyword">

  rule</span> true andThenBool K::<span class="hljs-keyword">Bool</span> =&gt; K<span class="hljs-keyword">
  rule</span> K::<span class="hljs-keyword">Bool</span> andThenBool true =&gt; K<span class="hljs-keyword">
  rule</span> false andThenBool _ =&gt; false<span class="hljs-keyword">
  rule</span> _ andThenBool false =&gt; false<span class="hljs-keyword">

  rule</span> false xorBool B:<span class="hljs-keyword">Bool</span> =&gt; B:<span class="hljs-keyword">Bool</span><span class="hljs-keyword">
  rule</span> B:<span class="hljs-keyword">Bool</span> xorBool false =&gt; B:<span class="hljs-keyword">Bool</span><span class="hljs-keyword">
  rule</span> B:<span class="hljs-keyword">Bool</span> xorBool B:<span class="hljs-keyword">Bool</span> =&gt; false<span class="hljs-keyword">

  rule</span> true orBool _:<span class="hljs-keyword">Bool</span> =&gt; true<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">Bool</span> orBool true =&gt; true<span class="hljs-keyword">
  rule</span> false orBool B:<span class="hljs-keyword">Bool</span> =&gt; B<span class="hljs-keyword">
  rule</span> B:<span class="hljs-keyword">Bool</span> orBool false =&gt; B<span class="hljs-keyword">

  rule</span> true orElseBool _ =&gt; true<span class="hljs-keyword">
  rule</span> _ orElseBool true =&gt; true<span class="hljs-keyword">
  rule</span> false orElseBool K::<span class="hljs-keyword">Bool</span> =&gt; K<span class="hljs-keyword">
  rule</span> K::<span class="hljs-keyword">Bool</span> orElseBool false =&gt; K<span class="hljs-keyword">

  rule</span> true impliesBool B:<span class="hljs-keyword">Bool</span> =&gt; B<span class="hljs-keyword">
  rule</span> false impliesBool _:<span class="hljs-keyword">Bool</span> =&gt; true<span class="hljs-keyword">
  rule</span> _:<span class="hljs-keyword">Bool</span> impliesBool true =&gt; true<span class="hljs-keyword">
  rule</span> B:<span class="hljs-keyword">Bool</span> impliesBool false =&gt; notBool B<span class="hljs-keyword">

  rule</span> B1:<span class="hljs-keyword">Bool</span> =/=<span class="hljs-keyword">Bool</span> B2:<span class="hljs-keyword">Bool</span> =&gt; notBool (B1 ==<span class="hljs-keyword">Bool</span> B2)<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Integers</h2>
<p>Provided here is the syntax of an implementation of arbitrary-precision
integer arithmetic in K. This type is hooked to an implementation of integers
provided by the backend. For a fixed-width integer type, see the <code>MINT</code> module
below.</p>
<p>The <code>UNSIGNED-INT-SYNTAX</code> module provides a syntax of whole numbers in K.
This is useful because often programming languages implement the sign of an
integer as a unary operator rather than part of the lexical syntax of integers.
However, you can also directly reference integers with a sign using the
<code>INT-SYNTAX</code> module.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> UNSIGNED-INT-SYNTAX<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> [hook(INT.<span class="hljs-keyword">Int</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= r<span class="hljs-string">&quot;[0-9]+&quot;</span> [<span class="hljs-literal">prefer</span>, <span class="hljs-literal">token</span>, prec(<span class="hljs-number">2</span>)]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> INT-SYNTAX<span class="hljs-keyword">
  imports</span> UNSIGNED-INT-SYNTAX<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= r<span class="hljs-string">&quot;[\\+-]?[0-9]+&quot;</span> [<span class="hljs-literal">prefer</span>, <span class="hljs-literal">token</span>, prec(<span class="hljs-number">2</span>)]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> INT-COMMON<span class="hljs-keyword">
  imports</span> INT-SYNTAX<span class="hljs-keyword">
  imports</span> BOOL
</code></pre>
<h3>Integer arithmetic</h3>
<p>You can:</p>
<ul>
<li>Compute the bitwise complement <code>~Int</code> of an integer value in twos-complement.</li>
<li>Compute the exponentiation <code>^Int</code> of two integers.</li>
<li>Compute the exponentiation of two integers modulo another integer (<code>^%Int</code>).
<code>A ^%Int B C</code> is equal in value to <code>(A ^Int B) %Int C</code>, but has a better
asymptotic complexity.</li>
<li>Compute the product <code>*Int</code> of two integers.</li>
<li>Compute the quotient <code>/Int</code> or modulus <code>%Int</code> of two integers using
t-division, which rounds towards zero. Division by zero is <code>#False</code>.</li>
<li>Compute the quotient <code>divInt</code> or modulus <code>modInt</code> of two integers using
Euclidean division, in which the remainder is always non-negative. Division
by zero is <code>#False</code>.</li>
<li>Compute the sum <code>+Int</code> or difference <code>-Int</code> of two integers.</li>
<li>Compute the arithmetic right shift <code>&gt;&gt;Int</code> of two integers. Shifting by a
negative quantity is <code>#False</code>.</li>
<li>Compute the left shift of two integers. Shifting by a negative quantity is
<code>#False</code>.</li>
<li>Compute the bitwise and of two integers in twos-complement.</li>
<li>Compute the bitwise xor of two integers in twos-complement.</li>
<li>Compute the bitwise inclusive-or of two integers in twos-complement.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= <span class="hljs-string">&quot;~Int&quot;</span><span class="hljs-keyword"> Int</span>                     [function, klabel(~Int_), symbol, functional, <span class="hljs-literal">latex</span>(\mathop{\sim_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">1</span>}), hook(INT.not), smtlib(notInt)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;^Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, klabel(_^Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(^), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{{\char`\^}_{\!\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.pow)]
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;^%Int&quot;</span><span class="hljs-keyword"> Int</span><span class="hljs-keyword"> Int</span>            [function, klabel(_^%Int__), symbol, <span class="hljs-literal">left</span>, smt-hook((mod (^ #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">3</span>)), hook(INT.powmod)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;*Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, functional, klabel(_*Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(*), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\ast_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.mul)]
               <span class="hljs-comment">/* <span class="hljs-doctag">FIXME:</span> translate /Int and %Int into smtlib */</span>
               <span class="hljs-comment">/* /Int and %Int implement t-division, which rounds towards 0 */</span>
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;/Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, klabel(_/Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(div), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\div_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.tdiv)]
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;%Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, klabel(_%Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(mod), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\%_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.tmod)]
               <span class="hljs-comment">/* divInt and modInt implement e-division according to the Euclidean division theorem, therefore the remainder is always positive */</span>
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;divInt&quot;</span><span class="hljs-keyword"> Int</span>               [function, klabel(_divInt_), symbol, <span class="hljs-literal">left</span>, smt-hook(div), hook(INT.ediv)]
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;modInt&quot;</span><span class="hljs-keyword"> Int</span>               [function, klabel(_modInt_), symbol, <span class="hljs-literal">left</span>, smt-hook(mod), hook(INT.emod)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;+Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, functional, klabel(_+Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(+), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{+_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.add)]
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;-Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, functional, klabel(_-Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(-), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{-_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.sub)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;&gt;&gt;Int&quot;</span><span class="hljs-keyword"> Int</span>                [function, klabel(_&gt;&gt;Int_), symbol, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\gg_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.shr), smtlib(shrInt)]
               |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;&lt;Int&quot;</span><span class="hljs-keyword"> Int</span>                [function, klabel(_&lt;&lt;Int_), symbol, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\ll_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.shl), smtlib(shlInt)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;&amp;Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, functional, klabel(_&amp;Int_), symbol, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\&amp;_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.and), smtlib(andInt)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;xorInt&quot;</span><span class="hljs-keyword"> Int</span>               [function, functional, klabel(_xorInt_), symbol, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\oplus_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.xor), smtlib(xorInt)]
               &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                 Int</span> <span class="hljs-string">&quot;|Int&quot;</span><span class="hljs-keyword"> Int</span>                 [function, functional, klabel(_|Int_), symbol, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{|_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.or), smtlib(orInt)]
</code></pre>
<h3>Integer minimum and maximum</h3>
<p>You can compute the minimum and maximum <code>minInt</code> and <code>maxInt</code> of two integers.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= <span class="hljs-string">&quot;minInt&quot;</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span>   [function, functional, smt-hook((ite (&lt; #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>)), hook(INT.min)]
               | <span class="hljs-string">&quot;maxInt&quot;</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span>   [function, functional, smt-hook((ite (&lt; #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">2</span> #<span class="hljs-number">1</span>)), hook(INT.max)]
</code></pre>
<h3>Absolute value</h3>
<p>You can compute the absolute value <code>absInt</code> of an integer.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= absInt (<span class="hljs-keyword"> Int</span> )                 [function, functional, smt-hook((ite (&lt; #<span class="hljs-number">1</span> <span class="hljs-number">0</span>) (- <span class="hljs-number">0</span> #<span class="hljs-number">1</span>) #<span class="hljs-number">1</span>)), hook(INT.abs)]
</code></pre>
<h3>Log base 2</h3>
<p>You can compute the log base 2, rounded towards zero, of an integer. The log
base 2 of an integer is equal to the index of the highest bit set in the
representation of a positive integer. Log base 2 of zero or a negative number
is <code>#False</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= log2Int (<span class="hljs-keyword"> Int</span> )                [function, hook(INT.log2)]
</code></pre>
<h3>Bit slicing</h3>
<p>You can compute the value of a range of bits in the twos-complement
representation of an integer, as interpeted either unsigned or signed, of an
integer. <code>index</code> is offset from 0 and <code>length</code> is the number of bits, starting
with <code>index</code>, that should be read. The number is assumed to be represented
in little endian notation with each byte going from least significant to
most significant. In other words, 0 is the least-significant bit, and each
successive bit is more significant than the last.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= bitRangeInt           (<span class="hljs-keyword"> Int</span>, index:<span class="hljs-keyword"> Int</span>, length:<span class="hljs-keyword"> Int</span> ) [function, hook(INT.bitRange)]
               | signExtendBitRangeInt (<span class="hljs-keyword"> Int</span>, index:<span class="hljs-keyword"> Int</span>, length:<span class="hljs-keyword"> Int</span> ) [function, hook(INT.signExtendBitRange)]
</code></pre>
<h3>Integer comparisons</h3>
<p>You can compute whether two integers are less than or equal to, less than,
greater than or equal to, greater than, equal, or unequal to another integer.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::=<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;=Int&quot;</span><span class="hljs-keyword"> Int</span>         [function, functional, klabel(_&lt;=Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(&lt;=), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\leq_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.le)]
                |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;Int&quot;</span><span class="hljs-keyword"> Int</span>          [function, functional, klabel(_&lt;Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(&lt;), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{&lt;_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.lt)]
                |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&gt;=Int&quot;</span><span class="hljs-keyword"> Int</span>         [function, functional, klabel(_&gt;=Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(&gt;=), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\geq_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.ge)]
                |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&gt;Int&quot;</span><span class="hljs-keyword"> Int</span>          [function, functional, klabel(_&gt;Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(&gt;), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{&gt;_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.gt)]
                |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;==Int&quot;</span><span class="hljs-keyword"> Int</span>         [function, functional, klabel(_==Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(=), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{{=}{=}_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.eq)]
                |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;=/=Int&quot;</span><span class="hljs-keyword"> Int</span>        [function, functional, klabel(_=/=Int_), symbol, <span class="hljs-literal">left</span>, smt-hook(distinct), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{{=}{/}{=}_{\scriptstyle\it<span class="hljs-keyword"> Int</span>}}{#<span class="hljs-number">2</span>}), hook(INT.ne)]
</code></pre>
<h3>Divides</h3>
<p>You can compute whether one integer evenly divides another. This is the
case when the second integer modulo the first integer is equal to zero.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::=<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;dividesInt&quot;</span><span class="hljs-keyword"> Int</span>    [function]
</code></pre>
<h3>Implementation of Integers</h3>
<p>The remainder of this section consists of an implementation in K of some
of the operators above, as well as lemmas used  by the Java and Haskell backend
to simplify expressions of sort <code>Int</code>. They do not affect the semantics of
integers, merely describing additional rules that the backend can use to
simplify terms.</p>
<pre class="hljs"><code><span class="hljs-keyword">endmodule</span><span class="hljs-keyword">

module</span> INT-SYMBOLIC [symbolic]<span class="hljs-keyword">
  imports</span> INT-COMMON<span class="hljs-keyword">
  imports</span> INT-SYMBOLIC-KORE

  <span class="hljs-comment">// Arithmetic Normalization</span><span class="hljs-keyword">
  rule</span> I +<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span> =&gt; I [simplification]<span class="hljs-keyword">
  rule</span> I -<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span> =&gt; I [simplification]<span class="hljs-keyword">

  rule</span> X modInt N =&gt; X<span class="hljs-keyword"> requires</span> <span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> X andBool X &lt;<span class="hljs-keyword">Int</span> N [simplification]<span class="hljs-keyword">
  rule</span> X   %<span class="hljs-keyword">Int</span> N =&gt; X<span class="hljs-keyword"> requires</span> <span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> X andBool X &lt;<span class="hljs-keyword">Int</span> N [simplification]

  <span class="hljs-comment">// Bit-shifts</span><span class="hljs-keyword">
  rule</span> X &lt;&lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span> =&gt; X [simplification]<span class="hljs-keyword">
  rule</span> <span class="hljs-number">0</span> &lt;&lt;<span class="hljs-keyword">Int</span> _ =&gt; <span class="hljs-number">0</span> [simplification]<span class="hljs-keyword">
  rule</span> X &gt;&gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span> =&gt; X [simplification]<span class="hljs-keyword">
  rule</span> <span class="hljs-number">0</span> &gt;&gt;<span class="hljs-keyword">Int</span> _ =&gt; <span class="hljs-number">0</span> [simplification]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> INT-SYMBOLIC-KORE [symbolic, kore]<span class="hljs-keyword">
  imports</span> INT-COMMON<span class="hljs-keyword">
  imports</span> ML-SYNTAX

  <span class="hljs-comment">// Definability Conditions</span><span class="hljs-keyword">
  rule</span> #Ceil(@I1:<span class="hljs-keyword">Int</span> /<span class="hljs-keyword">Int</span>   @I2:<span class="hljs-keyword">Int</span>) =&gt; {(@I2 =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span>) #Equals true} #And #Ceil(@I1) #And #Ceil(@I2) [anywhere, simplification]<span class="hljs-keyword">
  rule</span> #Ceil(@I1:<span class="hljs-keyword">Int</span> %<span class="hljs-keyword">Int</span>   @I2:<span class="hljs-keyword">Int</span>) =&gt; {(@I2 =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span>) #Equals true} #And #Ceil(@I1) #And #Ceil(@I2) [anywhere, simplification]<span class="hljs-keyword">
  rule</span> #Ceil(@I1:<span class="hljs-keyword">Int</span> modInt @I2:<span class="hljs-keyword">Int</span>) =&gt; {(@I2 =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span>) #Equals true} #And #Ceil(@I1) #And #Ceil(@I2) [anywhere, simplification]<span class="hljs-keyword">
  rule</span> #Ceil(@I1:<span class="hljs-keyword">Int</span> &gt;&gt;<span class="hljs-keyword">Int</span>  @I2:<span class="hljs-keyword">Int</span>) =&gt; {(@I2 &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span>)  #Equals true} #And #Ceil(@I1) #And #Ceil(@I2) [anywhere, simplification]<span class="hljs-keyword">
  rule</span> #Ceil(@I1:<span class="hljs-keyword">Int</span> &lt;&lt;<span class="hljs-keyword">Int</span>  @I2:<span class="hljs-keyword">Int</span>) =&gt; {(@I2 &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span>)  #Equals true} #And #Ceil(@I1) #And #Ceil(@I2) [anywhere, simplification]

  <span class="hljs-comment">// Arithmetic Normalization</span><span class="hljs-keyword">
  rule</span> I +<span class="hljs-keyword">Int</span> B =&gt; B +<span class="hljs-keyword">Int</span> I          [concrete(I), symbolic(B), priority(<span class="hljs-number">51</span>), simplification]<span class="hljs-keyword">
  rule</span> A -<span class="hljs-keyword">Int</span> I =&gt; A +<span class="hljs-keyword">Int</span> (<span class="hljs-number">0</span> -<span class="hljs-keyword">Int</span> I) [concrete(I), symbolic(A), priority(<span class="hljs-number">51</span>), simplification]<span class="hljs-keyword">

  rule</span> (A +<span class="hljs-keyword">Int</span> I2) +<span class="hljs-keyword">Int</span> I3 =&gt; A +<span class="hljs-keyword">Int</span> (I2 +<span class="hljs-keyword">Int</span> I3) [concrete(I2, I3), symbolic(A), simplification]<span class="hljs-keyword">
  rule</span> I1 +<span class="hljs-keyword">Int</span> (B +<span class="hljs-keyword">Int</span> I3) =&gt; B +<span class="hljs-keyword">Int</span> (I1 +<span class="hljs-keyword">Int</span> I3) [concrete(I1, I3), symbolic(B), simplification]<span class="hljs-keyword">
  rule</span> I1 -<span class="hljs-keyword">Int</span> (B +<span class="hljs-keyword">Int</span> I3) =&gt; (I1 -<span class="hljs-keyword">Int</span> I3) -<span class="hljs-keyword">Int</span> B [concrete(I1, I3), symbolic(B), simplification]<span class="hljs-keyword">
  rule</span> I1 +<span class="hljs-keyword">Int</span> (I2 +<span class="hljs-keyword">Int</span> C) =&gt; (I1 +<span class="hljs-keyword">Int</span> I2) +<span class="hljs-keyword">Int</span> C [concrete(I1, I2), symbolic(C), simplification]<span class="hljs-keyword">
  rule</span> I1 +<span class="hljs-keyword">Int</span> (I2 -<span class="hljs-keyword">Int</span> C) =&gt; (I1 +<span class="hljs-keyword">Int</span> I2) -<span class="hljs-keyword">Int</span> C [concrete(I1, I2), symbolic(C), simplification]<span class="hljs-keyword">
  rule</span> (I1 -<span class="hljs-keyword">Int</span> B) +<span class="hljs-keyword">Int</span> I3 =&gt; (I1 +<span class="hljs-keyword">Int</span> I3) -<span class="hljs-keyword">Int</span> B [concrete(I1, I3), symbolic(B), simplification]<span class="hljs-keyword">
  rule</span> I1 -<span class="hljs-keyword">Int</span> (I2 +<span class="hljs-keyword">Int</span> C) =&gt; (I1 -<span class="hljs-keyword">Int</span> I2) -<span class="hljs-keyword">Int</span> C [concrete(I1, I2), symbolic(C), simplification]<span class="hljs-keyword">
  rule</span> I1 -<span class="hljs-keyword">Int</span> (I2 -<span class="hljs-keyword">Int</span> C) =&gt; (I1 -<span class="hljs-keyword">Int</span> I2) +<span class="hljs-keyword">Int</span> C [concrete(I1, I2), symbolic(C), simplification]<span class="hljs-keyword">
  rule</span> (C -<span class="hljs-keyword">Int</span> I2) -<span class="hljs-keyword">Int</span> I3 =&gt; C -<span class="hljs-keyword">Int</span> (I2 +<span class="hljs-keyword">Int</span> I3) [concrete(I2, I3), symbolic(C), simplification]<span class="hljs-keyword">

  rule</span> I1 &amp;<span class="hljs-keyword">Int</span> (I2 &amp;<span class="hljs-keyword">Int</span> C) =&gt; (I1 &amp;<span class="hljs-keyword">Int</span> I2) &amp;<span class="hljs-keyword">Int</span> C [concrete(I1, I2), symbolic(C), simplification]<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> INT-KAST [kast]<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  imports</span> INT-COMMON<span class="hljs-keyword">

  rule</span> I1:<span class="hljs-keyword">Int</span> ==<span class="hljs-keyword">Int</span> I2:<span class="hljs-keyword">Int</span> =&gt; I1 ==K I2<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> INT-KORE [kore]<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  imports</span> INT-COMMON<span class="hljs-keyword">

  rule</span> I1:<span class="hljs-keyword">Int</span> ==K I2:<span class="hljs-keyword">Int</span> =&gt; I1 ==<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> INT<span class="hljs-keyword">
  imports</span> INT-COMMON<span class="hljs-keyword">
  imports</span> INT-SYMBOLIC<span class="hljs-keyword">
  imports</span> INT-KAST<span class="hljs-keyword">
  imports</span> INT-KORE<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">

  rule</span> bitRangeInt(I::<span class="hljs-keyword">Int</span>, IDX::<span class="hljs-keyword">Int</span>, LEN::<span class="hljs-keyword">Int</span>) =&gt; (I &gt;&gt;<span class="hljs-keyword">Int</span> IDX) modInt (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> LEN)<span class="hljs-keyword">

  rule</span> signExtendBitRangeInt(I::<span class="hljs-keyword">Int</span>, IDX::<span class="hljs-keyword">Int</span>, LEN::<span class="hljs-keyword">Int</span>) =&gt; (bitRangeInt(I, IDX, LEN) +<span class="hljs-keyword">Int</span> (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> (LEN -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>))) modInt (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> LEN) -<span class="hljs-keyword">Int</span> (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> (LEN -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>))<span class="hljs-keyword">

  rule</span> I1:<span class="hljs-keyword">Int</span> divInt I2:<span class="hljs-keyword">Int</span> =&gt; (I1 -<span class="hljs-keyword">Int</span> (I1 modInt I2)) /<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  requires</span> I2 =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span>
    I1:<span class="hljs-keyword">Int</span> modInt I2:<span class="hljs-keyword">Int</span>
  =&gt;
    ((I1 %<span class="hljs-keyword">Int</span> absInt(I2)) +<span class="hljs-keyword">Int</span> absInt(I2)) %<span class="hljs-keyword">Int</span> absInt(I2)<span class="hljs-keyword">
  requires</span> I2 =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span>    [concrete, simplification]<span class="hljs-keyword">

  rule</span> minInt(I1:<span class="hljs-keyword">Int</span>, I2:<span class="hljs-keyword">Int</span>) =&gt; I1<span class="hljs-keyword"> requires</span> I1 &lt;=<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">
  rule</span> minInt(I1:<span class="hljs-keyword">Int</span>, I2:<span class="hljs-keyword">Int</span>) =&gt; I2<span class="hljs-keyword"> requires</span> I1 &gt;=<span class="hljs-keyword">Int</span> I2<span class="hljs-keyword">

  rule</span> I1:<span class="hljs-keyword">Int</span> =/=<span class="hljs-keyword">Int</span> I2:<span class="hljs-keyword">Int</span> =&gt; notBool (I1 ==<span class="hljs-keyword">Int</span> I2)<span class="hljs-keyword">
  rule</span> (I1:<span class="hljs-keyword">Int</span> dividesInt I2:<span class="hljs-keyword">Int</span>) =&gt; (I2 %<span class="hljs-keyword">Int</span> I1) ==<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Int</span> ::= freshInt(<span class="hljs-keyword">Int</span>)    [freshGenerator, function, functional]<span class="hljs-keyword">
  rule</span> freshInt(I:<span class="hljs-keyword">Int</span>) =&gt; I<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Int</span> ::= randInt(<span class="hljs-keyword">Int</span>) [function, hook(INT.rand)]<span class="hljs-keyword">
  syntax</span> K ::= srandInt(<span class="hljs-keyword">Int</span>) [function, hook(INT.srand)]<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>IEEE 754 Floating-point Numbers</h2>
<p>Provided here is the syntax of an implementation of arbitrary-precision
floating-point arithmetic in K based on a generalization of the IEEE 754
standard. This type is hooked to an implementation of floats provided by the
backend.</p>
<p>The syntax of ordinary floating-point values in K consists of an optional sign
(+ or -) followed by an optional integer part, followed by a decimal point,
followed by an optional fractional part. Either the integer part or the
fractional part must be specified. The mantissa is followed by an optional
exponent part, which consists of an <code>e</code> or <code>E</code>, an optional sign (+ or -),
and an integer. The expoennt is followed by an optional suffix, which can be
either <code>f</code>, <code>F</code>, <code>d</code>, <code>D</code>, or <code>pNxM</code> where <code>N</code> and <code>M</code> are positive integers.
<code>p</code> and <code>x</code> can be either upper or lowercase.</p>
<p>The value of a floating-point literal is computed as follows: First the
mantissa is read as a rational number. Then it is multiplied by 10 to the
power of the exponent, which is interpreted as an integer, and defaults to
zero if it is not present. Finally, it is rounded to the nearest possible
value in a floating-point type represented like an IEEE754 floating-point type,
with the number of bits of precision and exponent specified by the suffix.
A suffix of <code>f</code> or <code>f</code> represents the IEEE <code>binary32</code> format. A suffix of <code>d</code>
or <code>D</code>, or no suffix, represents the IEEE <code>binary64</code> format. A suffix of
<code>pNxM</code> (either upper or lowercase) specifies exactly <code>N</code> bits of precision and
<code>M</code> bits of exponent. The number of bits of precision is assumed to include
any optional <code>1</code> that precedes the IEEE 754 mantissa. In other words, <code>p24x8</code>
is equal to the IEEE <code>binary32</code> format, and <code>p53x11</code> is equal to the IEEE
<code>binary64</code> format.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> FLOAT-SYNTAX<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Float</span> [hook(FLOAT.<span class="hljs-keyword">Float</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Float</span> ::= r<span class="hljs-string">&quot;([\\+-]?[0-9]+(\\.[0-9]*)?|\\.[0-9]+)([eE][\\+-]?[0-9]+)?([fFdD]|([pP][0-9]+[xX][0-9]+))?&quot;</span> [<span class="hljs-literal">token</span>, prec(<span class="hljs-number">1</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Float</span> ::= r<span class="hljs-string">&quot;[\\+-]?Infinity([fFdD]|([pP][0-9]+[xX][0-9]+))?&quot;</span> [<span class="hljs-literal">token</span>, prec(<span class="hljs-number">3</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Float</span> ::= r<span class="hljs-string">&quot;NaN([fFdD]|([pP][0-9]+[xX][0-9]+))?&quot;</span> [<span class="hljs-literal">token</span>, prec(<span class="hljs-number">3</span>)]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> FLOAT<span class="hljs-keyword">
  imports</span> FLOAT-SYNTAX<span class="hljs-keyword">
  imports</span> BOOL<span class="hljs-keyword">
  imports</span> INT-SYNTAX
</code></pre>
<h3>Float precision</h3>
<p>You can retrieve the number of bits of precision in a <code>Float</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= precisionFloat(<span class="hljs-keyword">Float</span>) [function, functional, hook(FLOAT.precision)]
</code></pre>
<h3>Float exponent bits</h3>
<p>You can retrieve the number of bits of exponent range in a <code>Float</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= exponentBitsFloat(<span class="hljs-keyword">Float</span>) [function, functional, hook(FLOAT.exponentBits)]
</code></pre>
<h3>Float exponent</h3>
<p>You can retrieve the value of the exponent bits of a <code>Float</code> as an integer.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= exponentFloat(<span class="hljs-keyword">Float</span>) [function, functional, hook(FLOAT.exponent)]
</code></pre>
<h3>Float sign</h3>
<p>You can retrieve the value of the sign bit of a <code>Float</code> as a boolean. True
means the sign bit is set.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= signFloat(<span class="hljs-keyword">Float</span>)      [function, functional, hook(FLOAT.sign)]
</code></pre>
<h3>Float special values</h3>
<p>You can check whether a <code>Float</code> value is infinite or Not-a-Number.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= isNaN(<span class="hljs-keyword">Float</span>)          [function, functional, smt-hook(fp.isNaN), hook(FLOAT.isNaN)]
                | isInfinite(<span class="hljs-keyword">Float</span>)     [function, functional]
</code></pre>
<h3>Float arithmetic</h3>
<p>You can:</p>
<ul>
<li>Compute the unary negation <code>--Float</code> of a float. <code>--Float X</code> is distinct
from <code>0.0 -Float X</code>. For example, <code>0.0 -Float 0.0</code> is positive zero.
<code>--Float 0.0</code> is negative zero.</li>
<li>Compute the exponentation <code>^Float</code> of two floats.</li>
<li>Compute the product <code>*Float</code>, quotient <code>/Float</code>, or remainder <code>%Float</code> of two
floats. The remainder is computed based on rounding the quotient of the two
floats to the nearest integer.</li>
<li>Compute the sum <code>+Float</code> or difference <code>-Float</code> of two floats.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Float</span> ::= <span class="hljs-string">&quot;--Float&quot;</span><span class="hljs-keyword"> Float</span>             [function, functional, smt-hook(fp.neg), hook(FLOAT.neg)]
                 &gt;<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;^Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}^{#<span class="hljs-number">2</span>}), hook(FLOAT.pow)]
                 &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                   Float</span> <span class="hljs-string">&quot;*Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook((fp.mul roundNearestTiesToEven #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>)), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\ast_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.mul)]
                 |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;/Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook((fp.div roundNearestTiesToEven #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>)), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\div_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.div)]
                 |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;%Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook((fp.rem roundNearestTiesToEven #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>)), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\%_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.rem)]
                 &gt; <span class="hljs-literal">left</span>:<span class="hljs-keyword">
                   Float</span> <span class="hljs-string">&quot;+Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook((fp.add roundNearestTiesToEven #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>)), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{+_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.add)]
                 |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;-Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook((fp.sub roundNearestTiesToEven #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>)), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{-_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.sub)]
</code></pre>
<h3>Floating-point mathematics</h3>
<p>You can:</p>
<ul>
<li>Compute the Nth integer root <code>rootFloat</code> of a float.</li>
<li>Compute the absolute value <code>absFloat</code> of a float.</li>
<li>Round a floating-point number to a specified precision and exponent
range (<code>roundFloat</code>). The resulting <code>Float</code> will yield the specified values
when calling <code>precisionFloat and </code>exponentBitsFloat` and when performing
further computation.</li>
<li>Round a float to the next lowest floating-point value which is an integer
(<code>floorFloat</code>).</li>
<li>Round a float to the next highest floating-point value which is an integer
(<code>ceilFloat</code>).</li>
<li>Compute the natural exponential <code>expFloat</code> of a float (i.e. e^x).</li>
<li>Compute the natural logarithm <code>logFloat</code> of a float.</li>
<li>Compute the sine <code>sinFloat</code> of a float.</li>
<li>Compute the cosine <code>cosFloat</code> of a float.</li>
<li>Compute the tangent <code>tanFlooat</code> of a float.</li>
<li>Compute the arcsine <code>asinFloat</code> of a float.</li>
<li>Compute the arccosine <code>acosFloat</code> of a float.</li>
<li>Compute the arctangent <code>atanFloat</code> of a float.</li>
<li>Compute the arctangent <code>atan2Float</code> of two floats.</li>
<li>Compute the maximum <code>maxFloat</code> of two floats.</li>
<li>Compute the minimum <code>minFloat</code> of two floats.</li>
<li>Compute the square root <code>sqrtFloat</code> of a float.</li>
<li>Compute the largest finite value expressible in a specified precision and
exponent range (<code>maxValueFloat</code>).</li>
<li>Compute the smallest positive finite value expressible in a specified
precision and exponent range (<code>minValueFloat</code>).</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Float</span> ::= rootFloat(<span class="hljs-keyword">Float</span>,<span class="hljs-keyword"> Int</span>)        [function, hook(FLOAT.root)]
                 | absFloat(<span class="hljs-keyword">Float</span>)              [function, functional, smt-hook(fp.abs), hook(FLOAT.abs)]
                 | roundFloat(<span class="hljs-keyword">Float</span>, precision:<span class="hljs-keyword"> Int</span>, exponentBits:<span class="hljs-keyword"> Int</span>)  [function, hook(FLOAT.round)]
                 | floorFloat(<span class="hljs-keyword">Float</span>)            [function, functional, hook(FLOAT.floor)]
                 | ceilFloat(<span class="hljs-keyword">Float</span>)             [function, functional, hook(FLOAT.ceil)]
                 | expFloat(<span class="hljs-keyword">Float</span>)              [function, functional, hook(FLOAT.exp)]
                 | logFloat(<span class="hljs-keyword">Float</span>)              [function, hook(FLOAT.log)]
                 | sinFloat(<span class="hljs-keyword">Float</span>)              [function, functional, hook(FLOAT.sin)]
                 | cosFloat(<span class="hljs-keyword">Float</span>)              [function, functional, hook(FLOAT.cos)]
                 | tanFloat(<span class="hljs-keyword">Float</span>)              [function, hook(FLOAT.tan)]
                 | asinFloat(<span class="hljs-keyword">Float</span>)             [function, hook(FLOAT.asin)]
                 | acosFloat(<span class="hljs-keyword">Float</span>)             [function, hook(FLOAT.acos)]
                 | atanFloat(<span class="hljs-keyword">Float</span>)             [function, functional, hook(FLOAT.atan)]
                 | atan2Float(<span class="hljs-keyword">Float</span>,<span class="hljs-keyword"> Float</span>)     [function, hook(FLOAT.atan2)]
                 | maxFloat(<span class="hljs-keyword">Float</span>,<span class="hljs-keyword"> Float</span>)       [function, smt-hook(fp.max), hook(FLOAT.max)]
                 | minFloat(<span class="hljs-keyword">Float</span>,<span class="hljs-keyword"> Float</span>)       [function, smt-hook(fp.min), hook(FLOAT.min)]
                 | sqrtFloat(<span class="hljs-keyword">Float</span>)             [function]
                 | maxValueFloat(precision:<span class="hljs-keyword"> Int</span>, exponentBits:<span class="hljs-keyword"> Int</span>)      [function, hook(FLOAT.maxValue)]
                 | minValueFloat(precision:<span class="hljs-keyword"> Int</span>, exponentBits:<span class="hljs-keyword"> Int</span>)      [function, hook(FLOAT.minValue)]
</code></pre>
<h3>Floating-point comparisons</h3>
<p>Compute whether a float is less than or equasl to, less than, greater than or
equal to, greater than, equal, or unequal to another float. Note that
<code>X ==Float Y</code> and <code>X ==K Y</code> might yield different values. The latter should be
used in cases where you want to compare whether two values of sort <code>Float</code>
contain the same term. The former should be used when you want to implement
the <code>==</code> operator of a programming language. In particular, <code>NaN =/=Float NaN</code>
is true, because <code>NaN</code> compares unequal to all values, including itself, in
IEEE 754 arithmetic. <code>0.0 ==Float -0.0</code> is also true.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::=<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;&lt;=Float&quot;</span><span class="hljs-keyword"> Float</span>       [function, <span class="hljs-literal">left</span>, smt-hook(fp.leq), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\leq_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.le)]
                |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;&lt;Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook(fp.lt), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{&lt;_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.lt)]
                |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;&gt;=Float&quot;</span><span class="hljs-keyword"> Float</span>       [function, <span class="hljs-literal">left</span>, smt-hook(fp.geq), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\geq_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.ge)]
                |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;&gt;Float&quot;</span><span class="hljs-keyword"> Float</span>        [function, <span class="hljs-literal">left</span>, smt-hook(fg.gt), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{&gt;_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.gt)]
                |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;==Float&quot;</span><span class="hljs-keyword"> Float</span>       [function, <span class="hljs-literal">left</span>, smt-hook(fp.eq), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{==_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>}), hook(FLOAT.eq), klabel(_==Float_)]
                |<span class="hljs-keyword"> Float</span> <span class="hljs-string">&quot;=/=Float&quot;</span><span class="hljs-keyword"> Float</span>      [function, <span class="hljs-literal">left</span>, smt-hook((not (fp.eq #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>))), <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\neq_{\scriptstyle\it<span class="hljs-keyword"> Float</span>}}{#<span class="hljs-number">2</span>})]<span class="hljs-keyword">

  rule</span> F1:<span class="hljs-keyword">Float</span> =/=<span class="hljs-keyword">Float</span> F2:<span class="hljs-keyword">Float</span> =&gt; notBool (F1 ==<span class="hljs-keyword">Float</span> F2)
</code></pre>
<h3>Conversion between integer and float</h3>
<p>You can convert an integer to a floating-point number with the specified
precision and exponent range. You can also convert a floating-point number
to the nearest integer. This operation rounds to the nearest integer, but it
also avoids the double-rounding that is present in <code>ceilFloat</code> and <code>floorFloat</code>
if the nearest integer is not representable in the specified floating-point
type.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Float</span> ::= Int2Float(<span class="hljs-keyword">Int</span>, precision:<span class="hljs-keyword"> Int</span>, exponentBits:<span class="hljs-keyword"> Int</span>)    [function, <span class="hljs-literal">latex</span>({\\it{}Int2Float}), hook(FLOAT.int2float)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= Float2Int(<span class="hljs-keyword">Float</span>)    [function, functional, <span class="hljs-literal">latex</span>({\\it{}Float2Int}), hook(FLOAT.float2int)]
</code></pre>
<h3>Implementation of Floats</h3>
<p>The remainder of this section consists of an implementation in K of some of the
operators above.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> sqrtFloat(F:<span class="hljs-keyword">Float</span>) =&gt; rootFloat(F, <span class="hljs-number">2</span>)<span class="hljs-keyword">

  rule</span> isInfinite(F:<span class="hljs-keyword">Float</span>) =&gt; F &gt;<span class="hljs-keyword">Float</span> maxValueFloat(precisionFloat(F), exponentBitsFloat(F)) orBool F &lt;<span class="hljs-keyword">Float</span> --<span class="hljs-keyword">Float</span> maxValueFloat(precisionFloat(F), exponentBitsFloat(F))<span class="hljs-keyword">

endmodule</span>
</code></pre>
<h2>Strings</h2>
<p>Provided here is the syntax of an implementation of Unicode strings in K. This
type is hooked to an implementation of strings provided by the backend. The
implementation is currently incomplete and does not fully support encodings
and code points beyond the initial 256 code points of the Basic Latin and
Latin-1 Supplement blocks. In the future, there may be breaking changes to
the semantics of this module in order to support this functionality.</p>
<p>The syntax of strings in K is delineated by double quotes. Inside the double
quotes, any character can appear verbatim except double quotes, backslash,
newline, and carriage return. K also supports the following escape sequences:</p>
<ul>
<li>&quot; - the &quot; character</li>
<li>\ - the \ character</li>
<li>\n - newline character</li>
<li>\r - carriage return character</li>
<li>\t - tab character</li>
<li>\f - form feed character</li>
<li>\xFF - \x followed by two hexadecimal characters indicates a code point
between 0x00 and 0xff</li>
<li>\uFFFF - \u followed by four hexadecimal characters indicates a code point
between 0x0000 and 0xffff</li>
<li>\UFFFFFFFF - \U followed by eight hexadecimal characters indicates a code
point between 0x000000 and 0x10ffff</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> STRING-SYNTAX<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> [hook(STRING.<span class="hljs-keyword">String</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= r<span class="hljs-string">&quot;[\\\&quot;](([^\\\&quot;\\n\\r\\\\])|([\\\\][nrtf\\\&quot;\\\\])|([\\\\][x][0-9a-fA-F]{2})|([\\\\][u][0-9a-fA-F]{4})|([\\\\][U][0-9a-fA-F]{8}))*[\\\&quot;]&quot;</span>      [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> STRING-COMMON<span class="hljs-keyword">
  imports</span> STRING-SYNTAX<span class="hljs-keyword">
  imports</span> INT<span class="hljs-keyword">
  imports</span> FLOAT-SYNTAX<span class="hljs-keyword">
  imports</span> K-EQUAL
</code></pre>
<h3>String concatenation</h3>
<p>You can concatenate two strings in O(N) time. For successive concatenation
operations, it may be better to use the <code>STRING-BUFFER</code> module.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::=<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;+String&quot;</span><span class="hljs-keyword"> String</span>    [function, functional, <span class="hljs-literal">left</span>, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}+_{\scriptstyle\it<span class="hljs-keyword"> String</span>}{#<span class="hljs-number">2</span>}), hook(STRING.concat)]
</code></pre>
<h3>String length</h3>
<p>You can get the length of a string in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= lengthString (<span class="hljs-keyword"> String</span> ) [function, functional, hook(STRING.length)]
</code></pre>
<h3>Character and integer conversion</h3>
<p>You can convert between a character (as represented by a string containing
a single code point) and an integer in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::= chrChar (<span class="hljs-keyword"> Int</span> )      [function, hook(STRING.chr)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= ordChar (<span class="hljs-keyword"> String</span> )      [function, hook(STRING.ord)]
</code></pre>
<h3>String substring</h3>
<p>You can compute a substring of a string in O(N) time (where N is the
length of the substring). Note that the range generated is
<code>[startIndex..endIndex)</code></p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::= substrString (<span class="hljs-keyword"> String</span> , startIndex:<span class="hljs-keyword"> Int</span> , endIndex:<span class="hljs-keyword"> Int</span> ) [function, functional, hook(STRING.substr)]
</code></pre>
<h3>String search</h3>
<p>You can find the first (respectively, last) occurrence of a string, starting
at a certain <code>index</code>, in another string in O(N*M) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= findString ( haystack:<span class="hljs-keyword"> String</span> , needle:<span class="hljs-keyword"> String</span> , index:<span class="hljs-keyword"> Int</span> )   [function, hook(STRING.find)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= rfindString ( haystack:<span class="hljs-keyword"> String</span> , needle:<span class="hljs-keyword"> String</span> , index:<span class="hljs-keyword"> Int</span> )  [function, hook(STRING.rfind)]
</code></pre>
<h3>String character search</h3>
<p>You can find the first (respectively, last) occurrence of one of the characters
of the search string, starting at a certain <code>index</code>, in another string in
O(N*M) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= findChar ( haystack:<span class="hljs-keyword"> String</span> , needles:<span class="hljs-keyword"> String</span> , index:<span class="hljs-keyword"> Int</span> )     [function, hook(STRING.findChar)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= rfindChar ( haystack:<span class="hljs-keyword"> String</span> , needles:<span class="hljs-keyword"> String</span> , index:<span class="hljs-keyword"> Int</span> )    [function, hook(STRING.rfindChar)]
</code></pre>
<h3>String and float conversion</h3>
<p>You can convert between a <code>String</code> and a <code>Float</code>. The String will be
represented in the syntax of the <code>Float</code> sort (see the section on the <code>FLOAT</code>
module above for details of that syntax). Which particular string is returned
by <code>Float2String</code> is determined by the backend, but the same <code>Float</code> is
guaranteed to return the same <code>String</code>, and converting that <code>String</code> back to a
<code>Float</code> is guaranteed to return the original <code>Float</code>.</p>
<p>You can also convert a <code>Float</code> to a string in a particular syntax using the
variant of <code>Float2String</code> with a <code>format</code>. In this case, the resulting string
is one which results directly from passing that <code>format</code> to <code>mpfr_printf</code>. This
functionality may not be supported on backends that do not use Gnu MPFR to
implement floating-point numbers.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::= Float2String (<span class="hljs-keyword"> Float</span> )              [function, functional, hook(STRING.float2string)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= Float2String (<span class="hljs-keyword"> Float</span> , format:<span class="hljs-keyword"> String</span> )     [function, klabel(FloatFormat), hook(STRING.floatFormat)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Float</span>  ::= String2Float (<span class="hljs-keyword"> String</span> )             [function, hook(STRING.string2float)]
</code></pre>
<h3>String and integer conversions</h3>
<p>You can convert between a <code>String</code> and an <code>Int</code>. The String will be represented
in the syntax of the <code>INT</code> module (i.e., a nonempty sequence of digits
optionally prefixed by a sign). When converting from an <code>Int</code> to a <code>String</code>,
the sign will not be present unless the integer is negative.</p>
<p>You can also convert between a <code>String</code> and an <code>Int</code> in a particular radix.
This radix can be anywhere between 2 and 36. For a radix 2 &lt;= N &lt;= 10, the
digits 0 to N-1 will be used. For a radix 11 &lt;= N &lt;= 36, the digits 0 to 9
and the first N-10 letters of the Latin alphabet will be used. Both uppercase
and lowercase letters are supported by <code>String2Base</code>. Whether the letters
returned by <code>Base2String</code> are upper or lowercase is determined by the backend,
but the backend will consistently choose one or the other.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span>    ::= String2Int   (<span class="hljs-keyword"> String</span> )             [function, hook(STRING.string2int)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= Int2String   (<span class="hljs-keyword"> Int</span> )                [function, functional, hook(STRING.int2string)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= Base2String  (<span class="hljs-keyword"> Int</span> , base:<span class="hljs-keyword"> Int</span> )          [function, hook(STRING.base2string)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span>    ::= String2Base  (<span class="hljs-keyword"> String</span> , base:<span class="hljs-keyword"> Int</span> )       [function, hook(STRING.string2base)]
</code></pre>
<h3>String count and replace</h3>
<p>You can replace one, some, or all occurrences of a string within another
string in O(N*M) time. The <code>replaceAll</code>, <code>replace</code>, and <code>replaceFirst</code> methods
are identical, except <code>replaceFirst</code> replaces exactly one ocurrence of the
string, the first occurrence. <code>replace</code> replaces the first <code>times</code> occurrences.
And <code>replaceAll</code> replaces every occurrence.</p>
<p>You can also count the number of times a string occurs within another string
using <code>countAllOccurrences</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::= <span class="hljs-string">&quot;replaceAll&quot;</span> <span class="hljs-string">&quot;(&quot;</span> haystack:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> needle:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> replacement:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span>      [function, functional, hook(STRING.replaceAll)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= <span class="hljs-string">&quot;replace&quot;</span> <span class="hljs-string">&quot;(&quot;</span> haystack:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> needle:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> replacement:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> times:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(STRING.replace)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= <span class="hljs-string">&quot;replaceFirst&quot;</span> <span class="hljs-string">&quot;(&quot;</span> haystack:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> needle:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> replacement:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span>    [function, functional, hook(STRING.replaceFirst)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= <span class="hljs-string">&quot;countAllOccurrences&quot;</span> <span class="hljs-string">&quot;(&quot;</span> haystack:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> needle:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span>            [function, functional, hook(STRING.countAllOccurrences)]
</code></pre>
<h3>String equality and lexicographic comparison</h3>
<p>You can compare whether two strings are equal or unequal, or whether one string
is less than, less than or equal to, greater than, or greater than or equal to
another according to the natural lexicographic ordering of strings.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::=<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;==String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, <span class="hljs-literal">left</span>, hook(STRING.eq)]
                |<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;=/=String&quot;</span><span class="hljs-keyword"> String</span>      [function, functional, <span class="hljs-literal">left</span>, hook(STRING.ne)]<span class="hljs-keyword">
  rule</span> S1:<span class="hljs-keyword">String</span> =/=<span class="hljs-keyword">String</span> S2:<span class="hljs-keyword">String</span> =&gt; notBool (S1 ==<span class="hljs-keyword">String</span> S2)<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Bool</span> ::=<span class="hljs-keyword"> String</span>  <span class="hljs-string">&quot;&lt;String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, hook(STRING.lt)]
                |<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;&lt;=String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, hook(STRING.le)]
                |<span class="hljs-keyword"> String</span>  <span class="hljs-string">&quot;&gt;String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, hook(STRING.gt)]
                |<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;&gt;=String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, hook(STRING.ge)]
</code></pre>
<h3>Implementation of Strings</h3>
<p>What follows is a few String hooks which are deprecated and only are supported
on certain outdated backends of K, as well as an implementation of several
of the above operations in K.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::= categoryChar(<span class="hljs-keyword">String</span>)       [function, hook(STRING.category)]
                  | directionalityChar(<span class="hljs-keyword">String</span>) [function, hook(STRING.directionality)]<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> String</span> ::= <span class="hljs-string">&quot;newUUID&quot;</span> [function, hook(STRING.uuid), impure]<span class="hljs-keyword">

  rule</span> S1:<span class="hljs-keyword">String</span> &lt;=<span class="hljs-keyword">String</span> S2:<span class="hljs-keyword">String</span> =&gt; notBool (S2 &lt;<span class="hljs-keyword">String</span> S1)<span class="hljs-keyword">
  rule</span> S1:<span class="hljs-keyword">String</span> &gt;<span class="hljs-keyword">String</span> S2:<span class="hljs-keyword">String</span> =&gt; S2 &lt;<span class="hljs-keyword">String</span> S1<span class="hljs-keyword">
  rule</span> S1:<span class="hljs-keyword">String</span> &gt;=<span class="hljs-keyword">String</span> S2:<span class="hljs-keyword">String</span> =&gt; notBool (S1 &lt;<span class="hljs-keyword">String</span> S2)<span class="hljs-keyword">

  rule</span> findChar(S1:<span class="hljs-keyword">String</span>, S2:<span class="hljs-keyword">String</span>, I:<span class="hljs-keyword">Int</span>) =&gt; #if findString(S1, substrString(S2, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), I) ==<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span> #then findChar(S1, substrString(S2, <span class="hljs-number">1</span>, lengthString(S2)), I) #else #if findChar(S1, substrString(S2, <span class="hljs-number">1</span>, lengthString(S2)), I) ==<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span> #then findString(S1, substrString(S2, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), I) #else minInt(findString(S1, substrString(S2, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), I), findChar(S1, substrString(S2, <span class="hljs-number">1</span>, lengthString(S2)), I)) #fi #fi<span class="hljs-keyword"> requires</span> S2 =/=<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">
  rule</span> findChar(_, <span class="hljs-string">&quot;&quot;</span>, _) =&gt; <span class="hljs-number">-1</span><span class="hljs-keyword">
  rule</span> rfindChar(S1:<span class="hljs-keyword">String</span>, S2:<span class="hljs-keyword">String</span>, I:<span class="hljs-keyword">Int</span>) =&gt; maxInt(rfindString(S1, substrString(S2, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), I), rfindChar(S1, substrString(S2, <span class="hljs-number">1</span>, lengthString(S2)), I))<span class="hljs-keyword"> requires</span> S2 =/=<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">
  rule</span> rfindChar(_, <span class="hljs-string">&quot;&quot;</span>, _) =&gt; <span class="hljs-number">-1</span><span class="hljs-keyword">

  rule</span> countAllOccurrences(Source:<span class="hljs-keyword">String</span>, ToCount:<span class="hljs-keyword">String</span>) =&gt; <span class="hljs-number">0</span><span class="hljs-keyword">
            requires</span> findString(Source, ToCount, <span class="hljs-number">0</span>) &lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> countAllOccurrences(Source:<span class="hljs-keyword">String</span>, ToCount:<span class="hljs-keyword">String</span>) =&gt; <span class="hljs-number">1</span> +<span class="hljs-keyword">Int</span> countAllOccurrences(substrString(Source, findString(Source, ToCount, <span class="hljs-number">0</span>) +<span class="hljs-keyword">Int</span> lengthString(ToCount), lengthString(Source)), ToCount)<span class="hljs-keyword">
            requires</span> findString(Source, ToCount, <span class="hljs-number">0</span>) &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">

  rule</span> replaceFirst(Source:<span class="hljs-keyword">String</span>, ToReplace:<span class="hljs-keyword">String</span>, Replacement:<span class="hljs-keyword">String</span>) =&gt; substrString(Source, <span class="hljs-number">0</span>, findString(Source, ToReplace, <span class="hljs-number">0</span>))
                +<span class="hljs-keyword">String</span> Replacement +<span class="hljs-keyword">String</span> substrString(Source, findString(Source, ToReplace, <span class="hljs-number">0</span>) +<span class="hljs-keyword">Int</span> lengthString(ToReplace), lengthString(Source))<span class="hljs-keyword">
                requires</span> findString(Source, ToReplace, <span class="hljs-number">0</span>) &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> replaceFirst(Source:<span class="hljs-keyword">String</span>, ToReplace:<span class="hljs-keyword">String</span>, _:<span class="hljs-keyword">String</span>) =&gt; Source<span class="hljs-keyword">
        requires</span> findString(Source, ToReplace, <span class="hljs-number">0</span>) &lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">


  rule</span> replace(Source:<span class="hljs-keyword">String</span>, ToReplace:<span class="hljs-keyword">String</span>, Replacement:<span class="hljs-keyword">String</span>, Count:<span class="hljs-keyword">Int</span>) =&gt;
       substrString(Source, <span class="hljs-number">0</span>, findString(Source, ToReplace, <span class="hljs-number">0</span>)) +<span class="hljs-keyword">String</span> Replacement +<span class="hljs-keyword">String</span>
       replace(substrString(Source, findString(Source, ToReplace, <span class="hljs-number">0</span>) +<span class="hljs-keyword">Int</span> lengthString(ToReplace), lengthString(Source)), ToReplace, Replacement, Count -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>)<span class="hljs-keyword">
        requires</span> Count &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> replace(Source:<span class="hljs-keyword">String</span>, _, _, <span class="hljs-number">0</span>) =&gt; Source<span class="hljs-keyword">
  rule</span> replaceAll(Source:<span class="hljs-keyword">String</span>, ToReplace:<span class="hljs-keyword">String</span>, Replacement:<span class="hljs-keyword">String</span>) =&gt; replace(Source, ToReplace, Replacement, countAllOccurrences(Source, ToReplace))<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> STRING-KAST [kast]<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  imports</span> STRING-COMMON<span class="hljs-keyword">

  rule</span> S1:<span class="hljs-keyword">String</span> ==<span class="hljs-keyword">String</span> S2:<span class="hljs-keyword">String</span> =&gt; S1 ==K S2<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> STRING-KORE [kore]<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  imports</span> STRING-COMMON<span class="hljs-keyword">

  rule</span> S1:<span class="hljs-keyword">String</span> ==K S2:<span class="hljs-keyword">String</span> =&gt; S1 ==<span class="hljs-keyword">String</span> S2<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> STRING<span class="hljs-keyword">
  imports</span> STRING-COMMON<span class="hljs-keyword">
  imports</span> STRING-KAST<span class="hljs-keyword">
  imports</span> STRING-KORE<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>String Buffers</h2>
<p>It is a well known fact that repeated string concatenations are quadratic
in performance whereas use of an efficient mutable representation of arrays
can yield linear performance. We thus provide such a sort, the <code>StringBuffer</code>
sort. Axiomatically, it is implemented below on symbolic backends using the
<code>String</code> module. However, on concrete backends it provides an efficient
implementation of string concatenation. There are three operations:</p>
<ul>
<li><code>.StringBuffer</code> creates a new <code>StringBuffer</code> with current content equal
to the empty string.</li>
<li><code>+String</code> takes a <code>StringBuffer</code> and a <code>String</code> and appends the <code>String</code> to
the end of the <code>StringBuffer</code></li>
<li><code>StringBuffer2String</code> converts a <code>StringBuffer</code> to a <code>String</code>. This operation
copies the string so that subsequent modifications to the <code>StringBuffer</code>
will not change the value of the <code>String</code> returned by this function.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> STRING-BUFFER-IN-K [symbolic]<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">

  syntax</span> StringBuffer ::= <span class="hljs-string">&quot;.StringBuffer&quot;</span> [function, functional]<span class="hljs-keyword">
  syntax</span> StringBuffer ::= StringBuffer <span class="hljs-string">&quot;+String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, <span class="hljs-literal">left</span>, <span class="hljs-literal">avoid</span>]<span class="hljs-keyword">
  syntax</span> StringBuffer ::=<span class="hljs-keyword"> String</span><span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= StringBuffer2String ( StringBuffer ) [function, functional]<span class="hljs-keyword">

  rule</span> {SB:<span class="hljs-keyword">String</span> +<span class="hljs-keyword">String</span> S:<span class="hljs-keyword">String</span>}&lt;:StringBuffer =&gt; (SB +<span class="hljs-keyword">String</span> S)::<span class="hljs-keyword">String</span><span class="hljs-keyword">
  rule</span> .StringBuffer =&gt; <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">
  rule</span> StringBuffer2String(S:<span class="hljs-keyword">String</span>) =&gt; S<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> STRING-BUFFER-HOOKED [concrete]<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">

  syntax</span> StringBuffer [hook(BUFFER.StringBuffer)]<span class="hljs-keyword">
  syntax</span> StringBuffer ::= <span class="hljs-string">&quot;.StringBuffer&quot;</span> [function, functional, hook(BUFFER.empty), impure]<span class="hljs-keyword">
  syntax</span> StringBuffer ::= StringBuffer <span class="hljs-string">&quot;+String&quot;</span><span class="hljs-keyword"> String</span> [function, functional, <span class="hljs-literal">left</span>, hook(BUFFER.concat), <span class="hljs-literal">avoid</span>]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= StringBuffer2String ( StringBuffer ) [function, functional, hook(BUFFER.toString)]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> STRING-BUFFER<span class="hljs-keyword">
  imports</span> STRING-BUFFER-HOOKED<span class="hljs-keyword">
  imports</span> STRING-BUFFER-IN-K<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Byte Arrays</h2>
<p>Provided here is the syntax of an implementation of fixed-width arrays of Bytes
in K. This type is hooked to an implementation of bytes provided by the
backend. In concrete backends, this representation is mutable and thus multiple
references can occur to the same <code>Bytes</code> object and when one is modified, the
others are also modified. Care should be taken not to rely on this fact however
as this is not the case in symbolic backends and thus you will experience
divergent behavior unless the <code>Bytes</code> type is used in a manner that preserves
consistency.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> BYTES-HOOKED<span class="hljs-keyword">
  imports</span> STRING-SYNTAX<span class="hljs-keyword">

  syntax</span> Bytes [hook(BYTES.Bytes), <span class="hljs-literal">token</span>]
</code></pre>
<h3>Empty byte array</h3>
<p>The byte array of length zero is represented by <code>.Bytes</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= <span class="hljs-string">&quot;.Bytes&quot;</span> [function, functional, hook(BYTES.empty)]
</code></pre>
<h3>Endianness</h3>
<p>When converting to/from an integer, byte arrays can be treated as either little
endian (ie, least significant byte first) or big endian (ie, most significant
byte first).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Endianness ::= <span class="hljs-string">&quot;LE&quot;</span> [klabel(littleEndianBytes), symbol]
                      | <span class="hljs-string">&quot;BE&quot;</span> [klabel(bigEndianBytes), symbol]
</code></pre>
<h3>Signedness</h3>
<p>When converting to/from an integer, byte arrays can be treated as either signed
or unsigned.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Signedness ::= <span class="hljs-string">&quot;Signed&quot;</span> [klabel(signedBytes), symbol]
                      | <span class="hljs-string">&quot;Unsigned&quot;</span> [klabel(unsignedBytes), symbol]
</code></pre>
<h3>Integer and Bytes conversion</h3>
<p>You can convert from a <code>Bytes</code> to an <code>Int</code>. In order to do this, the endianness
and signedness of the <code>Bytes</code> must be provided. The resulting integer is
created by means of interpreting the <code>Bytes</code> as either a twos-complement
representation, or an unsigned representation, of an integer, in the specified
byte order.</p>
<p>You can also convert from an <code>Int</code> to a <code>Bytes</code>. This comes in two variants.
In the first, the <code>length</code> of the resulting <code>Bytes</code> in bytes is explicitly
specified. If the <code>length</code> is greater than the highest set bit in the magnitude
of the integer, the result is padded with 0 bits if the number is positive
and 1 bits if the number is negative. If the <code>length</code> is less than the highest
bit set in the magnitude of the integer, the most-significant bits of the
integer will be truncated. The endianness of the resulting <code>Bytes</code> object
is as specified.</p>
<p>In the second variant, both endianness and signedness are specified, and
the resulting <code>Bytes</code> object will be the smallest number of bytes necessary
for the resulting <code>Bytes</code> object to be convertible back to the original integer
via <code>Bytes2Int</code>. In other words, if the highest bit set in the magnitude of the
integer is N, then the byte array will be at least N+1 bits long, rounded up
to the nearest byte.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= Bytes2Int(Bytes, Endianness, Signedness) [function, functional, hook(BYTES.bytes2int)]<span class="hljs-keyword">
  syntax</span> Bytes ::= Int2Bytes(length:<span class="hljs-keyword"> Int</span>,<span class="hljs-keyword"> Int</span>, Endianness) [function, functional, hook(BYTES.int2bytes)]
                 | Int2Bytes(<span class="hljs-keyword">Int</span>, Endianness, Signedness) [function, functional, klabel(Int2BytesNoLen)]
</code></pre>
<h3>String and Bytes conversion</h3>
<p>You can convert between a <code>Bytes</code> and a <code>String</code> in O(N) time. The resulting
value is a copy of the original and will not be affected by subsequent
mutations of the input or output value.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> String</span> ::= Bytes2String(Bytes) [function, functional, hook(BYTES.bytes2string)]<span class="hljs-keyword">
  syntax</span> Bytes ::= String2Bytes(<span class="hljs-keyword">String</span>) [function, functional, hook(BYTES.string2bytes)]
</code></pre>
<h3>Bytes update</h3>
<p>You can set the value of a particular byte in a <code>Bytes</code> object in O(1) time.
The result is <code>#False</code> if <code>value</code> is not in the range [0..255] or if <code>index</code>
is not a valid index (ie, less than zero or greater than or equal to the length
of the <code>Bytes</code> term).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= Bytes <span class="hljs-string">&quot;[&quot;</span> index:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;-&quot;</span> value:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;]&quot;</span> [function, hook(BYTES.update)]
</code></pre>
<h3>Bytes lookup</h3>
<p>You can get the value of a particular byte in a <code>Bytes</code> object in O(1) time.
The result is <code>#False</code> if <code>index</code> is not a valid index (see above).</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= Bytes <span class="hljs-string">&quot;[&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;]&quot;</span> [function, hook(BYTES.get)]
</code></pre>
<h3>Bytes substring</h3>
<p>You can get a new <code>Bytes</code> object containing a range of bytes from the input
<code>Bytes</code> in O(N) time (where N is the length of the substring). The range
of bytes included is <code>[startIndex..endIndex)</code>. The resulting <code>Bytes</code> is
a copy and mutations to it do not affect mutations to the original <code>Bytes</code>.
The result is <code>#False</code> if <code>startIndex</code> or <code>endIndex</code> are not valid.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= substrBytes(Bytes, startIndex:<span class="hljs-keyword"> Int</span>, endIndex:<span class="hljs-keyword"> Int</span>) [function, hook(BYTES.substr)]
</code></pre>
<h3>Multiple bytes update</h3>
<p>You can modify a <code>Bytes</code> to return a <code>Bytes</code> which is equal to <code>dest</code> except
the <code>N</code> elements starting at <code>index</code> are replaced with the contents of <code>src</code> in
O(N) time. This does not create a new <code>Bytes</code> object and will instead modify
the original on concrete backends. The result is <code>#False</code> if <code>index</code> + <code>N</code>
is not a valid index.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= replaceAtBytes(dest: Bytes, index:<span class="hljs-keyword"> Int</span>, src: Bytes) [function, hook(BYTES.replaceAt)]
</code></pre>
<h3>Bytes padding</h3>
<p>You can create a new <code>Bytes</code> object which is at least <code>length</code> bytes long
by taking the input sequence and padding it on the right (respectively, on the
left) with the specified <code>value</code>. This does not create a new <code>Bytes</code> object
if the input is already at least <code>length</code> bytes long, and will instead
return the input unchanged. The result is <code>#False</code> if <code>value</code> is not in the
range <code>[0..255]</code>, or if the length is negative.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= padRightBytes(Bytes, length:<span class="hljs-keyword"> Int</span>, value:<span class="hljs-keyword"> Int</span>) [function, hook(BYTES.padRight)]
                 | padLeftBytes(Bytes, length:<span class="hljs-keyword"> Int</span>, value:<span class="hljs-keyword"> Int</span>) [function, hook(BYTES.padLeft)]
</code></pre>
<h3>Bytes reverse</h3>
<p>You can reverse a <code>Bytes</code> object in O(N) time. This does not create a new
<code>Bytes</code> object and will instead modify the original on concrete backends.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= reverseBytes(Bytes) [function, functional, hook(BYTES.reverse)]
</code></pre>
<h3>Bytes length</h3>
<p>You can get the length of a <code>Bytes</code> term in O(1) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= lengthBytes(Bytes) [function, functional, hook(BYTES.length), smtlib(lengthBytes)]
</code></pre>
<h3>Bytes concatenation</h3>
<p>You can create a new <code>Bytes</code> object by concatenating two <code>Bytes</code> objects
together in O(N) time.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Bytes ::= Bytes <span class="hljs-string">&quot;+Bytes&quot;</span> Bytes [function, functional, hook(BYTES.concat), <span class="hljs-literal">right</span>]
</code></pre>
<h3>Implementation of Bytes</h3>
<p>The remainder of this module consists of an implementation of some of the
operators listed above in K. This implementation is primarily used by outdated
backends and should not be viewed as authoritative, nor should the user
use the <code>nilBytes</code> or <code>:</code> operators in their definition.</p>
<pre class="hljs"><code><span class="hljs-keyword">  rule</span> .Bytes =&gt; String2Bytes(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> BYTES-IN-K [symbolic, kast]<span class="hljs-keyword">
  imports</span> INT<span class="hljs-keyword">
  imports</span> K-EQUAL<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">
  imports</span> STRING-BUFFER<span class="hljs-keyword">

  syntax</span> Bytes ::= <span class="hljs-string">&quot;nilBytes&quot;</span>
                 |<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;:&quot;</span> Bytes<span class="hljs-keyword">
  syntax</span> Endianness ::= <span class="hljs-string">&quot;LE&quot;</span> [klabel(littleEndianBytes), symbol]
                      | <span class="hljs-string">&quot;BE&quot;</span> [klabel(bigEndianBytes), symbol]<span class="hljs-keyword">
  syntax</span> Signedness ::= <span class="hljs-string">&quot;Signed&quot;</span> [klabel(signedBytes), symbol]
                      | <span class="hljs-string">&quot;Unsigned&quot;</span> [klabel(unsignedBytes), symbol]<span class="hljs-keyword">

  syntax</span> Bytes ::= <span class="hljs-string">&quot;.Bytes&quot;</span> [function, functional]<span class="hljs-keyword">
  rule</span> .Bytes =&gt; nilBytes<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Int</span> ::= Bytes2Int(Bytes, Endianness, Signedness) [function, functional]<span class="hljs-keyword">
  rule</span> Bytes2Int(nilBytes, _, _) =&gt; <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> Bytes2Int(B : nilBytes, BE, Unsigned) =&gt; B<span class="hljs-keyword">
  rule</span> Bytes2Int(B0 : B1 : BS, BE, Unsigned) =&gt; Bytes2Int(((B0 &lt;&lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">8</span>) |<span class="hljs-keyword">Int</span> B1) : BS, BE, Unsigned)<span class="hljs-keyword">
  rule</span> Bytes2Int(B0 : BS, BE, Signed) =&gt; signExtendBitRangeInt(Bytes2Int(B0 : BS, BE, Unsigned), <span class="hljs-number">0</span>, lengthBytes(B0 : BS) &lt;&lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">3</span>)<span class="hljs-keyword">
  rule</span> Bytes2Int(B0 : BS, LE, S) =&gt; Bytes2Int(reverseBytes(B0 : BS), BE, S)<span class="hljs-keyword">

  syntax</span> Bytes ::= Int2Bytes(<span class="hljs-keyword">Int</span>, Bytes) [function, klabel(Int2BytesAux)]<span class="hljs-keyword">
  syntax</span> Bytes ::= Int2Bytes(<span class="hljs-keyword">Int</span>,<span class="hljs-keyword"> Int</span>, Endianness) [function, functional]
                 | Int2Bytes(<span class="hljs-keyword">Int</span>, Endianness, Signedness) [function, functional, klabel(Int2BytesNoLen)]<span class="hljs-keyword">
  rule</span> Int2Bytes(LEN, I, BE) =&gt; padLeftBytes(Int2Bytes(bitRangeInt(I, <span class="hljs-number">0</span>, LEN &lt;&lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">3</span>), nilBytes), LEN, #if I &lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span> #then <span class="hljs-number">255</span> #else <span class="hljs-number">0</span> #fi)<span class="hljs-keyword">
  rule</span> Int2Bytes(LEN, I, LE) =&gt; reverseBytes(Int2Bytes(LEN, I, BE))<span class="hljs-keyword">
  rule</span> Int2Bytes(<span class="hljs-number">0</span>, BS) =&gt; BS<span class="hljs-keyword">
  rule</span> Int2Bytes(I, BS) =&gt; Int2Bytes(I &gt;&gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">8</span>, I &amp;<span class="hljs-keyword">Int</span> <span class="hljs-number">255</span> : BS)<span class="hljs-keyword"> requires</span> I =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> String</span> ::= Bytes2String(Bytes, StringBuffer) [function, klabel(Bytes2StringAux)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= Bytes2String(Bytes) [function, functional]<span class="hljs-keyword">
  rule</span> Bytes2String(BS) =&gt; Bytes2String(BS, .StringBuffer)<span class="hljs-keyword">
  rule</span> Bytes2String(nilBytes, BUFFER) =&gt; StringBuffer2String(BUFFER)<span class="hljs-keyword">
  rule</span> Bytes2String(B : BS, BUFFER) =&gt; Bytes2String(BS, BUFFER +<span class="hljs-keyword">String</span> chrChar(B))<span class="hljs-keyword">

  syntax</span> Bytes ::= String2Bytes(<span class="hljs-keyword">String</span>) [function, functional]<span class="hljs-keyword">
  rule</span> String2Bytes(S) =&gt; ordChar(substrString(S, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) : String2Bytes(substrString(S, <span class="hljs-number">1</span>, lengthString(S)))<span class="hljs-keyword"> requires</span> lengthString(S) &gt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span><span class="hljs-keyword">
  rule</span> String2Bytes(<span class="hljs-string">&quot;&quot;</span>) =&gt; nilBytes<span class="hljs-keyword">

  syntax</span> Bytes ::= Bytes <span class="hljs-string">&quot;[&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;&lt;-&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;]&quot;</span> [function]<span class="hljs-keyword">
  rule</span> BS [ N &lt;- M ] =&gt; substrBytes(BS, <span class="hljs-number">0</span>, N) +Bytes M : substrBytes(BS, N +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, lengthBytes(BS))<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Int</span> ::= Bytes <span class="hljs-string">&quot;[&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;]&quot;</span> [function]<span class="hljs-keyword">
  rule</span> (B : _) [ <span class="hljs-number">0</span> ] =&gt; B<span class="hljs-keyword">
  rule</span> (_ : BS) [ I ] =&gt; BS [ I -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>]<span class="hljs-keyword"> requires</span> I &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">

  syntax</span> Bytes ::= substrBytes(Bytes,<span class="hljs-keyword"> Int</span>,<span class="hljs-keyword"> Int</span>) [function]<span class="hljs-keyword">
  rule</span> substrBytes(_, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; nilBytes<span class="hljs-keyword">
  rule</span> substrBytes(_ : BS, N, M) =&gt; substrBytes(BS, N -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, M -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>)<span class="hljs-keyword"> requires</span> N &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> substrBytes(B : BS, <span class="hljs-number">0</span>, M) =&gt; B : substrBytes(BS, <span class="hljs-number">0</span>, M -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>)<span class="hljs-keyword"> requires</span> M &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">

  syntax</span> Bytes ::= replaceAtBytes(Bytes,<span class="hljs-keyword"> Int</span>, Bytes) [function]<span class="hljs-keyword">
  rule</span> replaceAtBytes(BS, _, nilBytes) =&gt; BS<span class="hljs-keyword">
  rule</span> replaceAtBytes(B : BS, N, BS&apos;) =&gt; B : replaceAtBytes(BS, N -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, BS&apos;)<span class="hljs-keyword"> requires</span> N &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> replaceAtBytes(_ : BS, <span class="hljs-number">0</span>, B : BS&apos;) =&gt; B : replaceAtBytes(BS, <span class="hljs-number">0</span>, BS&apos;)<span class="hljs-keyword">

  syntax</span> Bytes ::= padRightBytes(Bytes,<span class="hljs-keyword"> Int</span>,<span class="hljs-keyword"> Int</span>) [function]
                 | padLeftBytes(Bytes,<span class="hljs-keyword"> Int</span>,<span class="hljs-keyword"> Int</span>) [function]<span class="hljs-keyword">
  rule</span> padRightBytes(BS, LEN, VAL) =&gt; reverseBytes(padLeftBytes(reverseBytes(BS), LEN, VAL))<span class="hljs-keyword">
  rule</span> padLeftBytes(BS, LEN, _) =&gt; BS<span class="hljs-keyword"> requires</span> lengthBytes(BS) &gt;=<span class="hljs-keyword">Int</span> LEN andBool <span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> LEN<span class="hljs-keyword">
  rule</span> padLeftBytes(BS, LEN, VAL) =&gt; padLeftBytes(VAL : BS, LEN, VAL)<span class="hljs-keyword"> requires</span> lengthBytes(BS) &lt;<span class="hljs-keyword">Int</span> LEN andBool <span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> LEN<span class="hljs-keyword">

  syntax</span> Bytes ::= reverseBytes(Bytes) [function, functional]<span class="hljs-keyword">
  syntax</span> Bytes ::= reverseBytes(Bytes, Bytes) [function, klabel(reverseBytesAux)]<span class="hljs-keyword">
  rule</span> reverseBytes(BS) =&gt; reverseBytes(BS, nilBytes)<span class="hljs-keyword">
  rule</span> reverseBytes(nilBytes, BS) =&gt; BS<span class="hljs-keyword">
  rule</span> reverseBytes(B : BS, BS&apos;) =&gt; reverseBytes(BS, B : BS&apos;)<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Int</span> ::= lengthBytes(Bytes) [function, functional, smtlib(lengthBytes)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Int</span> ::= lengthBytes(Bytes,<span class="hljs-keyword"> Int</span>) [function, klabel(lengthBytesAux), smtlib(lengthBytesAux)]<span class="hljs-keyword">
  rule</span> lengthBytes(BS) =&gt; lengthBytes(BS, <span class="hljs-number">0</span>)<span class="hljs-keyword">
  rule</span> lengthBytes(nilBytes, SIZE) =&gt; SIZE<span class="hljs-keyword">
  rule</span> lengthBytes(_ : BS, SIZE) =&gt; lengthBytes(BS, SIZE +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>)<span class="hljs-keyword">

  syntax</span> Bytes ::= Bytes <span class="hljs-string">&quot;+Bytes&quot;</span> Bytes [function, functional, <span class="hljs-literal">right</span>]<span class="hljs-keyword">
  rule</span> nilBytes +Bytes B2 =&gt; B2<span class="hljs-keyword">
  rule</span> (B : BS) +Bytes B2 =&gt; B : (BS +Bytes B2)<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> BYTES-CONCRETE [concrete]<span class="hljs-keyword">
  imports</span> BYTES-HOOKED<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> BYTES-KORE [kore]<span class="hljs-keyword">
  imports</span> BYTES-HOOKED<span class="hljs-keyword">
  imports</span> BYTES-SYMBOLIC-CEIL<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> BYTES-SYMBOLIC-CEIL [symbolic, kore]<span class="hljs-keyword">
  imports</span> BYTES-HOOKED<span class="hljs-keyword">
  imports</span> INT<span class="hljs-keyword">

  rule</span> #Ceil(padRightBytes(_, LEN, VAL)) =&gt; {(<span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> LEN andBool <span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> VAL andBool VAL &lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">256</span>) #Equals true} [anywhere, simplification]<span class="hljs-keyword">
  rule</span> #Ceil(padLeftBytes(_, LEN, VAL))  =&gt; {(<span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> LEN andBool <span class="hljs-number">0</span> &lt;=<span class="hljs-keyword">Int</span> VAL andBool VAL &lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">256</span>) #Equals true} [anywhere, simplification]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> BYTES<span class="hljs-keyword">
  imports</span> BYTES-CONCRETE<span class="hljs-keyword">
  imports</span> BYTES-KORE<span class="hljs-keyword">
  imports</span> BYTES-IN-K<span class="hljs-keyword">
  imports</span> INT<span class="hljs-keyword">

  rule</span> Int2Bytes(I::<span class="hljs-keyword">Int</span>, E::Endianness, Unsigned) =&gt; Int2Bytes((log2Int(I) +<span class="hljs-keyword">Int</span> <span class="hljs-number">8</span>) /<span class="hljs-keyword">Int</span> <span class="hljs-number">8</span>, I, E)<span class="hljs-keyword">
    requires</span> I &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> Int2Bytes(<span class="hljs-number">0</span>, _::Endianness, _) =&gt; .Bytes<span class="hljs-keyword">
  rule</span> Int2Bytes(I::<span class="hljs-keyword">Int</span>, E::Endianness, Signed) =&gt; Int2Bytes((log2Int(I) +<span class="hljs-keyword">Int</span> <span class="hljs-number">9</span>) /<span class="hljs-keyword">Int</span> <span class="hljs-number">8</span>, I, E)<span class="hljs-keyword">
    requires</span> I &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> Int2Bytes(I::<span class="hljs-keyword">Int</span>, E::Endianness, Signed) =&gt; Int2Bytes((log2Int(~<span class="hljs-keyword">Int</span> I) +<span class="hljs-keyword">Int</span> <span class="hljs-number">9</span>) /<span class="hljs-keyword">Int</span> <span class="hljs-number">8</span>, I, E)<span class="hljs-keyword">
    requires</span> I &lt;<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span><span class="hljs-keyword">
  rule</span> Int2Bytes(<span class="hljs-number">-1</span>, E::Endianness, Signed) =&gt; Int2Bytes(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, E)<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Program identifiers</h2>
<p>Provided here is an implementation for program identifiers in K. Developers
of semantics for a particular language may wish to use their own implementation
instead of the one provided here if their syntax differs from the syntax
defined below. However, this is provided for convenience for developers who
do not care about the lexical syntax of identifiers.</p>
<p>Provided are the following pieces of functionality:</p>
<ul>
<li><code>Id2String</code> - Convert an <code>Id</code> to a <code>String</code> containing its name</li>
<li><code>String2Id</code> - Convert a <code>String</code> to an <code>Id</code> with the specified name</li>
<li>!X:Id - You can get a fresh identifier distinct from any previous identifier
generated by this syntax.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> ID-SYNTAX-PROGRAM-PARSING<span class="hljs-keyword">
  imports</span> BUILTIN-ID-TOKENS<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Id</span> ::= r<span class="hljs-string">&quot;(?&lt;![A-Za-z0-9\\_])[A-Za-z\\_][A-Za-z0-9\\_]*&quot;</span>     [prec(<span class="hljs-number">1</span>), <span class="hljs-literal">token</span>]
              | #LowerId                                             [<span class="hljs-literal">token</span>]
              | #UpperId                                             [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ID-SYNTAX<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Id</span> [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ID-COMMON<span class="hljs-keyword">
  imports</span> ID-SYNTAX<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> String</span> ::= Id2String (<span class="hljs-keyword"> Id</span> )    [function, functional, hook(STRING.<span class="hljs-literal">token</span>2string)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Id</span> ::= String2Id (<span class="hljs-keyword">String</span>) [function, functional, hook(STRING.string2token)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Id</span> ::= freshId(<span class="hljs-keyword">Int</span>)    [freshGenerator, function, functional]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ID<span class="hljs-keyword">
  imports</span> ID-COMMON<span class="hljs-keyword">
  imports</span> ID-SYMBOLIC<span class="hljs-keyword">

  rule</span> freshId(I:<span class="hljs-keyword">Int</span>) =&gt; String2Id(<span class="hljs-string">&quot;_&quot;</span> +<span class="hljs-keyword">String</span> Int2String(I))<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> ID-SYMBOLIC [symbolic, kast]<span class="hljs-keyword">
  imports</span> ID-COMMON<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">

  syntax</span> KItem  ::= <span class="hljs-string">&quot;#parseIdToken&quot;</span>  <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span><span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span>  [function, hook(STRING.parseToken)]<span class="hljs-keyword">
  rule</span> String2Id(S:<span class="hljs-keyword">String</span>) =&gt; {#parseIdToken(<span class="hljs-string">&quot;Id&quot;</span>, S)}:&gt;<span class="hljs-keyword">Id</span><span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>Equality and conditionals</h2>
<p>Provided here are implementations of two important primitives in K:</p>
<ul>
<li><code>==K</code> - the equality between two terms. Returns <code>true</code> if they are equal
and <code>false</code> if they are not equal.</li>
<li><code>#if #then #else #fi</code> - polymorphic conditional function. If the first
argument evaluates to <code>true</code>, the second argument is returned. Otherwise,
the third argument is returned. Note that this does not short-circuit on
symbolic backends.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> K-EQUAL-SYNTAX<span class="hljs-keyword">
  imports</span> BOOL<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> Bool</span> ::= <span class="hljs-literal">left</span>:
                  K <span class="hljs-string">&quot;==K&quot;</span> K           [function, functional, smt-hook(=), hook(KEQUAL.eq), klabel(_==K_), symbol, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{=_K}{#<span class="hljs-number">2</span>}), equalEqualK]
                | K <span class="hljs-string">&quot;=/=K&quot;</span> K          [function, functional, smt-hook(distinct), hook(KEQUAL.ne), klabel(_=/=K_), symbol, <span class="hljs-literal">latex</span>({#<span class="hljs-number">1</span>}\mathrel{\neq_K}{#<span class="hljs-number">2</span>}), notEqualEqualK]<span class="hljs-keyword">

  syntax</span> priorities equalEqualK notEqualEqualK &gt; boolOperation mlOp<span class="hljs-keyword">

  syntax</span> {Sort} Sort ::= <span class="hljs-string">&quot;#if&quot;</span><span class="hljs-keyword"> Bool</span> <span class="hljs-string">&quot;#then&quot;</span> Sort <span class="hljs-string">&quot;#else&quot;</span> Sort <span class="hljs-string">&quot;#fi&quot;</span>   [function, functional, smt-hook(ite), hook(KEQUAL.ite)]<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> K-EQUAL-KORE [kore]
  import BOOL
  import K-EQUAL-SYNTAX<span class="hljs-keyword">

  rule</span> K1:<span class="hljs-keyword">Bool</span> ==K K2:<span class="hljs-keyword">Bool</span> =&gt; K1 ==<span class="hljs-keyword">Bool</span> K2<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> K-EQUAL-KAST [kast]
  import BOOL
  import K-EQUAL-SYNTAX<span class="hljs-keyword">

  rule</span> K1:<span class="hljs-keyword">Bool</span> ==<span class="hljs-keyword">Bool</span> K2:<span class="hljs-keyword">Bool</span> =&gt; K1 ==K K2<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> K-EQUAL
  import BOOL
  import K-EQUAL-SYNTAX
  import K-EQUAL-KAST
  import K-EQUAL-KORE<span class="hljs-keyword">

  rule</span> K1:K =/=K K2:K =&gt; notBool (K1 ==K K2)<span class="hljs-keyword">

  rule</span> #if C:<span class="hljs-keyword">Bool</span> #then B1::K #else _ #fi =&gt; B1<span class="hljs-keyword"> requires</span> C<span class="hljs-keyword">
  rule</span> #if C:<span class="hljs-keyword">Bool</span> #then _ #else B2::K #fi =&gt; B2<span class="hljs-keyword"> requires</span> notBool C<span class="hljs-keyword">

endmodule</span>
</code></pre>
<h2>Meta operations</h2>
<p>Provided below are a few miscellaneous, mostly deprecated functions in K.
It is not recommended to use any of them directly as they are largely
unsupported in modern K. There are two exceptions:</p>
<ul>
<li><code>#getenv</code> - Returns the value of an environment variable</li>
<li><code>#parseKORE</code> - Takes a String containing a K intermediate representation of
a term such as is returned by <code>kast -o kore</code> and converts it to a term.
This is NOT type-safe. The responsibility is on the user to ensure that the
string they provide is a valid representation of a term of the sort <em>exactly</em>
equal to the sort where the function appears.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> K-REFLECTION<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">
  imports</span> STRING<span class="hljs-keyword">
  imports</span> K-REFLECTION-SYMBOLIC<span class="hljs-keyword">

  syntax</span> K ::= <span class="hljs-string">&quot;#configuration&quot;</span> [function, impure, hook(KREFLECTION.<span class="hljs-keyword">configuration</span>)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= #sort(K) [function, hook(KREFLECTION.sort)]<span class="hljs-keyword">
  syntax</span> KItem ::= #fresh(<span class="hljs-keyword">String</span>)   [function, hook(KREFLECTION.fresh), impure]<span class="hljs-keyword">
  syntax</span> KItem ::= getKLabel(K)  [function, hook(KREFLECTION.getKLabel)]<span class="hljs-keyword">

  syntax</span><span class="hljs-keyword"> String</span> ::= #getenv(<span class="hljs-keyword">String</span>) [function, impure, hook(KREFLECTION.getenv)]

  <span class="hljs-comment">// meaningful only for the purposes of compilation to a binary, otherwise</span>
  <span class="hljs-comment">// undefined</span><span class="hljs-keyword">
  syntax</span> List ::= #argv() [function, hook(KREFLECTION.argv)]

  <span class="hljs-comment">// Takes as input a string and returns a K term</span><span class="hljs-keyword">
  syntax</span> {Sort} Sort ::= #parseKORE(<span class="hljs-keyword">String</span>) [function, hook(KREFLECTION.parseKORE)]<span class="hljs-keyword">
  syntax</span> {Sort} Sort ::= #parseKAST(<span class="hljs-keyword">String</span>) [function, hook(KREFLECTION.parseKAST)]<span class="hljs-keyword">
  syntax</span> IOError ::= <span class="hljs-string">&quot;#noParse&quot;</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span> [klabel(#noParse), symbol]<span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> K-REFLECTION-SYMBOLIC [symbolic, kast]<span class="hljs-keyword">
  imports</span> BASIC-K<span class="hljs-keyword">
  imports</span> STRING

  <span class="hljs-comment">// return empty string if the term has no klabel</span><span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> String</span> ::= #getKLabelString(K) [function, hook(KREFLECTION.getKLabelString)]

  <span class="hljs-comment">// return true if no variable nor unresolved function appears in any subterm</span><span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Bool</span> ::= #isConcrete(K) [function, hook(KREFLECTION.isConcrete)]<span class="hljs-keyword">
  syntax</span><span class="hljs-keyword"> Bool</span> ::= #isVariable(K) [function, hook(KREFLECTION.isVariable)]<span class="hljs-keyword">
endmodule</span>
</code></pre>
<h2>I/O in K</h2>
<p>Concrete execution in K supports I/O operations. This functionality is not
supported during symbolic execution, because symbolic execution must exist
completely free of side-effects, and I/O is an irreducible type of side effect.
However, it is useful in many cases when defining concrete execution to be able
to make reference to I/O operations.</p>
<p>The design of these I/O operations is based on the POSIX standard, for the most
part. For example, the <code>#read</code> K function maps to the <code>read</code> POSIX function. We
do not at this time have a higher-level API for I/O, but this may be
implemented at some point in the future.</p>
<p>I/O operations generally return either their result, or an <code>IOError</code> term
corresponding to the <code>errno</code> returned by the underlying system call.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> K-IO<span class="hljs-keyword">
  imports</span> LIST<span class="hljs-keyword">
  imports</span> STRING
</code></pre>
<h3>I/O errors</h3>
<p>Aside from EOF, which is returned by <code>#getc</code> if the file is at end-of-file, all
of the below I/O errors correspond to possible values for <code>errno</code> after calling
a library function. If the <code>errno</code> returned is not one of the below errnos
known to K, <code>#unknownIOError</code> is returned along with the integer errno value.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOError ::= <span class="hljs-string">&quot;#EOF&quot;</span> [klabel(#EOF), symbol] | #unknownIOError(errno:<span class="hljs-keyword"> Int</span>) [symbol]
                   | <span class="hljs-string">&quot;#E2BIG&quot;</span> [klabel(#E2BIG), symbol]
                   | <span class="hljs-string">&quot;#EACCES&quot;</span> [klabel(#EACCES), symbol]
                   | <span class="hljs-string">&quot;#EAGAIN&quot;</span> [klabel(#EAGAIN), symbol]
                   | <span class="hljs-string">&quot;#EBADF&quot;</span> [klabel(#EBADF), symbol]
                   | <span class="hljs-string">&quot;#EBUSY&quot;</span> [klabel(#EBUSY), symbol]
                   | <span class="hljs-string">&quot;#ECHILD&quot;</span> [klabel(#ECHILD), symbol]
                   | <span class="hljs-string">&quot;#EDEADLK&quot;</span> [klabel(#EDEADLK), symbol]
                   | <span class="hljs-string">&quot;#EDOM&quot;</span> [klabel(#EDOM), symbol]
                   | <span class="hljs-string">&quot;#EEXIST&quot;</span> [klabel(#EEXIST), symbol]
                   | <span class="hljs-string">&quot;#EFAULT&quot;</span> [klabel(#EFAULT), symbol]
                   | <span class="hljs-string">&quot;#EFBIG&quot;</span> [klabel(#EFBIG), symbol]
                   | <span class="hljs-string">&quot;#EINTR&quot;</span> [klabel(#EINTR), symbol]
                   | <span class="hljs-string">&quot;#EINVAL&quot;</span> [klabel(#EINVAL), symbol]
                   | <span class="hljs-string">&quot;#EIO&quot;</span> [klabel(#EIO), symbol]
                   | <span class="hljs-string">&quot;#EISDIR&quot;</span> [klabel(#EISDIR), symbol]
                   | <span class="hljs-string">&quot;#EMFILE&quot;</span> [klabel(#EMFILE), symbol]
                   | <span class="hljs-string">&quot;#EMLINK&quot;</span> [klabel(#EMLINK), symbol]
                   | <span class="hljs-string">&quot;#ENAMETOOLONG&quot;</span> [klabel(#ENAMETOOLONG), symbol]
                   | <span class="hljs-string">&quot;#ENFILE&quot;</span> [klabel(#ENFILE), symbol]
                   | <span class="hljs-string">&quot;#ENODEV&quot;</span> [klabel(#ENODEV), symbol]
                   | <span class="hljs-string">&quot;#ENOENT&quot;</span> [klabel(#ENOENT), symbol]
                   | <span class="hljs-string">&quot;#ENOEXEC&quot;</span> [klabel(#ENOEXEC), symbol]
                   | <span class="hljs-string">&quot;#ENOLCK&quot;</span> [klabel(#ENOLCK), symbol]
                   | <span class="hljs-string">&quot;#ENOMEM&quot;</span> [klabel(#ENOMEM), symbol]
                   | <span class="hljs-string">&quot;#ENOSPC&quot;</span> [klabel(#ENOSPC), symbol]
                   | <span class="hljs-string">&quot;#ENOSYS&quot;</span> [klabel(#ENOSYS), symbol]
                   | <span class="hljs-string">&quot;#ENOTDIR&quot;</span> [klabel(#ENOTDIR), symbol]
                   | <span class="hljs-string">&quot;#ENOTEMPTY&quot;</span> [klabel(#ENOTEMPTY), symbol]
                   | <span class="hljs-string">&quot;#ENOTTY&quot;</span> [klabel(#ENOTTY), symbol]
                   | <span class="hljs-string">&quot;#ENXIO&quot;</span> [klabel(#ENXIO), symbol]
                   | <span class="hljs-string">&quot;#EPERM&quot;</span> [klabel(#EPERM), symbol]
                   | <span class="hljs-string">&quot;#EPIPE&quot;</span> [klabel(#EPIPE), symbol]
                   | <span class="hljs-string">&quot;#ERANGE&quot;</span> [klabel(#ERANGE), symbol]
                   | <span class="hljs-string">&quot;#EROFS&quot;</span> [klabel(#EROFS), symbol]
                   | <span class="hljs-string">&quot;#ESPIPE&quot;</span> [klabel(#ESPIPE), symbol]
                   | <span class="hljs-string">&quot;#ESRCH&quot;</span> [klabel(#ESRCH), symbol]
                   | <span class="hljs-string">&quot;#EXDEV&quot;</span> [klabel(#EXDEV), symbol]
                   | <span class="hljs-string">&quot;#EWOULDBLOCK&quot;</span> [klabel(#EWOULDBLOCK), symbol]
                   | <span class="hljs-string">&quot;#EINPROGRESS&quot;</span> [klabel(#EINPROGRESS), symbol]
                   | <span class="hljs-string">&quot;#EALREADY&quot;</span> [klabel(#EALREADY), symbol]
                   | <span class="hljs-string">&quot;#ENOTSOCK&quot;</span> [klabel(#ENOTSOCK), symbol]
                   | <span class="hljs-string">&quot;#EDESTADDRREQ&quot;</span> [klabel(#EDESTADDRREQ), symbol]
                   | <span class="hljs-string">&quot;#EMSGSIZE&quot;</span> [klabel(#EMSGSIZE), symbol]
                   | <span class="hljs-string">&quot;#EPROTOTYPE&quot;</span> [klabel(#EPROTOTYPE), symbol]
                   | <span class="hljs-string">&quot;#ENOPROTOOPT&quot;</span> [klabel(#ENOPROTOOPT), symbol]
                   | <span class="hljs-string">&quot;#EPROTONOSUPPORT&quot;</span> [klabel(#EPROTONOSUPPORT), symbol]
                   | <span class="hljs-string">&quot;#ESOCKTNOSUPPORT&quot;</span> [klabel(#ESOCKTNOSUPPORT), symbol]
                   | <span class="hljs-string">&quot;#EOPNOTSUPP&quot;</span> [klabel(#EOPNOTSUPP), symbol]
                   | <span class="hljs-string">&quot;#EPFNOSUPPORT&quot;</span> [klabel(#EPFNOSUPPORT), symbol]
                   | <span class="hljs-string">&quot;#EAFNOSUPPORT&quot;</span> [klabel(#EAFNOSUPPORT), symbol]
                   | <span class="hljs-string">&quot;#EADDRINUSE&quot;</span> [klabel(#EADDRINUSE), symbol]
                   | <span class="hljs-string">&quot;#EADDRNOTAVAIL&quot;</span> [klabel(#EADDRNOTAVAIL), symbol]
                   | <span class="hljs-string">&quot;#ENETDOWN&quot;</span> [klabel(#ENETDOWN), symbol]
                   | <span class="hljs-string">&quot;#ENETUNREACH&quot;</span> [klabel(#ENETUNREACH), symbol]
                   | <span class="hljs-string">&quot;#ENETRESET&quot;</span> [klabel(#ENETRESET), symbol]
                   | <span class="hljs-string">&quot;#ECONNABORTED&quot;</span> [klabel(#ECONNABORTED), symbol]
                   | <span class="hljs-string">&quot;#ECONNRESET&quot;</span> [klabel(#ECONNRESET), symbol]
                   | <span class="hljs-string">&quot;#ENOBUFS&quot;</span> [klabel(#ENOBUFS), symbol]
                   | <span class="hljs-string">&quot;#EISCONN&quot;</span> [klabel(#EISCONN), symbol]
                   | <span class="hljs-string">&quot;#ENOTCONN&quot;</span> [klabel(#ENOTCONN), symbol]
                   | <span class="hljs-string">&quot;#ESHUTDOWN&quot;</span> [klabel(#ESHUTDOWN), symbol]
                   | <span class="hljs-string">&quot;#ETOOMANYREFS&quot;</span> [klabel(#ETOOMANYREFS), symbol]
                   | <span class="hljs-string">&quot;#ETIMEDOUT&quot;</span> [klabel(#ETIMEDOUT), symbol]
                   | <span class="hljs-string">&quot;#ECONNREFUSED&quot;</span> [klabel(#ECONNREFUSED), symbol]
                   | <span class="hljs-string">&quot;#EHOSTDOWN&quot;</span> [klabel(#EHOSTDOWN), symbol]
                   | <span class="hljs-string">&quot;#EHOSTUNREACH&quot;</span> [klabel(#EHOSTUNREACH), symbol]
                   | <span class="hljs-string">&quot;#ELOOP&quot;</span> [klabel(#ELOOP), symbol]
                   | <span class="hljs-string">&quot;#EOVERFLOW&quot;</span> [klabel(#EOVERFLOW), symbol]
</code></pre>
<h3>I/O result sorts</h3>
<p>Here we see sorts defined to contain either an <code>Int</code> or an <code>IOError</code>, or
either a <code>String</code> or an <code>IOError</code>. These sorts are used to implement the
return sort of functions that may succeed, in which case they return a value,
or may fail, in which case their return value indicates an error and the
error indicated is returned via <code>errno</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOInt ::=<span class="hljs-keyword"> Int</span> | IOError<span class="hljs-keyword">
  syntax</span> IOString ::=<span class="hljs-keyword"> String</span> | IOError
</code></pre>
<h3>Opening a file</h3>
<p>You can open a file in K using <code>#open</code>. An optional mode indicates the file
open mode, which can have any value allowed by the <code>fopen</code> function in C.
The returned value is the file descriptor that was opened, or an error.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOInt ::= <span class="hljs-string">&quot;#open&quot;</span> <span class="hljs-string">&quot;(&quot;</span> path:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span> [function]
               | <span class="hljs-string">&quot;#open&quot;</span> <span class="hljs-string">&quot;(&quot;</span> path:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> mode:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.open), impure]<span class="hljs-keyword">

  rule</span> #open(S:<span class="hljs-keyword">String</span>) =&gt; #open(S:<span class="hljs-keyword">String</span>, <span class="hljs-string">&quot;r+&quot;</span>)
</code></pre>
<h3>Get/set position in file</h3>
<p>You can get the current offset in a file using <code>#tell</code>. You can also seek
to a particular offset using <code>#seek</code> or <code>#seekEnd</code>. <code>#seek</code> is implemented via
a call to <code>lseek</code> with the <code>SEEK_SET</code> whence. <code>#seekEnd</code> is implemented via a
call to <code>lseek</code> with the <code>SEEK_END</code> whence. You can emulate the <code>SEEK_CUR</code>
whence by means of <code>#seek(FD, #tell(FD) +Int Offset)</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOInt ::= <span class="hljs-string">&quot;#tell&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.tell), impure]<span class="hljs-keyword">
  syntax</span> K ::= <span class="hljs-string">&quot;#seek&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> index:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.seek), impure]
             | <span class="hljs-string">&quot;#seekEnd&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> fromEnd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.seekEnd), impure]
</code></pre>
<h3>Read from file</h3>
<p>You can read a single character from a file using <code>#getc</code>. <code>#EOF</code> is returned
if you are at end-of-fie.</p>
<p>You can also read up to <code>length</code> characters in a file using <code>#read</code>. The
resulting read characters are returned, which may be fewer characters than
requested. A string of zero length being returned indicates end-of-file.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOInt ::= <span class="hljs-string">&quot;#getc&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span>             [function, hook(IO.getc), impure]<span class="hljs-keyword">
  syntax</span> IOString ::= <span class="hljs-string">&quot;#read&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> length:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span>    [function, hook(IO.read), impure]
</code></pre>
<h3>Write to file</h3>
<p>You can write a single character to a file using <code>#putc</code>. You can also write
a string to a file using <code>#write</code>. The returned value on success is <code>.K</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> K ::= <span class="hljs-string">&quot;#putc&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> value:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span>      [function, hook(IO.putc), impure]
             | <span class="hljs-string">&quot;#write&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> value:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.write), impure]
</code></pre>
<h3>Closing a file</h3>
<p>You can close a file using <code>#close</code>. The returned value on success is <code>.K</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> K ::= <span class="hljs-string">&quot;#close&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.close), impure]
</code></pre>
<h3>Locking/unlocking a file</h3>
<p>You can lock or unlock parts of a file using the <code>#lock</code> and <code>#unlock</code>
functions. The lock starts at the beginning of the file and continues for
<code>endIndex</code> bytes. Note that Unix systems do not actually prevent locked files
from being read and modified; you will have to lock both sides of a concurrent
access to guarantee exclusivity.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> K ::= <span class="hljs-string">&quot;#lock&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> endIndex:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.lock), impure]
             | <span class="hljs-string">&quot;#unlock&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;,&quot;</span> endIndex:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.unlock), impure]
</code></pre>
<h3>Networking</h3>
<p>You can accept a connection on a socket using <code>#accept</code>, or shut down the
write end of a socket with <code>#shutdownWrite</code>. Note that facility is not provided
for opening, binding, and listening on sockets. These functions are implemented
in order to support creating stateful request/response servers where the
request loop is implemented using rewriting in K, but the connection
initialization is written in native code and linked into the LLVM backend.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOInt ::= <span class="hljs-string">&quot;#accept&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.accept), impure]<span class="hljs-keyword">
  syntax</span> K ::= <span class="hljs-string">&quot;#shutdownWrite&quot;</span> <span class="hljs-string">&quot;(&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.shutdownWrite), impure]
</code></pre>
<h3>Time</h3>
<p>You can get the current time in seconds since midnight UTC on January 1, 1970
using <code>#time</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= <span class="hljs-string">&quot;#time&quot;</span> <span class="hljs-string">&quot;(&quot;</span> <span class="hljs-string">&quot;)&quot;</span> [function, hook(IO.time), impure]
</code></pre>
<h3>Builtin file descriptors</h3>
<p>Provided here are functions that return the file descriptor for standard input,
standard output, and standard error.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= <span class="hljs-string">&quot;#stdin&quot;</span>   [function, functional]
                | <span class="hljs-string">&quot;#stdout&quot;</span> [function, functional]
                | <span class="hljs-string">&quot;#stderr&quot;</span> [function, functional]<span class="hljs-keyword">

  rule</span> #stdin =&gt; <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> #stdout =&gt; <span class="hljs-number">1</span><span class="hljs-keyword">
  rule</span> #stderr =&gt; <span class="hljs-number">2</span>
</code></pre>
<h3>Shell access</h3>
<p>You can execute a command using the shell using the <code>#system</code> operator. Care
must be taken to sanitize inputs to this function or security issues may
result. Note that K has no facility for reasoning about logic that happens
outside its process, so any functionality that you wish to be able to formally
reason about in K should not be implemented via the <code>#system</code> operator.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> KItem ::= #system (<span class="hljs-keyword"> String</span> ) [function, hook(IO.system), impure]
                 | <span class="hljs-string">&quot;#systemResult&quot;</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-keyword"> Int</span> <span class="hljs-comment">/* exit code */</span> <span class="hljs-string">&quot;,&quot;</span><span class="hljs-keyword"> String</span> <span class="hljs-comment">/* stdout */</span> <span class="hljs-string">&quot;,&quot;</span><span class="hljs-keyword"> String</span> <span class="hljs-comment">/* stderr */</span> <span class="hljs-string">&quot;)&quot;</span> [klabel(#systemResult), symbol]
</code></pre>
<h3>Temporary files</h3>
<p>You can get a temporary file and open it atomically using the <code>#mkstemp</code>
operator. The resulting file will be closed and deleted when K rewriting ends.
For more info on the argument to <code>#mkstemp</code>, see <code>man mkstemp</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> IOFile ::= #mkstemp(template:<span class="hljs-keyword"> String</span>) [function, hook(IO.mkstemp), impure]<span class="hljs-keyword">
  syntax</span> IOFile ::= IOError
                  | <span class="hljs-string">&quot;#tempFile&quot;</span> <span class="hljs-string">&quot;(&quot;</span> path:<span class="hljs-keyword"> String</span> <span class="hljs-string">&quot;,&quot;</span> fd:<span class="hljs-keyword"> Int</span> <span class="hljs-string">&quot;)&quot;</span> [klabel(#tempFile), symbol]
</code></pre>
<h3>Deleting a file</h3>
<p>You can delete a file using its absolute or relative path using the <code>#remove</code>
operator. It returns <code>.K</code> on success or an <code>IOError</code> on failure.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> K ::= #remove(path:<span class="hljs-keyword"> String</span>) [function, functional, hook(IO.remove), impure]
</code></pre>
<h3>Logging</h3>
<p>You can log information to disk using the <code>#logToFile</code> operator. Semantically,
this operator returns <code>.K</code>. However, it has a side effect that is not reasoned
about which is that <code>value</code> will be written to a uniquely-identified file
containing <code>name</code> in its name. The file is only flushed to disk when rewriting
finishes.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> K ::= #logToFile(name:<span class="hljs-keyword"> String</span>, value:<span class="hljs-keyword"> String</span>) [function, functional, hook(IO.log), impure, returnsUnit, symbol]
</code></pre>
<h3>Implementation of high-level I/O streams in K</h3>
<p>Below is an implementation of the <code>stream=&quot;stdin&quot;</code> and <code>stream=&quot;stdout&quot;</code>
cell attributes in K. You should not refer to these symbols or modules directly
in your definition. It is provided only so that the K compiler can make use of
it. For more information on how to use this feature, refer to IMP++ in the K
tutorial.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> Stream ::= #buffer(K)<span class="hljs-keyword">

endmodule</span>

<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> DO NOT DIRECTLY IMPORT *-STREAM MODULES</span>
<span class="hljs-comment">// These stream modules will be automatically instantiated and implicitly imported</span>
<span class="hljs-comment">// into the main module when `stream` attributes appear in configuration cells.</span>
<span class="hljs-comment">// Only `Stream` productions and `[stream]` rules will be imported.</span>
<span class="hljs-comment">// The cell name will be replaced with the one of the main configuration.</span><span class="hljs-keyword">

module</span> STDIN-STREAM<span class="hljs-keyword">
  imports</span> K-IO<span class="hljs-keyword">
  imports</span> K-REFLECTION<span class="hljs-keyword">

  syntax</span> Stream ::= #istream(<span class="hljs-keyword">Int</span>)<span class="hljs-keyword">
  syntax</span> Stream ::= #parseInput(<span class="hljs-keyword">String</span>,<span class="hljs-keyword"> String</span>)<span class="hljs-keyword">

  configuration</span> &lt;stdin&gt; ListItem(#buffer($STDIN:<span class="hljs-keyword">String</span>)) ListItem($IO:<span class="hljs-keyword">String</span>) ListItem(#istream(#stdin)) &lt;/stdin&gt;

  <span class="hljs-comment">// read one character at a time until we read whitespace</span><span class="hljs-keyword">
  rule</span> [stdinGetc]:
       &lt;stdin&gt;
       ListItem(#parseInput(_:<span class="hljs-keyword">String</span>, Delimiters:<span class="hljs-keyword">String</span>))
       ListItem(#buffer(S:<span class="hljs-keyword">String</span> =&gt; S +<span class="hljs-keyword">String</span> chrChar({#getc(N)}:&gt;<span class="hljs-keyword">Int</span>)))
       ListItem(<span class="hljs-string">&quot;on&quot;</span>)
       ListItem(#istream(N:<span class="hljs-keyword">Int</span>))
       &lt;/stdin&gt;<span class="hljs-keyword">
    requires</span> findChar(S, Delimiters, <span class="hljs-number">0</span>) ==<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span> <span class="hljs-comment">// [stdin]</span>
       [stream, priority(<span class="hljs-number">200</span>)]

  <span class="hljs-comment">// when we reach whitespace, if it parses create a ListItem</span><span class="hljs-keyword">
  rule</span> [stdinParseString]:
       &lt;stdin&gt;
       (ListItem(#parseInput(<span class="hljs-string">&quot;String&quot;</span>, Delimiters:<span class="hljs-keyword">String</span>)) =&gt; ListItem(S))
       ListItem(#buffer(S:<span class="hljs-keyword">String</span> =&gt; <span class="hljs-string">&quot;&quot;</span>))
       _:List
       &lt;/stdin&gt;<span class="hljs-keyword">
    requires</span> findChar(S, Delimiters, <span class="hljs-number">0</span>) =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span> <span class="hljs-comment">// [stdin]</span>
       [stream]

  <span class="hljs-comment">// a hack: handle the case when we read integers without the help of the IO server</span><span class="hljs-keyword">
  rule</span> [stdinParseInt]:
       &lt;stdin&gt;
       (ListItem(#parseInput(<span class="hljs-string">&quot;Int&quot;</span>, Delimiters:<span class="hljs-keyword">String</span>))
       =&gt; ListItem(String2Int(substrString(S, <span class="hljs-number">0</span>, findChar(S, Delimiters, <span class="hljs-number">0</span>)))))
       ListItem(#buffer(S:<span class="hljs-keyword">String</span> =&gt; substrString(S,findChar(S, Delimiters, <span class="hljs-number">0</span>) +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, lengthString(S))))
       _:List
       &lt;/stdin&gt;<span class="hljs-keyword">
    requires</span> findChar(S, Delimiters, <span class="hljs-number">0</span>) =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span>
       andBool lengthString(S) &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> <span class="hljs-comment">// [stdin]</span>
       [stream]<span class="hljs-keyword">

  rule</span> [stdinParseArbitrarySort]:
       &lt;stdin&gt;
       (ListItem(#parseInput(Sort:<span class="hljs-keyword">String</span>, Delimiters:<span class="hljs-keyword">String</span>))
       =&gt; ListItem(#parseKAST(substrString(S, <span class="hljs-number">0</span>, findChar(S, Delimiters, <span class="hljs-number">0</span>)))))
       ListItem(#buffer(S:<span class="hljs-keyword">String</span> =&gt; substrString(S,findChar(S, Delimiters, <span class="hljs-number">0</span>) +<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>, lengthString(S))))
       _:List
       &lt;/stdin&gt;<span class="hljs-keyword">
    requires</span> findChar(S, Delimiters, <span class="hljs-number">0</span>) =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span>
       andBool Sort ==<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;K&quot;</span>
       andBool lengthString(S) &gt;<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> <span class="hljs-comment">// [stdin]</span>
       [stream]<span class="hljs-keyword">

  rule</span> [stdinTrim]:
       &lt;stdin&gt;
       ListItem(#parseInput(Sort:<span class="hljs-keyword">String</span>, Delimiters:<span class="hljs-keyword">String</span>))
       ListItem(#buffer(S:<span class="hljs-keyword">String</span> =&gt; substrString(S, <span class="hljs-number">1</span>, lengthString(S))))
       _:List
       &lt;/stdin&gt;<span class="hljs-keyword">
    requires</span> findChar(S, Delimiters, <span class="hljs-number">0</span>) =/=<span class="hljs-keyword">Int</span> <span class="hljs-number">-1</span>
       andBool Sort =/=<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;String&quot;</span>
       andBool lengthString(S) &lt;=<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span> <span class="hljs-comment">// [stdin]</span>
       [stream]

  <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> This unblocking rule will be instantiated and inserted carefully</span>
  <span class="hljs-comment">// when necessary according to user-defined rules, since otherwise it will
  // lead to a diverging (i.e., non-terminating) transition system definition.</span>
  <span class="hljs-comment">// Currently, it supports only a simple pattern matching on the top of the
  // input stream cell, e.g.,</span>
  <span class="hljs-comment">//   rule &lt;k&gt; read() =&gt; V ... &lt;/k&gt; &lt;in&gt; ListItem(V:Int) =&gt; .List ...  &lt;/in&gt;</span>
  <span class="hljs-comment">// Non-supported rules that refer to the input stream cell in a sophisticated</span>
  <span class="hljs-comment">// way will get stuck in concrete execution mode with real IO enabled (i.e.,</span>
  <span class="hljs-comment">// under `--io on` option), while they will still work in symbolic execution</span>
  <span class="hljs-comment">// mode or concrete execution mode with real IO disabled (i.e., under `--io</span>
  <span class="hljs-comment">// off`, `--search`, or `--debug` options).</span>
  <span class="hljs-comment">//
  // <span class="hljs-doctag">TODO:</span> More patterns need to be supported as well. In that case, we need to</span>
  <span class="hljs-comment">// have a way to specify such patterns.</span><span class="hljs-keyword">
  rule</span> [stdinUnblock]:
       &lt;stdin&gt;
         (.List =&gt; ListItem(#parseInput(?Sort:<span class="hljs-keyword">String</span>, ?Delimiters:<span class="hljs-keyword">String</span>)))
         ListItem(#buffer(_:<span class="hljs-keyword">String</span>))
         ...
       &lt;/stdin&gt;
       [unblock]

  <span class="hljs-comment">/*
  syntax Stream ::= &quot;#noIO&quot;

  rule ListItem(#buffer(_))
       (ListItem(#noIO) ListItem(#istream(_:Int)) =&gt; .List) [stdin]
  */</span><span class="hljs-keyword">

endmodule</span><span class="hljs-keyword">

module</span> STDOUT-STREAM<span class="hljs-keyword">
  imports</span> K-IO<span class="hljs-keyword">

  syntax</span> Stream ::= #ostream(<span class="hljs-keyword">Int</span>)<span class="hljs-keyword">

  configuration</span> &lt;stdout&gt; ListItem(#ostream(#stdout)) ListItem($IO:<span class="hljs-keyword">String</span>) ListItem(#buffer(<span class="hljs-string">&quot;&quot;</span>)) &lt;/stdout&gt;
<span class="hljs-comment">//configuration &lt;stderr&gt; ListItem(#ostream(#stderr)) ListItem($IO:String) ListItem(#buffer(&quot;&quot;)) &lt;/stderr&gt;</span><span class="hljs-keyword">

  rule</span> [stdoutBufferFloat]:
       &lt;stdout&gt;
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:<span class="hljs-keyword">String</span> =&gt; Buffer +<span class="hljs-keyword">String</span> Float2String(F)))
       (ListItem(F:<span class="hljs-keyword">Float</span>) =&gt; .List)
       _:List
       &lt;/stdout&gt;
       <span class="hljs-comment">// [stdout, stderr]</span>
       [stream, priority(<span class="hljs-number">25</span>)]<span class="hljs-keyword">
  rule</span> [stdoutBufferInt]:
       &lt;stdout&gt;
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:<span class="hljs-keyword">String</span> =&gt; Buffer +<span class="hljs-keyword">String</span> Int2String(I)))
       (ListItem(I:<span class="hljs-keyword">Int</span>) =&gt; .List)
       _:List
       &lt;/stdout&gt;
       <span class="hljs-comment">// [stdout, stderr]</span>
       [stream, priority(<span class="hljs-number">25</span>)]<span class="hljs-keyword">
  rule</span> [stdoutBufferString]:
       &lt;stdout&gt;
       ListItem(#ostream(_))
       ListItem(_)
       ListItem(#buffer(Buffer:<span class="hljs-keyword">String</span> =&gt; Buffer +<span class="hljs-keyword">String</span> S))
       (ListItem(S:<span class="hljs-keyword">String</span>) =&gt; .List)
       _:List
       &lt;/stdout&gt;
       <span class="hljs-comment">// [stdout, stderr]</span>
       [stream, priority(<span class="hljs-number">25</span>)]

  <span class="hljs-comment">// Send first char from the buffer to the server</span><span class="hljs-keyword">
  rule</span> [stdoutWrite]:
       &lt;stdout&gt;
       ListItem(#ostream(N:<span class="hljs-keyword">Int</span> =&gt; {#write(N, S) ~&gt; N:<span class="hljs-keyword">Int</span>}:&gt;<span class="hljs-keyword">Int</span>))
       ListItem(<span class="hljs-string">&quot;on&quot;</span>)
       ListItem(#buffer(S:<span class="hljs-keyword">String</span> =&gt; <span class="hljs-string">&quot;&quot;</span>))
       _:List
       &lt;/stdout&gt;<span class="hljs-keyword">
    requires</span> S =/=<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// [stdout, stderr]</span>
       [stream, priority(<span class="hljs-number">30</span>)]

  <span class="hljs-comment">/*
  syntax Stream ::= &quot;#noIO&quot;

  rule ListItem(#buffer(Buffer:String =&gt; Buffer +String Float2String(F)))
       (ListItem(F:Float) =&gt; .List)
       _:List [stdout, stderr]
  rule ListItem(#buffer(Buffer:String =&gt; Buffer +String Int2String(I)))
       (ListItem(I:Int) =&gt; .List)
       _:List [stdout, stderr]
  rule ListItem(#buffer(Buffer:String =&gt; Buffer +String S))
       (ListItem(S:String) =&gt; .List)
       _:List [stdout, stderr]

  rule (ListItem(#ostream(_:Int)) ListItem(#noIO) =&gt; .List)
       ListItem(#buffer(_))
       _:List [stdout, stderr]
  */</span><span class="hljs-keyword">

endmodule</span>
</code></pre>
<h2>Machine Integers</h2>
<p>Provided here is an implementation of arbitrarily large fixed-precision binary
integers in K. This type is hooked to an implementation of integers provided
by the backend, and in particular makes use of native machine integers for
certain sizes of integer. For arbitrary-precision integers, see the <code>INT</code>
module above.</p>
<p>The syntax of machine integers in K is the same as arbitrary-precision integers
(i.e., an optional sign followed by a sequence of digits) except that machine
integers always end in a suffix <code>pN</code> where <code>N</code> is an integer indicating the
width in bits of the integer. The <code>MInt</code> sort is parametric, and this is
reflected in the literals. For example, the sort of <code>0p8</code> is <code>MInt{8}</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> MINT-SYNTAX
  <span class="hljs-comment">/*@\section{Description} The MInt implements machine integers of arbitrary
   * bit width represented in 2&apos;s complement. */</span><span class="hljs-keyword">
  syntax</span> {Width} MInt{Width} [hook(MINT.MInt)]

  <span class="hljs-comment">/*@ Machine integer of bit width and value. */</span><span class="hljs-keyword">
  syntax</span> {Width} MInt{Width} ::= r<span class="hljs-string">&quot;[\\+-]?[0-9]+[pP][0-9]+&quot;</span> [<span class="hljs-literal">token</span>, prec(<span class="hljs-number">2</span>), hook(MINT.literal)]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> MINT<span class="hljs-keyword">
  imports</span> MINT-SYNTAX<span class="hljs-keyword">
  imports</span> INT
</code></pre>
<h3>Bitwidth of MInt</h3>
<p>You can get the number of bits of width in an MInt using <code>bitwidthMInt</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> {Width}<span class="hljs-keyword"> Int</span> ::= bitwidthMInt(MInt{Width})   [function, functional, hook(MINT.bitwidth)]
</code></pre>
<h3>Int and MInt conversions</h3>
<p>You can convert from an <code>MInt</code> to an <code>Int</code> using the <code>MInt2Signed</code> and
<code>MInt2Unsigned</code> functions. an <code>MInt</code> does not have a sign; its sign is instead
reflected in how operators interpret its value either as a signed integer or as
an unsigned integer. Thus, you can interpret a <code>MInt</code> as a signed integer witth
<code>MInt2Signed</code>, or as an unsigned integer respectively using <code>MInt2Unsigned</code>.</p>
<p>You can also convert from an <code>Int</code> to an <code>MInt</code> using <code>Int2MInt</code>. Care must
be given to ensure that the sort context where the <code>Int2MInt</code> operator appears
has the correct bitwidth, as this will influence the width of the resulting
<code>MInt</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> {Width}<span class="hljs-keyword"> Int</span> ::= MInt2Signed(MInt{Width})     [function, functional, hook(MINT.svalue)]
                       | MInt2Unsigned(MInt{Width})     [function, functional, hook(MINT.uvalue), smt-hook(bv2int)]<span class="hljs-keyword">

  syntax</span> {Width} MInt{Width} ::= Int2MInt(<span class="hljs-keyword">Int</span>) [function, functional, hook(MINT.integer), smt-hook(int2bv)]
</code></pre>
<h3>MInt min and max values</h3>
<p>You can get the minimum and maximum values of a signed or unsigned <code>MInt</code>
with az specified bit width using <code>sminMInt</code>, <code>smaxMInt</code>, <code>uminMInt</code>, and
<code>umaxMInt</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Int</span> ::= sminMInt(<span class="hljs-keyword">Int</span>)    [function]
               | smaxMInt(<span class="hljs-keyword">Int</span>)    [function]
               | uminMInt(<span class="hljs-keyword">Int</span>)    [function]
               | umaxMInt(<span class="hljs-keyword">Int</span>)    [function]<span class="hljs-keyword">
  rule</span> sminMInt(N:<span class="hljs-keyword">Int</span>) =&gt; <span class="hljs-number">0</span> -<span class="hljs-keyword">Int</span> (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> (N -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>))<span class="hljs-keyword">
  rule</span> smaxMInt(N:<span class="hljs-keyword">Int</span>) =&gt; (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> (N -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>)) -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span><span class="hljs-keyword">
  rule</span> uminMInt(_:<span class="hljs-keyword">Int</span>) =&gt; <span class="hljs-number">0</span><span class="hljs-keyword">
  rule</span> umaxMInt(N:<span class="hljs-keyword">Int</span>) =&gt; (<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-keyword">Int</span> N) -<span class="hljs-keyword">Int</span> <span class="hljs-number">1</span>
</code></pre>
<h3>MInt bounds checking</h3>
<p>You can check whether a specified <code>Int</code> will be represented in an <code>MInt</code>
with a specified <code>width</code> without any loss of precision when interpreted as
a signed or unsigned integer using <code>soverflowMInt</code> and <code>uoverflowMInt</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span><span class="hljs-keyword"> Bool</span> ::= soverflowMInt(width:<span class="hljs-keyword"> Int</span>,<span class="hljs-keyword"> Int</span>)   [function]
                | uoverflowMInt(width:<span class="hljs-keyword"> Int</span>,<span class="hljs-keyword"> Int</span>)   [function]<span class="hljs-keyword">
  rule</span>
    soverflowMInt(N:<span class="hljs-keyword">Int</span>, I:<span class="hljs-keyword">Int</span>)
  =&gt;
    I &lt;<span class="hljs-keyword">Int</span> sminMInt(N) orBool I &gt;<span class="hljs-keyword">Int</span> smaxMInt(N)<span class="hljs-keyword">
  rule</span>
    uoverflowMInt(N:<span class="hljs-keyword">Int</span>, I:<span class="hljs-keyword">Int</span>)
  =&gt;
    I &lt;<span class="hljs-keyword">Int</span> uminMInt(N) orBool I &gt;<span class="hljs-keyword">Int</span> umaxMInt(N)
</code></pre>
<h3>MInt arithmetic</h3>
<p>You can:</p>
<ul>
<li>Compute the bitwise complement <code>~MInt</code> of an <code>MInt</code>.</li>
<li>Compute the unary negation <code>--MInt</code> of an <code>MInt</code>.</li>
<li>Compute the product <code>*MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the quotient <code>/sMInt</code> of two <code>MInt</code>s interpreted as signed integers.</li>
<li>Compute the modulus <code>%sMInt</code> of two <code>MInt</code>s interpreted as signed integers.</li>
<li>Compute the quotient <code>/uMInt</code> of two <code>MInt</code>s interpreted as unsigned
integers.</li>
<li>Compute the modulus <code>%uMInt</code> of two <code>MInt</code>s interpreted as unsigned integers.</li>
<li>Compute the sum <code>+MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the difference <code>-MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the left shift <code>&lt;&lt;MInt</code> of two <code>MInt</code>s. The second <code>MInt</code> is always
interpreted as positive.</li>
<li>Compute the arithmetic right shift <code>&gt;&gt;aMInt</code> of two <code>MInt</code>s. The second
<code>MInt</code> is always interpreted as positve.</li>
<li>Compute the logical right shift <code>&gt;&gt;lMInt</code> of two <code>MInt</code>s. The second <code>MInt</code>
is always interpreted as positive.</li>
<li>Compute the bitwise and <code>&amp;MInt</code> of two <code>MInt</code>s.</li>
<li>Compute the bitwise xor <code>xorMInt</code> of two <code>MInt</code>s.</li>
<li>Compute the bitwise inclusive or <code>|MInt</code> of two <code>MInt</code>s.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> {Width} MInt{Width} ::= <span class="hljs-string">&quot;~MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.not), smt-hook(bvnot)]
                               | <span class="hljs-string">&quot;--MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.neg), smt-hook(bvuminus)]
                               &gt; <span class="hljs-literal">left</span>:
                                 MInt{Width} <span class="hljs-string">&quot;*MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.mul), smt-hook(bvmul)]
                               | MInt{Width} <span class="hljs-string">&quot;/sMInt&quot;</span> MInt{Width} [function, hook(MINT.sdiv), smt-hook(bvsdiv)]
                               | MInt{Width} <span class="hljs-string">&quot;%sMInt&quot;</span> MInt{Width} [function, hook(MINT.srem), smt-hook(bvsrem)]
                               | MInt{Width} <span class="hljs-string">&quot;/uMInt&quot;</span> MInt{Width} [function, hook(MINT.udiv), smt-hook(bvudiv)]
                               | MInt{Width} <span class="hljs-string">&quot;%uMInt&quot;</span> MInt{Width} [function, hook(MINT.urem), smt-hook(bvurem)]
                               &gt; <span class="hljs-literal">left</span>:
                                 MInt{Width} <span class="hljs-string">&quot;+MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.add), smt-hook(bvadd)]
                               | MInt{Width} <span class="hljs-string">&quot;-MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.sub), smt-hook(bvsub)]
                               &gt; <span class="hljs-literal">left</span>:
                                 MInt{Width} <span class="hljs-string">&quot;&lt;&lt;MInt&quot;</span> MInt{Width} [function, hook(MINT.shl), smt-hook(bvshl)]
                               | MInt{Width} <span class="hljs-string">&quot;&gt;&gt;aMInt&quot;</span> MInt{Width} [function, hook(MINT.ashr), smt-hook(bvashr)]
                               | MInt{Width} <span class="hljs-string">&quot;&gt;&gt;lMInt&quot;</span> MInt{Width} [function, hook(MINT.lshr), smt-hook(bvlshr)]
                               &gt; <span class="hljs-literal">left</span>:
                                 MInt{Width} <span class="hljs-string">&quot;&amp;MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.and), smt-hook(bvand)]
                               &gt; <span class="hljs-literal">left</span>:
                                 MInt{Width} <span class="hljs-string">&quot;xorMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.xor), smt-hook(bvxor)]
                               &gt; <span class="hljs-literal">left</span>:
                                 MInt{Width} <span class="hljs-string">&quot;|MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.or), smt-hook(bvor)]
</code></pre>
<h3>MInt comparison</h3>
<p>You can compute whether one <code>MInt</code> is less than, less than or equal to, greater
than, or greater than or equal to another <code>MInt</code> when interpreted as signed
or unsigned integers. You can also compute whether one <code>MInt</code> is equal to or
unequal to another <code>MInt</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> {Width}<span class="hljs-keyword"> Bool</span> ::= MInt{Width} <span class="hljs-string">&quot;&lt;sMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.slt), smt-hook(bvslt)]
                        | MInt{Width} <span class="hljs-string">&quot;&lt;uMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.ult), smt-hook(bvult)]
                        | MInt{Width} <span class="hljs-string">&quot;&lt;=sMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.sle), smt-hook(bvsle)]
                        | MInt{Width} <span class="hljs-string">&quot;&lt;=uMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.ule), smt-hook(bvule)]
                        | MInt{Width} <span class="hljs-string">&quot;&gt;sMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.sgt), smt-hook(bvsgt)]
                        | MInt{Width} <span class="hljs-string">&quot;&gt;uMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.ugt), smt-hook(bvugt)]
                        | MInt{Width} <span class="hljs-string">&quot;&gt;=sMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.sge), smt-hook(bvsge)]
                        | MInt{Width} <span class="hljs-string">&quot;&gt;=uMInt&quot;</span> MInt{Width} [function, functional, hook(MINT.uge), smt-hook(bvuge)]
                        | MInt{Width} <span class="hljs-string">&quot;==MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.eq), smt-hook(=)]
                        | MInt{Width} <span class="hljs-string">&quot;=/=MInt&quot;</span> MInt{Width} [function, functional, hook(MINT.ne), smt-hook(distinct)]
</code></pre>
<h3>MInt min/max</h3>
<p>You can compute the signed minimum <code>sMinMInt</code>, the signed maximum <code>sMaxMInt</code>,
the unsigned minimum <code>uMinMInt</code>, and the unsigned maximum <code>uMaxMInt</code> of two
<code>MInt</code>s.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> {Width} MInt{Width} ::= sMaxMInt(MInt{Width}, MInt{Width}) [function, functional, hook(MINT.smax), smt-hook((ite (bvslt #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">2</span> #<span class="hljs-number">1</span>))]
                               | sMinMInt(MInt{Width}, MInt{Width}) [function, functional, hook(MINT.smin), smt-hook((ite (bvslt #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>))]
                               | uMaxMInt(MInt{Width}, MInt{Width}) [function, functional, hook(MINT.umax), smt-hook((ite (bvult #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">2</span> #<span class="hljs-number">1</span>))]
                               | uMinMInt(MInt{Width}, MInt{Width}) [function, functional, hook(MINT.umin), smt-hook((ite (bvult #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>) #<span class="hljs-number">1</span> #<span class="hljs-number">2</span>))]
</code></pre>
<h3>MInt to MInt conversion</h3>
<p>You can convert an <code>MInt</code> of one width to another width with <code>roundMInt</code>.
The resulting <code>MInt</code> will be truncated starting from the most significant bit
if the resulting width is smaller than the input. The resulting <code>MInt</code> will be
zero-extended with the same low-order bits if the resulting width is larger
than the input.</p>
<pre class="hljs"><code><span class="hljs-keyword">  syntax</span> {Width1, Width2} MInt{Width1} ::= roundMInt(MInt{Width2}) [function, functional, hook(MINT.round)]
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">endmodule</span>
</code></pre>
<h2>Strategies</h2>
<p>K supports a built-in strategy language that allows you to control how rules
apply. In order to enable it, simply import the <code>STRATEGY</code> module in your
definition. This includes the following basic strategy constructs:</p>
<ul>
<li><code>^ Category:#RuleTag</code> - This is a strategy that indicates that you should
apply a rule with the specified category exactly once. By default, all rules
get the <code>regular</code> tag. This can be changed on individual rules with the <code>tag</code>
attribute.</li>
<li><code>~ Category:#RuleTag</code> - This is the state the strategy cell will be in
after a rule has applied. In other words, all rules that do not mention the
strategy cell are automatically instrumented so that they rewrite the current
top of the <code>&lt;s&gt;</code> cell from <code>^</code> to <code>~</code></li>
<li><code>&lt;s&gt;</code> - This is the strategy cell and contains the current strategy.</li>
<li><code>#STUCK()</code> - By default, a rule is automatically inserted into the definition
which adds <code>#STUCK()</code> to the top of the <code>&lt;s&gt;</code> cell if no other rules apply
and if it is not already at the top of the <code>&lt;s&gt;</code> cell.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">module</span> STRATEGY<span class="hljs-keyword">
    imports</span> ML-SYNTAX<span class="hljs-keyword">
    imports</span> KVARIABLE-SYNTAX<span class="hljs-keyword">
    imports</span> K-EQUAL<span class="hljs-keyword">

    syntax</span> #RuleTag ::= #KVariable<span class="hljs-keyword">

    syntax</span> Strategy ::= #STUCK()    [symbol]
                      | <span class="hljs-string">&quot;^&quot;</span> #RuleTag [symbol, klabel(#applyRule)]
                      | <span class="hljs-string">&quot;~&quot;</span> #RuleTag [symbol, klabel(#appliedRule)]<span class="hljs-keyword">

    configuration</span> &lt;s&gt; $STRATEGY:K &lt;/s&gt;<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> RULE-TAG-SYNTAX<span class="hljs-keyword">
    imports</span> BUILTIN-ID-TOKENS<span class="hljs-keyword">

    syntax</span> #RuleTag ::= #LowerId [<span class="hljs-literal">token</span>]<span class="hljs-keyword">
endmodule</span>
</code></pre>
<p>This is not a complete strategy language. However, it provides several basics.
The user can extend this strategy language into a complete strategy language
in one of three ways. First, they can import the <code>DEFAULT-STRATEGY</code> module,
which provides a very basic strategy that is essentially equivalent to
execution without a strategy. This can be useful if you wish to wholly
manipulate the strategy cell yourself within other rules.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> DEFAULT-STRATEGY-CONCRETE [concrete]<span class="hljs-keyword">
    imports</span><span class="hljs-keyword"> syntax</span> STRATEGY<span class="hljs-keyword">
    imports</span> RULE-TAG-SYNTAX<span class="hljs-keyword">
    rule</span> ~ regular =&gt; ^ regular [anywhere]<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> DEFAULT-STRATEGY-SYMBOLIC [symbolic]<span class="hljs-keyword">
    imports</span><span class="hljs-keyword"> syntax</span> STRATEGY<span class="hljs-keyword">
    imports</span> RULE-TAG-SYNTAX<span class="hljs-keyword">
    rule</span> &lt;s&gt; ~ regular =&gt; ^ regular ... &lt;/s&gt;<span class="hljs-keyword">
endmodule</span><span class="hljs-keyword">

module</span> DEFAULT-STRATEGY<span class="hljs-keyword">
    imports</span><span class="hljs-keyword"> syntax</span> STRATEGY<span class="hljs-keyword">
    imports</span> DEFAULT-STRATEGY-CONCRETE<span class="hljs-keyword">
    imports</span> DEFAULT-STRATEGY-SYMBOLIC<span class="hljs-keyword">

    rule</span> initSCell(_) =&gt; &lt;s&gt; ^ regular &lt;/s&gt;<span class="hljs-keyword">
endmodule</span>
</code></pre>
<p>The second way you can extend the strategy language is with the
<code>STRATEGY-ABSTRACT</code> module. This provides a slightly more advanced set of
strategies which you can use to compose the basic strategies in the <code>STRATEGY</code>
module into more complex strategies. Note however that the functionality
provided is still relatively basic.</p>
<pre class="hljs"><code><span class="hljs-keyword">module</span> STRATEGY-ABSTRACT<span class="hljs-keyword">
    imports</span> STRATEGY<span class="hljs-keyword">

    syntax</span> #RuleTag ::= <span class="hljs-string">&quot;(&quot;</span> #RuleTag <span class="hljs-string">&quot;)&quot;</span> [<span class="hljs-literal">bracket</span>]
 <span class="hljs-comment">// ----------------------------------------------</span><span class="hljs-keyword">

    syntax</span> Strategy ::= <span class="hljs-string">&quot;.Strategy&quot;</span>
                      | <span class="hljs-string">&quot;(&quot;</span> Strategy <span class="hljs-string">&quot;)&quot;</span> [<span class="hljs-literal">bracket</span>]
 <span class="hljs-comment">// ----------------------------------------------</span><span class="hljs-keyword">
    rule</span> &lt;s&gt; .Strategy =&gt; . ... &lt;/s&gt;<span class="hljs-keyword">

    syntax</span> KItem ::= #catchSTUCK ( Strategy )
 <span class="hljs-comment">// -----------------------------------------</span><span class="hljs-keyword">
    rule</span> &lt;s&gt; #catchSTUCK(_) =&gt; . ... &lt;/s&gt;<span class="hljs-keyword">
    rule</span> &lt;s&gt; #STUCK() ~&gt; (S:Strategy =&gt; .) ... &lt;/s&gt;<span class="hljs-keyword">
    rule</span> &lt;s&gt; #STUCK() ~&gt; #catchSTUCK(S) =&gt; S ... &lt;/s&gt;<span class="hljs-keyword">

    syntax</span> Strategy ::= Strategy <span class="hljs-string">&quot;;&quot;</span> Strategy [<span class="hljs-literal">left</span>]
 <span class="hljs-comment">// ------------------------------------------------</span><span class="hljs-keyword">
    rule</span> &lt;s&gt; S:Strategy ; S&apos;:Strategy =&gt; S ~&gt; S&apos; ... &lt;/s&gt;<span class="hljs-keyword">

    syntax</span> #RuleTag ::= #RuleTag <span class="hljs-string">&quot;|&quot;</span> #RuleTag [<span class="hljs-literal">left</span>, klabel(#alternateRule)]
 <span class="hljs-comment">// ------------------------------------------------------------------------</span><span class="hljs-keyword">
    rule</span> &lt;s&gt; ^ RT:#RuleTag | RT&apos;:#RuleTag =&gt; ^ RT ~&gt; #catchSTUCK(^ RT&apos;) ... &lt;/s&gt;<span class="hljs-keyword">

    syntax</span> #RuleTag ::= #RuleTag <span class="hljs-string">&quot;*&quot;</span> [klabel(#repeatRule)]
 <span class="hljs-comment">// ------------------------------------------------------</span><span class="hljs-keyword">
    rule</span> &lt;s&gt; ^ RT:#RuleTag * =&gt; ^ RT ~&gt; ^ RT * ~&gt; #catchSTUCK(.Strategy) ... &lt;/s&gt;<span class="hljs-keyword">
endmodule</span>
</code></pre>
<p>The third mechanism for extending the strategy language is to define your own
strategy language. No special facility is required in K in order to compose
strategies together, so you are free to write whatever rules that manipulate
the strategy cell you want, and thus whatever more complex strategies you can
compose from the base builtin strategies.</p>
</body></html>
          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Render youtube video
        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = anchorElements.length - 1; i >= 0; i--) {
          if (anchorElements.length - 1 - i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`
<div style="text-align:center;">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/${youtubeId}"
    frameborder="0"
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen
    style="max-width: 100%;"
  ></iframe>
  <p>The video is out of date</p>
</div>
`);
              $(anchorElement).replaceWith($iframe[0]);
            }
          }
        }
      });
    </script>
  </body>
</html>
