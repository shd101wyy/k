<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../downloads.html"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../index.html">Homepage</a>
      <a class="bd-toc-link" href="../../../../../downloads.html">Downloads</a>
      <a class="bd-toc-link" href="../../../../../tutorials.html">K Tutorial</a>
      <a class="bd-toc-link" href="../../../../../people.html">People</a>
      <a class="bd-toc-link" href="../../../../../projects.html">Projects</a>
      <a class="bd-toc-link" href="../../../../../project_ideas.html"
        >Project Ideas</a
      >
      <a class="bd-toc-link" href="../../../../../publications.html">Publications</a>
      <a class="bd-toc-link" href="../../../../../news.html">News</a>
      <a class="bd-toc-link" href="../../../../../events.html">Events</a>
      <a class="bd-toc-link" href="../../../../../funding.html">Funding</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <h1 class="title"></h1>
          <p>Go back to <a href="../../../../../tutorials.html">K Tutorial.</a></p>
          <p>
            <a
              href="https://github.com/kframework/k/tree/master/k-distribution/tutorial/1_k/1_lambda/lesson_1"
              >All files</a
            >
            in the K tool distribution that were used in this movie.
          </p>
          <p>
            <a
              href="https://kframework.org/tool/run/?autoload=tutorial/1_k/1_lambda/lesson_1/lambda.k"
              target="_blank"
              rel="noopener"
            >
              <img src="../../../../../assets/img/try-it-online.jpg" /> Open Full
              Tool Page</a
            >
          </p>
          <div class="introduction markdown-preview">
            <hr>
<h2>copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.</h2>
<h1>SIMPLE — Typed — Static</h1>
<p>Author: Grigore Roșu (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin Șerbănuță (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h3>Abstract</h3>
<p>This is the <strong>K</strong> definition of the static semantics of the typed SIMPLE
language, or in other words, a type system for the typed SIMPLE
language in <strong>K</strong>.  We do not re-discuss the various features of the
SIMPLE language here.  The reader is referred to the untyped version of
the language for such discussions.  We here only focus on the new and
interesting problems raised by the addition of type declarations, and
what it takes to devise a type system/checker for the language.</p>
<p>When designing a type system for a language, no matter in what
paradigm, we have to decide upon the intended typing policy.  Note
that we can have multiple type systems for the same language, one for
each typing policy.  For example, should we accept programs which
don't have a main function?  Or should we allow functions that do not
return explicitly?  Or should we allow functions whose type expects
them to return a value (say an <code>int</code>) to use a plain
<code>return;</code> statement, which returns no value, like in C?
And so on and so forth.  Typically, there are two opposite tensions
when designing a type system.  On the one hand, you want your type
system to be as permissive as possible, that is, to accept as many
programs that do not get stuck when executed with the untyped
semantics as possible; this will keep the programmers using your
language happy.  On the other hand, you want your type system to have
a reasonable performance when implemented; this will keep both the
programmers and the implementers of your language happy.  For example,
a type system for rejecting programs that could perform
division-by-zero is not expected to be feasible in general.  A simple
guideline when designing typing policies is to imagine how the
semantics of the untyped language may get stuck and try to prevent
those situations from happening.</p>
<p>Before we give the <strong>K</strong> type system of SIMPLE formally, we discuss,
informally, the intended typing policy:</p>
<ul>
<li>
<p>Each program should contain a <code>main()</code> function.  Indeed,
the untyped SIMPLE semantics will get stuck on any program which does
not have a <code>main</code> function.</p>
</li>
<li>
<p>Each primitive value has its own type, which can be <code>int</code>
<code>bool</code>, or <code>string</code>.  There is also a type <code>void</code>
for nonexistent values, for example for the result of a function meant
to return no value (but only be used for its side effects, like a
procedure).</p>
</li>
<li>
<p>The syntax of untyped SIMPLE is extended to allow type
declarations for all the variables, including array variables.  This is
done in a C/Java-style.  For example, <code>int x;</code> or
<code>int x=7, y=x+3;</code>, or <code>int[][][] a[10,20];</code>
(the latter defines a <code>10 × 20</code> matrix of arrays of integers).
Recall from untyped SIMPLE that, unlike in C/Java, our multi-dimensional
arrays use comma-separated arguments, although they have the array-of-array
semantics.</p>
</li>
<li>
<p>Functions are also typed in a C/Java style.  However, since in SIMPLE
we allow functions to be passed to and returned by other functions, we also
need function types.  We will use the conventional higher-order arrow-notation
for function types, but will separate the argument types with commas.  For
example, a function returning an array of <code>bool</code> elements and
taking as argument an array <code>x</code> of two-integer-argument functions
returning an integer, is declared using a syntax of the form
<code>bool[] f(((int,int)-&gt;int)[] x) { ... }</code>
and has the type <code>((int,int)-&gt;int)[] -&gt; bool[]</code>.</p>
</li>
<li>
<p>We allow any variable declarations at the top level.  Functions
can only be declared at the top level.  Each function can only access the
other functions and variables declared at the top level, or its own locally
declared variables.  SIMPLE has static scoping.</p>
</li>
<li>
<p>The various expression and statement constructs take only elements of
the expected types.</p>
</li>
<li>
<p>Increment and assignment can operate both on variables and on array
elements.  For example, if <code>f</code> has type <code>int-&gt;int[][]</code> and
function <code>g</code> has the type <code>int-&gt;int</code>, then the
increment expression <code>++f(7)[g(2),g(3)]</code> is valid.</p>
</li>
<li>
<p>Functions should only return values of their declared result
type.  To give the programmers more flexibility, we allow functions to
use <code>return;</code> statements to terminate without returning an
actual value, or to not explicitly use any return statement,
regardless of their declared return type.  This flexibility can be
handy when writing programs using certain functions only for their
side effects.  Nevertheless, as the dynamic semantics shows, a return
value is automatically generated when an explicit <code>return</code>
statement is not encountered.</p>
</li>
<li>
<p>For simplicity, we here limit exceptions to only throw and catch
integer values.  We let it as an exercise to the reader to extend the
semantics to allow throwing and catching arbitrary-type exceptions.
Like in programming languages like Java, one can go even further and
define a semantics where thrown exceptions are propagated through
try-catch statements until one of the corresponding type is found.
We will do this when we define the KOOL language, not here.
To keep the definition if SIMPLE simple, here we do not attempt to
reject programs which throw uncaught exceptions.</p>
</li>
</ul>
<p>Like in untyped SIMPLE, some constructs can be desugared into a
smaller set of basic constructs.  In general, it should be clear why a
program does not type by looking at the top of the <code>k</code> cells in
its stuck configuration.</p>
<pre><code class="language-k">module SIMPLE-TYPED-STATIC-SYNTAX
  imports DOMAINS-SYNTAX
</code></pre>
<h3>Syntax</h3>
<p>The syntax of typed SIMPLE extends that of untyped SIMPLE with support
for declaring types to variables and functions.</p>
<pre><code class="language-k">  syntax Id ::= &quot;main&quot; [token]
</code></pre>
<h3>Types</h3>
<p>Primitive, array and function types, as well as lists (or tuples) of types.
The lists of types are useful for function arguments.</p>
<pre><code class="language-k">  syntax Type ::= &quot;void&quot; | &quot;int&quot; | &quot;bool&quot; | &quot;string&quot;
                | Type &quot;[&quot; &quot;]&quot;
                &gt; Types &quot;-&gt;&quot; Type
                | &quot;(&quot; Type &quot;)&quot;             [bracket]

  syntax Types ::= List{Type,&quot;,&quot;}
</code></pre>
<h3>Declarations</h3>
<p>Variable and function declarations have the expected syntax.  For variables,
we basically just replaced the <code>var</code> keyword of untyped SIMPLE with a
type.  For functions, besides replacing the <code>function</code> keyword with a
type, we also introduce a new syntactic category for typed variables,
<code>Param</code>, and lists over it.</p>
<pre><code class="language-k">  syntax Param ::= Type Id
  syntax Params ::= List{Param,&quot;,&quot;}

  syntax Decl ::= Type Exps &quot;;&quot;
                | Type Id &quot;(&quot; Params &quot;)&quot; Block
</code></pre>
<h3>Expressions</h3>
<p>The syntax of expressions is identical to that in untyped SIMPLE,
except for the logical conjunction and disjunction which have
different strictness attributes, because they now have different
evaluation strategies.</p>
<pre><code class="language-k">  syntax Exp ::= Int | Bool | String | Id
               | &quot;(&quot; Exp &quot;)&quot;             [bracket]
               | &quot;++&quot; Exp
               &gt; Exp &quot;[&quot; Exps &quot;]&quot;        [strict]
               &gt; Exp &quot;(&quot; Exps &quot;)&quot;        [strict]
               | &quot;-&quot; Exp                 [strict]
               | &quot;sizeOf&quot; &quot;(&quot; Exp &quot;)&quot;    [strict]
               | &quot;read&quot; &quot;(&quot; &quot;)&quot;
               &gt; left:
                 Exp &quot;*&quot; Exp             [strict, left]
               | Exp &quot;/&quot; Exp             [strict, left]
               | Exp &quot;%&quot; Exp             [strict, left]
               &gt; left:
                 Exp &quot;+&quot; Exp             [strict, left]
               | Exp &quot;-&quot; Exp             [strict, left]
               &gt; non-assoc:
                 Exp &quot;&lt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&lt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;&gt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&gt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;==&quot; Exp            [strict, non-assoc]
               | Exp &quot;!=&quot; Exp            [strict, non-assoc]
               &gt; &quot;!&quot; Exp                 [strict]
               &gt; left:
                 Exp &quot;&amp;&amp;&quot; Exp            [strict, left]
               | Exp &quot;||&quot; Exp            [strict, left]
               &gt; &quot;spawn&quot; Block
               &gt; Exp &quot;=&quot; Exp             [strict(2), right]
</code></pre>
<p>Note that <code>spawn</code> has not been declared strict.  This may
seem unexpected,  because the child thread shares the same environment
with the parent thread, so from a typing perspective the spawned
statement makes the same sense in a child thread as it makes in the
parent thread.  The reason for not declaring it strict is because we
want to disallow programs where the spawned thread calls the
<code>return</code> statement, because those programs would get stuck in
the dynamic semantics.  The type semantics of spawn below will reject
such programs.</p>
<p>We still need lists of expressions, defined below, but note that we do
not need lists of identifiers anymore.  They have been replaced by the lists
of parameters.</p>
<pre><code class="language-k">  syntax Exps ::= List{Exp,&quot;,&quot;}          [strict]
</code></pre>
<h3>Statements</h3>
<p>The statements have the same syntax as in untyped SIMPLE, except for
the exceptions, which now type their parameter.  Note that, unlike in untyped
SIMPLE, all statement constructs which have arguments and are not desugared
are strict, including the conditional and the <code>while</code>.  Indeed, from a
typing perspective, they are all strict: first type their arguments and then
type the actual construct.</p>
<pre><code class="language-k">  syntax Block ::= &quot;{&quot; &quot;}&quot;
                | &quot;{&quot; Stmts &quot;}&quot;

  syntax Stmt ::= Decl | Block
                | Exp &quot;;&quot;                                  [strict]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block &quot;else&quot; Block      [avoid, strict]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block
                | &quot;while&quot; &quot;(&quot; Exp &quot;)&quot; Block                [strict]
                | &quot;for&quot; &quot;(&quot; Stmts Exp &quot;;&quot; Exp &quot;)&quot; Block
                | &quot;return&quot; Exp &quot;;&quot;                         [strict]
                | &quot;return&quot; &quot;;&quot;
                | &quot;print&quot; &quot;(&quot; Exps &quot;)&quot; &quot;;&quot;                 [strict]
                | &quot;try&quot; Block &quot;catch&quot; &quot;(&quot; Param &quot;)&quot; Block  [strict(1)]
                | &quot;throw&quot; Exp &quot;;&quot;                          [strict]
                | &quot;join&quot; Exp &quot;;&quot;                           [strict]
                | &quot;acquire&quot; Exp &quot;;&quot;                        [strict]
                | &quot;release&quot; Exp &quot;;&quot;                        [strict]
                | &quot;rendezvous&quot; Exp &quot;;&quot;                     [strict]
</code></pre>
<p>Note that the sequential composition is now sequentially strict,
because, unlike in the dynamic semantics where statements dissolved,
they now reduce to the <code>stmt</code> type, which is a result.</p>
<pre><code class="language-k">  syntax Stmts ::= Stmt
                |  Stmts Stmts                             [seqstrict, right]
</code></pre>
<h3>Desugaring macros</h3>
<p>We use the same desugaring macros like in untyped SIMPLE, but, of
course, including the types of the involved variables.</p>
<pre><code class="language-k">  rule if (E) S =&gt; if (E) S else {}                                     [macro]
  rule for(Start Cond; Step) {S:Stmts} =&gt; {Start while(Cond){S Step;}}  [macro]
  rule for(Start Cond; Step) {} =&gt; {Start while(Cond){Step;}}           [macro]
  rule T:Type E1:Exp, E2:Exp, Es:Exps; =&gt; T E1; T E2, Es;               [macro-rec]
  rule T:Type X:Id = E; =&gt; T X; X = E;                                  [macro]

endmodule


module SIMPLE-TYPED-STATIC
  imports SIMPLE-TYPED-STATIC-SYNTAX
  imports DOMAINS
</code></pre>
<h3>Static semantics</h3>
<p>Here we define the type system of SIMPLE.  Like concrete semantics,
type systems defined in <strong>K</strong> are also executable.  However, <strong>K</strong> type
systems turn into type checkers instead of interpreters when executed.</p>
<p>The typing process is done in two (overlapping) phases.  In the first
phase the global environment is built, which contains type bindings
for all the globally declared variables and functions.  For functions,
the declared types will be ``trusted'' during the first phase and
simply bound to their corresponding function names and placed in the
global type environment.  At the same time, type-checking tasks that
the function bodies indeed respect their claimed types are generated.
All these tasks are (concurrently) verified during the second phase.
This way, all the global variable and function declarations are
available in the global type environment and can be used in order to
type-check each function code.  This is consistent with the semantics
of untyped SIMPLE, where functions can access all the global variables
and can call any other function declared in the same program.  The
two phases may overlap because of the <strong>K</strong> concurrent semantics.  For
example, a function task can be started while the first phase is still
running; moreover, it may even complete before the first phase does,
namely when all the global variables and functions that it needs have
already been processed and made available in the global environment by
the first phase task.</p>
<h3>Extended syntax and results</h3>
<p>The idea is to start with a configuration holding the program to type
in one of its cells, then apply rewrite rules on it mixing types and
language syntax, and eventually obtain a type instead of the original
program.  In other words, the program reduces to its type using
the <strong>K</strong> rules giving the type system of the language.  In doing so,
additional typing tasks for function bodies are generated and solved
the same way.  If this rewriting process gets stuck, then we say that
the program is not well-typed.  Otherwise the program is well-typed
(by definition).  We did not need types for statements and for blocks
as part of the typed SIMPLE syntax, because programmers are not allowed
to use such types explicitly.  However, we are going to need them in the
type system, because blocks and statements reduce to them.</p>
<p>We start by allowing types to be used inside expressions and statements in
our language.  This way, types can be used together with language syntax in
subsequent <strong>K</strong> rules without any parsing errors.  Like in the type system of
IMP++ in the <strong>K</strong> tutorial, we prefer to group the block and statement types
under one syntactic sub-category of types, because this allows us to more
compactly state that certain terms can be either blocks or statements.  Also,
since programs and fragments of program will reduce to their types, in order
for the strictness and context declarations to be executable we state that
types are results (same like we did in the IMP++ tutorial).</p>
<pre><code class="language-k">  syntax Exp ::= Type
  syntax Exps ::= Types
  syntax BlockOrStmtType ::= &quot;block&quot; | &quot;stmt&quot;
  syntax Type ::= BlockOrStmtType
  syntax Block ::= BlockOrStmtType
  syntax KResult ::= Type
                   | Types    //TODO: remove this, eventually
</code></pre>
<h3>Configuration</h3>
<p>The configuration of our type system consists of a <code>tasks</code> cell
holding various typing <code>task</code> cells, and a global type environment.
Each task includes a <code>k</code> cell holding the code to type, a <code>tenv</code>
cell holding the local type environment, and a <code>return</code> cell holding
the return type of the currently checked function.  The latter is needed in
order to check whether return statements return values of the expected type.
Initially, the program is placed in a <code>k</code> cell inside a
<code>task</code> cell.  Since the cells with multiplicity <code>?</code> are not
included in the initial configuration, the <code>task</code> cell holding
the original program in its <code>k</code> cell will contain no other
subcells.</p>
<pre><code class="language-k">  configuration &lt;T color=&quot;yellow&quot;&gt;
                  &lt;tasks color=&quot;orange&quot;&gt;
                    &lt;task multiplicity=&quot;*&quot; color=&quot;yellow&quot;&gt;
                      &lt;k color=&quot;green&quot;&gt; $PGM:Stmts &lt;/k&gt;
                      &lt;tenv multiplicity=&quot;?&quot; color=&quot;cyan&quot;&gt; .Map &lt;/tenv&gt;
                      &lt;returnType multiplicity=&quot;?&quot; color=&quot;black&quot;&gt; void &lt;/returnType&gt;
                    &lt;/task&gt;
                  &lt;/tasks&gt;
//                  &lt;br/&gt;
                  &lt;gtenv color=&quot;blue&quot;&gt; .Map &lt;/gtenv&gt;
                &lt;/T&gt;
</code></pre>
<h3>Variable declarations</h3>
<p>Variable declarations type as statements, that is, they reduce to the
type <code>stmt</code>.  There are only two cases that need to be
considered: when a simple variable is declared and when an array
variable is declared.  The macros at the end of the syntax module
above take care of reducing other variable declarations, including
ones where the declared variables are initialized, to only these two
cases.  The first case has two subcases: when the variable declaration
is global (i.e., the <code>task</code> cell contains only the <code>k</code>
cell), in which case it is added to the global type environment
checking at the same time that the variable has not been already
declared; and when the variable declaration is local (i.e., a
<code>tenv</code> cell is available), in which case it is simply added to
the local type environment, possibly shadowing previous homonymous
variables.  The third case reduces to the second, incrementally moving
the array dimension into the type until the array becomes a simple
variable.</p>
<pre><code class="language-k">  rule &lt;task&gt; &lt;k&gt; T:Type X:Id; =&gt; stmt ...&lt;/k&gt; &lt;/task&gt;
       &lt;gtenv&gt; Rho (.Map =&gt; X |-&gt; T) &lt;/gtenv&gt;
    requires notBool(X in keys(Rho))
  rule &lt;k&gt; T:Type X:Id; =&gt; stmt ...&lt;/k&gt; &lt;tenv&gt; Rho =&gt; Rho[X &lt;- T] &lt;/tenv&gt;

  context _:Type _::Exp[HOLE::Exps];
// The rule below may need to sort E to Exp in the future, if the
// parser gets stricter; without that information, it may not be able
// to complete the LHS into T E[int,Ts],.Exps; (and similarly for the RHS)
  rule T:Type E:Exp[int,Ts:Types]; =&gt; T[] E[Ts];  [structural]
// I want to write the rule below as _:Type (E:Exp[.Types] =&gt; E),
// but the list completion seems to not work well with that.
  rule T:Type E:Exp[.Types]; =&gt; T E;          [structural]
</code></pre>
<h3>Function declarations</h3>
<p>Functions are allowed to be declared only at the top level (the
<code>task</code> cell holds only its <code>k</code> subcell).  Each function
declaration reduces to a variable declaration (a binding of its name
to its declared function type), but also adds a task into the
<code>tasks</code> cell.  The task consists of a typing of the statement
declaring all the function parameters followed by the function body,
together with the expected return type of the function.  The
<code>getTypes</code> and <code>mkDecls</code> functions, defined at the end of
the file in the section on auxiliary operations, extracts the list of
types and makes a sequence of variable declarations from a list of
function parameters, respectively.  Note that, although in the dynamic
semantics we include a terminating <code>return</code> statement at the
end of the function body to eliminate from the analysis the case when
the function does not provide an explicit return, we do not need to
include such a similar <code>return</code> statement here.  That's because
the <code>return</code> statements type to <code>stmt</code> anyway, and the
entire code of the function body needs to type anyway.</p>
<pre><code class="language-k">  rule &lt;task&gt; &lt;k&gt; T:Type F:Id(Ps:Params) S =&gt; getTypes(Ps)-&gt;T F; ...&lt;/k&gt; &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt;
               &lt;k&gt; mkDecls(Ps) S &lt;/k&gt; &lt;tenv&gt; .Map &lt;/tenv&gt; &lt;returnType&gt; T &lt;/returnType&gt;
             &lt;/task&gt;)
    [structural]
</code></pre>
<h3>Checking if <code>main()</code> exists}</h3>
<p>Once the entire program is processed (generating appropriate tasks
to type check its function bodies), we can dissolve the main
<code>task</code> cell (the one holding only a <code>k</code> subcell).  Since
we want to enforce that programs include a main function, we also
generate a function task executing <code>main()</code> to ensure that it
types (remove this task creation if you do not want your type system
to reject programs without a <code>main</code> function).</p>
<pre><code class="language-k">  rule &lt;task&gt; &lt;k&gt; stmt =&gt; main(.Exps); &lt;/k&gt; (.Bag =&gt; &lt;tenv&gt; .Map &lt;/tenv&gt;) &lt;/task&gt;
    [structural]
</code></pre>
<h3>Collecting the terminated tasks</h3>
<p>Similarly, once a non-main task (i.e., one which contains a
<code>tenv</code> subcells) is completed using the subsequent rules (i.e.,
its <code>k</code> cell holds only the <code>block</code> or <code>stmt</code>
type), we can dissolve its corresponding cell.  Note that it is
important to ensure that we only dissolve tasks containing a
<code>tenv</code> cell with the rule below, because the main task should
<code>not</code> dissolve this way!  It should do what the above rule says.
In the end, there should be no task cell left in the configuration
when the program correctly type checks.</p>
<pre><code class="language-k">  rule &lt;task&gt;... &lt;k&gt; _:BlockOrStmtType &lt;/k&gt; &lt;tenv&gt; _ &lt;/tenv&gt; ...&lt;/task&gt; =&gt; .Bag
</code></pre>
<h3>Basic values</h3>
<p>The first three rewrite rules below reduce the primitive values to
their types, as we typically do when we define type systems in <strong>K</strong>.</p>
<pre><code class="language-k">  rule _:Int =&gt; int
  rule _:Bool =&gt; bool
  rule _:String =&gt; string
</code></pre>
<h3>Variable lookup</h3>
<p>There are three cases to distinguish for variable lookup: (1) if the
variable is bound in the local type environment, then look its type up
there; (2) if a local environment exists and the variable is not bound
in it, then look its type up in the global environment; (3) finally,
if there is no local environment, meaning that we are executing the
top-level pass, then look the variable's type up in the global
environment, too.</p>
<pre><code class="language-k">  rule &lt;k&gt; X:Id =&gt; T ...&lt;/k&gt; &lt;tenv&gt;... X |-&gt; T ...&lt;/tenv&gt;

  rule &lt;k&gt; X:Id =&gt; T ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;gtenv&gt;... X |-&gt; T ...&lt;/gtenv&gt;
    requires notBool(X in keys(Rho))

  rule &lt;task&gt; &lt;k&gt; X:Id =&gt; T ...&lt;/k&gt; &lt;/task&gt; &lt;gtenv&gt;... X |-&gt; T ...&lt;/gtenv&gt;
</code></pre>
<h3>Increment</h3>
<p>We want the increment operation to apply to any lvalue, including
array elements, not only to variables.  For that reason, we define a
special context extracting the type of the argument of the increment
operation only if that argument is an lvalue.  Otherwise the rewriting
process gets stuck.  The operation <code>ltype</code> is defined at the
end of this file, in the auxiliary operation section.  It essentially
acts as a filter, getting stuck if its argument is not an lvalue and
letting it reduce otherwise.  The type of the lvalue is expected to be
an integer in order to be allowed to be incremented, as seen in the
rule <code>++ int =&gt; int</code> below.</p>
<pre><code class="language-k">  context ++(HOLE =&gt; ltype(HOLE))
  rule ++ int =&gt; int
</code></pre>
<h3>Common expression constructs</h3>
<p>The rules below are straightforward and self-explanatory:</p>
<pre><code class="language-k">  rule int + int =&gt; int
  rule string + string =&gt; string
  rule int - int =&gt; int
  rule int * int =&gt; int
  rule int / int =&gt; int
  rule int % int =&gt; int
  rule - int =&gt; int
  rule int &lt; int =&gt; bool
  rule int &lt;= int =&gt; bool
  rule int &gt; int =&gt; bool
  rule int &gt;= int =&gt; bool
  rule T:Type == T =&gt; bool
  rule T:Type != T =&gt; bool
  rule bool &amp;&amp; bool =&gt; bool
  rule bool || bool =&gt; bool
  rule ! bool =&gt; bool
</code></pre>
<h3>Array access and size</h3>
<p>Array access requires each index to type to an integer, and the
array type to be at least as deep as the number of indexes:</p>
<pre><code class="language-k">// NOTE:
// We used to need parentheses in the RHS, to avoid capturing Ts as rule tag.
// Let's hope that is not a problem anymore.

  rule (T[])[int, Ts:Types] =&gt; T[Ts]
  rule T:Type[.Types] =&gt; T
</code></pre>
<p><code>sizeOf</code> only needs to check that its argument is an array:</p>
<pre><code class="language-k">  rule sizeOf(T[]) =&gt; int
</code></pre>
<h3>Input/Output</h3>
<p>The read expression construct types to an integer, while print types
to a statement provided that all its arguments type to integers or
strings.</p>
<pre><code class="language-k">  rule read() =&gt; int

  rule print(T:Type, Ts =&gt; Ts); requires T ==K int orBool T ==K string
  rule print(.Types); =&gt; stmt
</code></pre>
<h3>Assignment</h3>
<p>The special context and the rule for assignment below are similar
to those for increment: the LHS of the assignment must be an lvalue
and, in that case, it must have the same type as the RHS, which then
becomes the type of the assignment.</p>
<pre><code class="language-k">  context (HOLE =&gt; ltype(HOLE)) = _
  rule T:Type = T =&gt; T
</code></pre>
<h3>Function application and return</h3>
<p>Function application requires the type of the function and the
types of the passed values to be compatible.  Note that a special case
is needed to handle the no-argument case:</p>
<pre><code class="language-k">  rule (Ts:Types -&gt; T)(Ts) =&gt; T requires Ts =/=K .Types
  rule (void -&gt; T)(.Types) =&gt; T
</code></pre>
<p>The returned value must have the same type as the declared
function return type.  If an empty return is encountered, than
we should check that we are in a function (and not a thread)
context, that is, a <code>return</code> cell must be available:</p>
<pre><code class="language-k">  rule &lt;k&gt; return T:Type; =&gt; stmt ...&lt;/k&gt; &lt;returnType&gt; T &lt;/returnType&gt;
  rule &lt;k&gt; return; =&gt; stmt ...&lt;/k&gt; &lt;returnType&gt; _ &lt;/returnType&gt;
</code></pre>
<h3>Blocks</h3>
<p>To avoid having to recover type environments after blocks, we prefer
to start a new task for block body, making sure that the new task
is passed the same type environment and return cells.  The value
returned by <code>return</code> statements must have the same type as
stated in the <code>return</code> cell.  The <code>print</code> variadic
function is allowed to only print integers and strings.  The thrown
exceptions can only have integer type.</p>
<pre><code class="language-k">  rule {} =&gt; block

  rule &lt;task&gt; &lt;k&gt; {S} =&gt; block ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;
       (.Bag =&gt; &lt;task&gt; &lt;k&gt; S &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; R &lt;/task&gt;)
</code></pre>
<h3>Expression statement</h3>
<pre><code class="language-k">  rule _:Type; =&gt; stmt
</code></pre>
<h3>Conditional and <code>while</code> loop</h3>
<pre><code class="language-k">  rule if (bool) block else block =&gt; stmt
  rule while (bool) block =&gt; stmt
</code></pre>
<h3>Exceptions</h3>
<p>We currently force the parameters of exceptions to only be integers.
Moreover, for simplicity, we assume that integer exceptions can be
thrown from anywhere, including from functions which do not define
any try-catch block (with the currently unchecked ‒also for
simplicity‒ expectation that the caller functions would catch those
exceptions).</p>
<pre><code class="language-k">  rule try block catch(int X:Id) {S} =&gt; {int X; S}  [structural]
  rule try block catch(int X:Id) {} =&gt; {int X;}  [structural]
  rule throw int; =&gt; stmt
</code></pre>
<h3>Concurrency</h3>
<p>Nothing special about typing the concurrency constructs, except that
we do not want the spawned thread to return, so we do not include any
<code>return</code> cell in the new task cell for the thread statement.
Same like with the functions above, we do not check for thrown
exceptions which are not caught.</p>
<pre><code class="language-k">  rule &lt;k&gt; spawn S =&gt; int ...&lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt;
       (.Bag =&gt; &lt;task&gt; &lt;k&gt; S &lt;/k&gt; &lt;tenv&gt; Rho &lt;/tenv&gt; &lt;/task&gt;)
  rule join int; =&gt; stmt
  rule acquire _:Type; =&gt; stmt
  rule release _:Type; =&gt; stmt
  rule rendezvous _:Type; =&gt; stmt

  rule _:BlockOrStmtType _:BlockOrStmtType =&gt; stmt
</code></pre>
<h3>Auxiliary constructs</h3>
<p>The function <code>mkDecls</code> turns a list of parameters into a
list of variable declarations.</p>
<pre><code class="language-k">  syntax Stmts ::= mkDecls(Params)  [function]
  rule mkDecls(T:Type X:Id, Ps:Params) =&gt; T X; mkDecls(Ps)
  rule mkDecls(.Params) =&gt; {}
</code></pre>
<p>The <code>ltype</code> context allows only expressions which have an
lvalue to evaluate.</p>
<pre><code class="language-k">  syntax LValue ::= Id
  rule isLValue(_:Exp[_:Exps]) =&gt; true
  syntax Exp ::= LValue  // K should be able to infer this
                         // if not added, then it gets stuck with an Id on k cell

// Instead of the second LValue production above you can use a rule:
//  rule isLValue(_:Exp[_:Exps]) =&gt; true

  syntax Exp ::= ltype(Exp)
//  context ltype(HOLE:LValue)
// The above context does not work due to some error, so we write instead
  context ltype(HOLE) requires isLValue(HOLE)
</code></pre>
<p>The function <code>getTypes</code> is the same as in SIMPLE typed dynamic.</p>
<pre><code class="language-k">  syntax Types ::= getTypes(Params)  [function]
  rule getTypes(T:Type _:Id) =&gt; T, .Types   // I would like to not use .Types
  rule getTypes(T:Type _:Id, P, Ps) =&gt; T, getTypes(P,Ps)
  rule getTypes(.Params) =&gt; void, .Types

endmodule
</code></pre>

          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        const headerSelector =
          ".markdown-preview h1, .markdown-preview h2, .markdown-preview h3";
        if ($(headerSelector).length) {
          if ($(headerSelector)[0].innerText.match(/^copyright/)) {
            $(headerSelector)[0].remove();
          }
          if ($(headerSelector).length) {
            const title = $(headerSelector)[0].innerText;
            $(".title").text(title);
            $(headerSelector)[0].remove();
          }
        }
        const youtubeHref = $(".markdown-preview a")[0].getAttribute("href");
        if (youtubeHref.match(/^https?:\/\/youtu.be\//)) {
          const match = youtubeHref.match(/^https?:\/\/youtu.be\/(.+?)$/);
          if (match && match[1]) {
            const youtubeId = match[1];
            const $iframe = $(`<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/${youtubeId}"
  frameborder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
  style="max-width: 100%;"
></iframe>`);
            $(".markdown-preview a")[0].replaceWith($iframe[0]);
          }
        }
      });
    </script>
  </body>
</html>
