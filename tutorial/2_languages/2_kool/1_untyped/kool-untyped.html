<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="K | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../assets/img/favicon.ico" />

<title>
  K | Runtime Verification Inc
</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px;"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/kframework/k"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../downloads.html"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem;"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../index.html">Homepage</a>
      <a class="bd-toc-link" href="../../../../downloads.html">Downloads</a>
      <a class="bd-toc-link" href="../../../../tutorials.html">K Tutorial</a>
      <a class="bd-toc-link" href="../../../../people.html">People</a>
      <a class="bd-toc-link" href="../../../../projects.html">Projects</a>
      <a class="bd-toc-link" href="../../../../project_ideas.html"
        >Project Ideas</a
      >
      <a class="bd-toc-link" href="../../../../publications.html">Publications</a>
      <a class="bd-toc-link" href="../../../../news.html">News</a>
      <a class="bd-toc-link" href="../../../../events.html">Events</a>
      <a class="bd-toc-link" href="../../../../funding.html">Funding</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <h1 class="title"></h1>
          <p>Go back to <a href="../../../../tutorials.html">K Tutorial.</a></p>
          <p>
            <a
              href="https://github.com/kframework/k/tree/master/k-distribution/tutorial/1_k/1_lambda/lesson_1"
              >All files</a
            >
            in the K tool distribution that were used in this movie.
          </p>
          <p>
            <a id="try-it-online-link" target="_blank" rel="noopener">
              <img src="../../../../assets/img/try-it-online.jpg" /> Open Full
              Tool Page</a
            >
          </p>
          <div class="introduction markdown-preview">
            <hr>
<h2>copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.</h2>
<h1>KOOL — Untyped</h1>
<p><a href="http://kframework.org/tool/run/?autoload=tutorial/2_languages/2_kool/1_untyped/kool-untyped.k">Try it online</a></p>
<p>Author: Grigore Roșu (<a href="mailto:grosu@illinois.edu">grosu@illinois.edu</a>)<br>
Organization: University of Illinois at Urbana-Champaign</p>
<p>Author: Traian Florin Șerbănuță (<a href="mailto:traian.serbanuta@unibuc.ro">traian.serbanuta@unibuc.ro</a>)<br>
Organization: University of Bucharest</p>
<h3>Abstract</h3>
<p>This is the <strong>K</strong> semantic definition of the untyped KOOL language.  KOOL
is aimed at being a pedagogical and research language that captures
the essence of the object-oriented programming paradigm.  Its untyped
variant discussed here is simpler than the typed one, ignoring several
intricate aspects of types in the presence of objects.  A program
consists of a set of class declarations.  Each class can extend at
most one other class (KOOL is single-inheritance).  A class can
declare a set of fields and a set of methods, all public and called
the class' <em>members</em>.  Specifically, KOOL includes the
following features:</p>
<ul>
<li>
<p>Class declarations, where a class may or may not explicitly
extend another class.  In case a class does not explicitly extend
another class, then it is assumed that it extends the default top-most
and empty (i.e., no members) class called <code>Object</code>.  Each class
is required to declare precisely one homonymous method, called its
<em>constructor</em>.  Each valid program should contain one class
named <code>Main</code>, whose constructor, <code>Main()</code>, takes no
arguments.  The execution of a program consists of creating an object
instance of class <code>Main</code> and invoking the constructor
<code>Main()</code> on it, that is, of executing <code>new Main();</code>.</p>
</li>
<li>
<p>All features of SIMPLE (see <code>examples/simple/untyped</code>),
i.e., multidimensional arrays, function (here called &quot;method&quot;)
abstractions with call-by-value parameter passing style and static
scoping, blocks with locals, input/output, parametric exceptions, and
concurrency via dynamic thread creation/termination and synchronization.
The only change in the syntax of SIMPLE when imported in KOOL is the
function declaration keyword, <code>function</code>, which is changed into
<code>method</code>.  The exact same desugaring macros from SIMPLE are
also included in KOOL.  We can think of KOOL's classes as embedding
SIMPLE programs (extended with OO constructs, as discussed next).</p>
</li>
<li>
<p>Object creation using the <code>new C(e1,...,en)</code>
expression construct.  An object instance of class <code>C</code> is first
created and then the constructor <code>C(e1,...,en)</code> is implicitly
called on that object.  KOOL only allows (and requires) one
constructor per class.  The class constructor can be called either
implicitly during a new object creation for the class, or explicitly.
The superclass constructor is <strong>not</strong> implicitly invoked when a
class constructor is invoked; if you want to invoke the superclass
constructor from a subclass constructor then you have to do it
explicitly.</p>
</li>
<li>
<p>An expression construct <code>this</code>, which evaluates to the
current object.</p>
</li>
<li>
<p>An expression construct <code>super</code>, which is used (only) in
combination with member lookup (see next) to refer to a superclass
field or method.</p>
</li>
<li>
<p>A member lookup expression construct <code>e.x</code>, where <code>e</code>
is an expression (either an expression expected to evaluate to an object
or the <code>super</code> construct) and <code>x</code> is a class member name,
that is, a field or a method name.</p>
</li>
<li>
<p>Expression constructs <code>e instanceOf C</code> and
<code>(C) e</code>, where <code>e</code> is an expression expected
to evaluate to an object and <code>C</code> a class name.  The former
tells whether the class of <code>e</code> is a subclass of <code>C</code>,
that is, whether <code>e</code> can be used as an instance of <code>C</code>,
and the latter changes the class of <code>e</code> to <code>C</code>.  These
operations always succeed: the former returns a Boolean value, while
the latter changes the current class of <code>e</code> to <code>C</code>
regardless of whether it is safe to do so or not.  The typed version
of KOOL will check the safety of casting by ensuring that the instance
class of the object is a subclass of <code>C</code>.  In untyped KOOL we
do not want to perform this check because we want to allow the
programmer maximum of flexibility: if one always accesses only
available members, then the program can execute successfully despite
the potentially unsafe cast.</p>
</li>
</ul>
<p>There are some specific aspects of KOOL that need to be discussed.</p>
<p>First, KOOL is higher-order, allowing function abstractions to be
treated like any other values in the language.  For example, if
<code>m</code> is a method of object <code>e</code> then <code>e.m</code>
evaluates to the corresponding function abstraction.  The function
abstraction is in fact a closure, because in addition to the method
parameters and body it also encapsulates the object value (i.e., the
environment of the object together with its current class—see below)
that <code>e</code> evaluates to.  This way, function abstractions can be
invoked anywhere and have the capability to change the state of their
object.  For example, if <code>m</code> is a method of object <code>e</code>
which increments a field <code>c</code> of <code>e</code> when invoked, and if
<code>getm</code> is another method of <code>e</code> which simply returns
<code>m</code> when invoked, then the double application
<code>(e.getm())()</code> has the same effect as <code>e.m()</code>, that is,
increments the counter <code>c</code> of <code>e</code>.  Note that the
higher-order nature of KOOL was not originally planned; it came as a
natural consequence of evaluating methods to closures and we decided
to keep it.  If you do not like it then do not use it.</p>
<p>Second, since all the fields and methods are public in KOOL and since
they can be redeclared in subclasses, it is not immediately clear how
to lookup the member <code>x</code> when we write <code>e.x</code> and
<code>e</code> is different from <code>super</code>.  We distinguish two cases,
depending on whether <code>e.x</code> occurs in a method invocation
context (i.e., <code>e.x(...)</code>) or in a field context.  KOOL has
dynamic method dispatch, so if <code>e.x</code> is invoked as a method
then <code>x</code> will be searched for starting with the instance class of
the object value to which <code>e</code> evaluates.  If <code>e.x</code>
occurs in a non-method-invocation context then <code>x</code> will be
treated as a field (although it may hold a method closure due to the
higher-order nature of KOOL) and thus will be searched starting with
the current class of the object value of <code>e</code> (which, because of
<code>this</code> and casting, may be different from its instance class).
In order to achieve the above, each object value will consist of a
pair holding the current class of the object and an environment stack
with one layer for each class in the object's instance class hierarchy.</p>
<p>Third, although KOOL is dynamic method dispatch, its capabilities
described above are powerful enough to allow us to mimic static
method dispatch.  For example, suppose that you want to invoke method
<code>m()</code> statically.  Then all you need to do is to declare a
local variable and bind it to <code>m</code>, for example <code>var staticm = m;</code>, and
then call <code>staticm()</code>.  This works because
<code>staticm</code> is first bound to the method closure that <code>m</code>
evaluates to, and then looked up as any local variable when invoked.
We only enable the dynamic method dispatch when we have an object
member on an application position, e.g., <code>m()</code>.</p>
<p>In what follows, we limit our comments to the new, KOOL-specific
aspects of the language.  We refer the reader to the untyped SIMPLE
language for documentation on the the remaining features, because
those were all borrowed from SIMPLE.</p>
<pre><code class="language-k">module KOOL-UNTYPED-SYNTAX
  imports DOMAINS-SYNTAX
</code></pre>
<h3>Syntax</h3>
<p>The syntax of KOOL extends that of SIMPLE with object-oriented
constructs.  We removed from the <strong>K</strong> annotated syntax of SIMPLE two
constructs, namely the one for function declarations (because we want
to call them <code>methods</code> now) and the one for function application
(because application is not strict in the first argument
anymore—needs to initiate dynamic method dispatch).  The additional
syntax includes:</p>
<ul>
<li>First, we need a new dedicated identifier, <code>Object</code>, for
the default top-most class.</li>
<li>Second, we rename the <code>function</code> keyword of SIMPLE into <code>method</code>.</li>
<li>Third, we add syntax for class declarations together with a
macro making classes which extend nothing to extend <code>Object</code>.</li>
<li>Fourth, we change the strictness attribute of application
into <code>strict(2)</code>.</li>
<li>Finally, we add syntax and corresponding strictness
for the KOOL object-oriented constructs.</li>
</ul>
<pre><code class="language-k">  syntax Id ::= &quot;Object&quot; [token] | &quot;Main&quot; [token]

  syntax Decl ::= &quot;var&quot; Exps &quot;;&quot;
                | &quot;method&quot; Id &quot;(&quot; Ids &quot;)&quot; Block  // called &quot;function&quot; in SIMPLE
                | &quot;class&quot; Id Block               // KOOL
                | &quot;class&quot; Id &quot;extends&quot; Id Block  // KOOL

  syntax Exp ::= Int | Bool | String | Id
               | &quot;this&quot;                                 // KOOL
               | &quot;super&quot;                                // KOOL
               | &quot;(&quot; Exp &quot;)&quot;             [bracket]
               | &quot;++&quot; Exp
               | Exp &quot;instanceOf&quot; Id     [strict(1)]    // KOOL
               | &quot;(&quot; Id &quot;)&quot; Exp          [strict(2)]    // KOOL  cast
               | &quot;new&quot; Id &quot;(&quot; Exps &quot;)&quot;   [strict(2)]    // KOOL
               | Exp &quot;.&quot; Id                             // KOOL
               &gt; Exp &quot;[&quot; Exps &quot;]&quot;        [strict]
               &gt; Exp &quot;(&quot; Exps &quot;)&quot;        [strict(2)]    // was strict in SIMPLE
               | &quot;-&quot; Exp                 [strict]
               | &quot;sizeOf&quot; &quot;(&quot; Exp &quot;)&quot;    [strict]
               | &quot;read&quot; &quot;(&quot; &quot;)&quot;
               &gt; left:
                 Exp &quot;*&quot; Exp             [strict, left]
               | Exp &quot;/&quot; Exp             [strict, left]
               | Exp &quot;%&quot; Exp             [strict, left]
               &gt; left:
                 Exp &quot;+&quot; Exp             [strict, left]
               | Exp &quot;-&quot; Exp             [strict, left]
               &gt; non-assoc:
                 Exp &quot;&lt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&lt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;&gt;&quot; Exp             [strict, non-assoc]
               | Exp &quot;&gt;=&quot; Exp            [strict, non-assoc]
               | Exp &quot;==&quot; Exp            [strict, non-assoc]
               | Exp &quot;!=&quot; Exp            [strict, non-assoc]
               &gt; &quot;!&quot; Exp                 [strict]
               &gt; left:
                 Exp &quot;&amp;&amp;&quot; Exp            [strict(1), left]
               | Exp &quot;||&quot; Exp            [strict(1), left]
               &gt; &quot;spawn&quot; Block
               &gt; Exp &quot;=&quot; Exp             [strict(2), right]

  syntax Ids  ::= List{Id,&quot;,&quot;}

  syntax Exps ::= List{Exp,&quot;,&quot;}          [strict, klabel(exps)]
  syntax Val
  syntax Vals ::= List{Val,&quot;,&quot;}          [klabel(exps)]

  syntax Block ::= &quot;{&quot; &quot;}&quot;
                | &quot;{&quot; Stmts &quot;}&quot;

  syntax Stmt ::= Decl | Block
                | Exp &quot;;&quot;                               [strict]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block &quot;else&quot; Block   [avoid, strict(1)]
                | &quot;if&quot; &quot;(&quot; Exp &quot;)&quot; Block
                | &quot;while&quot; &quot;(&quot; Exp &quot;)&quot; Block
            | &quot;for&quot; &quot;(&quot; Stmts Exp &quot;;&quot; Exp &quot;)&quot; Block
                | &quot;return&quot; Exp &quot;;&quot;                      [strict]
                | &quot;return&quot; &quot;;&quot;
                | &quot;print&quot; &quot;(&quot; Exps &quot;)&quot; &quot;;&quot;              [strict]
                | &quot;try&quot; Block &quot;catch&quot; &quot;(&quot; Id &quot;)&quot; Block
                | &quot;throw&quot; Exp &quot;;&quot;                       [strict]
                | &quot;join&quot; Exp &quot;;&quot;                        [strict]
                | &quot;acquire&quot; Exp &quot;;&quot;                     [strict]
                | &quot;release&quot; Exp &quot;;&quot;                     [strict]
                | &quot;rendezvous&quot; Exp &quot;;&quot;                  [strict]

  syntax Stmts ::= Stmt
                 | Stmts Stmts                          [right]
</code></pre>
<p>Old desugaring rules, from SIMPLE</p>
<pre><code class="language-k">  rule if (E) S =&gt; if (E) S else {}                                 [macro]
  rule for(Start Cond; Step) {S} =&gt; {Start while (Cond) {S Step;}}  [macro]
  rule var E1::Exp, E2::Exp, Es::Exps; =&gt; var E1; var E2, Es;       [macro-rec]
  rule var X::Id = E; =&gt; var X; X = E;                              [macro]
</code></pre>
<p>New desugaring rule</p>
<pre><code class="language-k">  rule class C:Id S =&gt; class C extends Object S                     // KOOL

endmodule
</code></pre>
<h3>Semantics</h3>
<p>We first discuss the new configuration of KOOL, which extends that of
SIMPLE.  Then we include the semantics of the constructs borrowed from
SIMPLE unchanged; we refrain from discussing those, because they were
already discussed in the <strong>K</strong> definition of SIMPLE.  Then we discuss
changes to SIMPLE's semantics needed for the more general meaning of
the previous SIMPLE constructs (for example for thread spawning,
assignment, etc.).  Finally, we discuss in detail the
semantics of the additional KOOL constructs.</p>
<pre><code class="language-k">module KOOL-UNTYPED
  imports KOOL-UNTYPED-SYNTAX
  imports DOMAINS
</code></pre>
<h3>Configuration</h3>
<p>KOOL removes one cell and adds two nested cells to the configuration
of SIMPLE.  The cell which is removed is the one holding the global
environment, because a KOOL program consists of a set of classes only,
with no global declarations.  In fact, since informally speaking each
KOOL class now includes a SIMPLE program, it is safe to say that the
global variables in SIMPLE became class fields in KOOL.  Let us now
discuss the new cells that are added to the configuration of SIMPLE.</p>
<ul>
<li>
<p>The cell <code>crntObj</code> holds data pertaining to the current
object, that is, the object environment in which the code in cell
<code>k</code> executes: <code>crntClass</code> holds the current class (which
can change as methods of the current object are invoked);
<code>envStack</code> holds the stack of environments as a list,
each layer corresponding to one class in the objects' instance class
hierarchy; <code>location</code>, which is optional, holds the location in
the store where the current object is or has to be located (this is
useful both for method closures and for the semantics of object
creation).</p>
</li>
<li>
<p>The cell <code>classes</code> holds all the declared classes, each
class being held in its own <code>class</code> cell which contains a name
(<code>className</code>), a parent (<code>extends</code>), and the actual
member declarations (<code>declarations</code>).</p>
</li>
</ul>
<pre><code class="language-k">  // the syntax declarations below are required because the sorts are
  // referenced directly by a production and, because of the way KIL to KORE
  // is implemented, the configuration syntax is not available yet
  // should simply work once KIL is removed completely
  // check other definitions for this hack as well
  syntax EnvCell
  syntax ControlCell
  syntax EnvStackCell
  syntax CrntObjCellFragment

  configuration &lt;T color=&quot;red&quot;&gt;
                  &lt;threads color=&quot;orange&quot;&gt;
                    &lt;thread multiplicity=&quot;*&quot; type=&quot;Set&quot; color=&quot;yellow&quot;&gt;
                      &lt;k color=&quot;green&quot;&gt; $PGM:Stmts ~&gt; execute &lt;/k&gt;
                    //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                      &lt;control color=&quot;cyan&quot;&gt;
                        &lt;fstack color=&quot;blue&quot;&gt; .List &lt;/fstack&gt;
                        &lt;xstack color=&quot;purple&quot;&gt; .List &lt;/xstack&gt;
                      //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                        &lt;crntObj color=&quot;Fuchsia&quot;&gt;  // KOOL
                           &lt;crntClass&gt; Object &lt;/crntClass&gt;
                           &lt;envStack&gt; .List &lt;/envStack&gt;
                           &lt;location multiplicity=&quot;?&quot;&gt; .K &lt;/location&gt;
                        &lt;/crntObj&gt;
                      &lt;/control&gt;
                    //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                      &lt;env color=&quot;violet&quot;&gt; .Map &lt;/env&gt;
                      &lt;holds color=&quot;black&quot;&gt; .Map &lt;/holds&gt;
                      &lt;id color=&quot;pink&quot;&gt; 0 &lt;/id&gt;
                    &lt;/thread&gt;
                  &lt;/threads&gt;
                //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                  &lt;store color=&quot;white&quot;&gt; .Map &lt;/store&gt;
                  &lt;busy color=&quot;cyan&quot;&gt;.Set &lt;/busy&gt;
                  &lt;terminated color=&quot;red&quot;&gt; .Set &lt;/terminated&gt;
                  &lt;input color=&quot;magenta&quot; stream=&quot;stdin&quot;&gt; .List &lt;/input&gt;
                  &lt;output color=&quot;brown&quot; stream=&quot;stdout&quot;&gt; .List &lt;/output&gt;
                  &lt;nextLoc color=&quot;gray&quot;&gt; 0 &lt;/nextLoc&gt;
                //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
                  &lt;classes color=&quot;Fuchsia&quot;&gt;        // KOOL
                     &lt;classData multiplicity=&quot;*&quot; type=&quot;Map&quot; color=&quot;Fuchsia&quot;&gt;
                        // the Map has as its key the first child of the cell,
                        // in this case the className cell.
                        &lt;className color=&quot;Fuchsia&quot;&gt; Main &lt;/className&gt;
                        &lt;baseClass color=&quot;Fuchsia&quot;&gt; Object &lt;/baseClass&gt;
                        &lt;declarations color=&quot;Fuchsia&quot;&gt; .K &lt;/declarations&gt;
                     &lt;/classData&gt;
                  &lt;/classes&gt;
                &lt;/T&gt;
</code></pre>
<h3>Unchanged Semantics from untyped SIMPLE</h3>
<p>The semantics below is taken over from SIMPLE unchanged.
The semantics of function declaration and invocation, including the
use of the special <code>lambda</code> abstraction value, needs to change
in order to account for the fact that methods are now invoked into
their object's environment.  The semantics of function return actually
stays unchanged.  Also, the semantics of program initialization is
different: now we have to create an instance of the <code>Main</code>
class which also calls the constructor <code>Main()</code>, while in
SIMPLE we only had to invoke the function <code>Main()</code>.
Finally, the semantics of thread spawning needs to change, too: the
parent thread needs to also share its object environment with the
spawned thread (in addition to its local environment, like in SIMPLE).
This is needed in order to be able to spawn method invokations under
dynamic method dispatch; for example, <code>spawn { run(); }</code>
will need to look up the method <code>run()</code> in the newly created
thread, operation which will most likely fail unless the child thread
sees the object environment of the parent thread.  Note that the
<code>spawn</code> statement of KOOL is more permissive than the threads
of Java.  In fact, the latter can be implemented in terms of our
<code>spawn</code>—see the program <code>threads.kool</code> for a sketch.</p>
<p>Below is a subset of the values of SIMPLE, which are also values
of KOOL.  We will add other values later in the semantics, such as
object and method closures.</p>
<pre><code class="language-k">  syntax Val ::= Int | Bool | String
               | array(Int,Int)
  syntax Exp ::= Val
  syntax Exps ::= Vals
  syntax KResult ::= Val
  syntax KResult ::= Vals
</code></pre>
<p>The semantics below are taken verbatim from the untyped SIMPLE
definition.</p>
<pre><code class="language-k">  syntax KItem ::= &quot;undefined&quot;  [latex(\bot)]

  rule &lt;k&gt; var X:Id; =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; Env[X &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; undefined ...&lt;/store&gt;
       &lt;nextLoc&gt; L:Int =&gt; L +Int 1 &lt;/nextLoc&gt;


  context var _:Id[HOLE];

  rule &lt;k&gt; var X:Id[N:Int]; =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; Env[X &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; array(L +Int 1, N)
                          (L +Int 1) ... (L +Int N) |-&gt; undefined ...&lt;/store&gt;
       &lt;nextLoc&gt; L:Int =&gt; L +Int 1 +Int N &lt;/nextLoc&gt;
    when N &gt;=Int 0


  syntax Id ::= &quot;$1&quot; | &quot;$2&quot;
  rule var X:Id[N1:Int, N2:Int, Vs:Vals];
    =&gt; var X[N1];
       {
         var $1=X;
         for(var $2=0; $2 &lt;= N1 - 1; ++$2) {
           var X[N2,Vs];
           $1[$2] = X;
         }
       }
    [structural]


  rule &lt;k&gt; X:Id =&gt; V ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]


  context ++(HOLE =&gt; lvalue(HOLE))
  rule &lt;k&gt; ++loc(L) =&gt; I +Int 1 ...&lt;/k&gt;
       &lt;store&gt;... L |-&gt; (I:Int =&gt; I +Int 1) ...&lt;/store&gt;  [increment]


  rule I1 + I2 =&gt; I1 +Int I2
  rule Str1 + Str2 =&gt; Str1 +String Str2
  rule I1 - I2 =&gt; I1 -Int I2
  rule I1 * I2 =&gt; I1 *Int I2
  rule I1 / I2 =&gt; I1 /Int I2 when I2 =/=K 0
  rule I1 % I2 =&gt; I1 %Int I2 when I2 =/=K 0
  rule - I =&gt; 0 -Int I
  rule I1 &lt; I2 =&gt; I1 &lt;Int I2
  rule I1 &lt;= I2 =&gt; I1 &lt;=Int I2
  rule I1 &gt; I2 =&gt; I1 &gt;Int I2
  rule I1 &gt;= I2 =&gt; I1 &gt;=Int I2

  rule V1:Val == V2:Val =&gt; V1 ==K V2
  rule V1:Val != V2:Val =&gt; V1 =/=K V2
  rule ! T =&gt; notBool(T)
  rule true  &amp;&amp; E =&gt; E
  rule false &amp;&amp; _ =&gt; false
  rule true  || _ =&gt; true
  rule false || E =&gt; E


  rule V:Val[N1:Int, N2:Int, Vs:Vals] =&gt; V[N1][N2, Vs]
    [structural, anywhere]

  rule array(L,_)[N:Int] =&gt; lookup(L +Int N)
    [structural, anywhere]


  rule sizeOf(array(_,N)) =&gt; N
</code></pre>
<p>The semantics of function application needs to change into dynamic
method dispatch invocation, which is defined shortly.  However,
interestingly, the semantics of return stays unchanged.</p>
<pre><code class="language-k">  rule &lt;k&gt; return(V:Val); ~&gt; _ =&gt; V ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;fstack&gt; ListItem(fstackFrame(Env,K,XS,&lt;crntObj&gt; CO &lt;/crntObj&gt;)) =&gt; .List ...&lt;/fstack&gt;
         &lt;xstack&gt; _ =&gt; XS &lt;/xstack&gt;
         &lt;crntObj&gt; _ =&gt; CO &lt;/crntObj&gt;
       &lt;/control&gt;
       &lt;env&gt; _ =&gt; Env &lt;/env&gt;

  syntax Val ::= &quot;nothing&quot;
  rule return; =&gt; return nothing;   [macro]


  rule &lt;k&gt; read() =&gt; I ...&lt;/k&gt; &lt;input&gt; ListItem(I:Int) =&gt; .List ...&lt;/input&gt;  [read]


  context (HOLE =&gt; lvalue(HOLE)) = _

  rule &lt;k&gt; loc(L) = V:Val =&gt; V ...&lt;/k&gt; &lt;store&gt;... L |-&gt; (_ =&gt; V) ...&lt;/store&gt;
    [assignment]


  rule {} =&gt; .  [structural]
  rule &lt;k&gt; { S } =&gt; S ~&gt; setEnv(Env) ...&lt;/k&gt;  &lt;env&gt; Env &lt;/env&gt;  [structural]


  rule S1::Stmts S2::Stmts =&gt; S1 ~&gt; S2  [structural]

  rule _:Val; =&gt; .

  rule if ( true) S else _ =&gt; S
  rule if (false) _ else S =&gt; S

  rule while (E) S =&gt; if (E) {S while(E)S}  [structural]

  rule &lt;k&gt; print(V:Val, Es =&gt; Es); ...&lt;/k&gt; &lt;output&gt;... .List =&gt; ListItem(V) &lt;/output&gt;
    [print]
  rule print(.Vals); =&gt; .  [structural]


  syntax KItem ::= xstackFrame(Id,Stmt,K,Map,K)
  // TODO(KORE): drop the additional production once parsing issue #1842 is fixed
                 | (Id,Stmt,K,Map,K)

  syntax KItem ::= &quot;popx&quot;

  rule &lt;k&gt; (try S1 catch(X) {S2} =&gt; S1 ~&gt; popx) ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;xstack&gt; .List =&gt; ListItem(xstackFrame(X, S2, K, Env, C)) ...&lt;/xstack&gt;
         C
       &lt;/control&gt;
       &lt;env&gt; Env &lt;/env&gt;

  rule &lt;k&gt; popx =&gt; . ...&lt;/k&gt;
       &lt;xstack&gt; ListItem(_) =&gt; .List ...&lt;/xstack&gt;

  rule &lt;k&gt; throw V:Val; ~&gt; _ =&gt; { var X = V; S2 } ~&gt; K &lt;/k&gt;
       &lt;control&gt;
         &lt;xstack&gt; ListItem(xstackFrame(X, S2, K, Env, C)) =&gt; .List ...&lt;/xstack&gt;
         (_ =&gt; C)
       &lt;/control&gt;
       &lt;env&gt; _ =&gt; Env &lt;/env&gt;
</code></pre>
<p>Thread spawning needs a new semantics, because we want the child
thread to also share the object environment with its parent.  The new
semantics of thread spawning will be defined shortly.  However,
interestingly, the other concurrency constructs keep their semantics
from SIMPLE unchanged.</p>
<pre><code class="language-k">  // TODO(KORE): ..Bag should be . throughout this definition #1772
  rule (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .Bag)
  /*
  rule (&lt;thread&gt;... &lt;k&gt;.&lt;/k&gt; &lt;holds&gt;H&lt;/holds&gt; &lt;id&gt;T&lt;/id&gt; ...&lt;/thread&gt; =&gt; .)
  */
       &lt;busy&gt; Busy =&gt; Busy -Set keys(H) &lt;/busy&gt;
       &lt;terminated&gt;... .Set =&gt; SetItem(T) ...&lt;/terminated&gt;

  rule &lt;k&gt; join T:Int; =&gt; . ...&lt;/k&gt;
       &lt;terminated&gt;... SetItem(T) ...&lt;/terminated&gt;

  rule &lt;k&gt; acquire V:Val; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... .Map =&gt; V |-&gt; 0 ...&lt;/holds&gt;
       &lt;busy&gt; Busy (.Set =&gt; SetItem(V)) &lt;/busy&gt;
    when (notBool(V in Busy:Set))  [acquire]

  rule &lt;k&gt; acquire V; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... V:Val |-&gt; (N:Int =&gt; N +Int 1) ...&lt;/holds&gt;

  rule &lt;k&gt; release V:Val; =&gt; . ...&lt;/k&gt;
       &lt;holds&gt;... V |-&gt; (N =&gt; N:Int -Int 1) ...&lt;/holds&gt;
    when N &gt;Int 0

  rule &lt;k&gt; release V; =&gt; . ...&lt;/k&gt; &lt;holds&gt;... V:Val |-&gt; 0 =&gt; .Map ...&lt;/holds&gt;
       &lt;busy&gt;... SetItem(V) =&gt; .Set ...&lt;/busy&gt;

  rule &lt;k&gt; rendezvous V:Val; =&gt; . ...&lt;/k&gt;
       &lt;k&gt; rendezvous V; =&gt; . ...&lt;/k&gt;  [rendezvous]
</code></pre>
<h3>Unchanged auxiliary operations from untyped SIMPLE</h3>
<pre><code class="language-k">  syntax Stmts ::= mkDecls(Ids,Vals)  [function]
  rule mkDecls((X:Id, Xs:Ids), (V:Val, Vs:Vals)) =&gt; var X=V; mkDecls(Xs,Vs)
  rule mkDecls(.Ids,.Vals) =&gt; {}

  // TODO(KORE): clarify sort inferences #1803
  syntax Exp ::= lookup(Int)
  /*
  syntax KItem ::= lookup(Int)
  */
  rule &lt;k&gt; lookup(L) =&gt; V ...&lt;/k&gt; &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]

  syntax KItem ::= setEnv(Map)
  rule &lt;k&gt; setEnv(Env) =&gt; . ...&lt;/k&gt;  &lt;env&gt; _ =&gt; Env &lt;/env&gt;  [structural]
  rule (setEnv(_) =&gt; .) ~&gt; setEnv(_)  [structural]
  // TODO: How can we make sure that the second rule above applies before the first one?
  //       Probably we'll deal with this using strategies, eventually.

  syntax Exp ::= lvalue(K)
  syntax Val ::= loc(Int)

  rule &lt;k&gt; lvalue(X:Id =&gt; loc(L)) ...&lt;/k&gt; &lt;env&gt;... X |-&gt; L:Int ...&lt;/env&gt;
    [structural]

  context lvalue(_::Exp[HOLE::Exps])
  context lvalue(HOLE::Exp[_::Exps])

  rule lvalue(lookup(L:Int) =&gt; loc(L))  [structural]


  syntax Map ::= Int &quot;...&quot; Int &quot;|-&gt;&quot; K
    [function, latex({#1}\ldots{#2}\mapsto{#3})]
  rule N...M |-&gt; _ =&gt; .Map  when N &gt;Int M
  rule N...M |-&gt; K =&gt; N |-&gt; K (N +Int 1)...M |-&gt; K  when N &lt;=Int M
</code></pre>
<h3>Changes to the existing untyped SIMPLE semantics</h3>
<p>When we extend a language, sometimes we need to do more than just add
new language constructs and semantics for them.  Sometimes we want to
also extend the semantics of existing language constructs, in order to
get more from them.</p>
<h3>Program initialization</h3>
<p>In SIMPLE, once all the global declarations were processed, the
function <code>main()</code> was invoked.  In KOOL, the global
declarations are classes, and their specific semantics is given
shortly; essentially, they are pre-processed one by one and added
into the <code>class</code> cell structure in the configuration.
Once all the classes are processed, the computation item
<code>execute</code>, which was placed right after the program in the
initial configuration, is reached.  In SIMPLE, the program was
initialized by calling the method <code>main()</code>.  In KOOL, the
program is initialized by creating an object instance of class
<code>Main</code>.  This will also implicitly call the method
<code>Main()</code> (the <code>Main</code> class constructor).  The emptiness
of the <code>env</code> cell below is just a sanity check, to make sure
that the user has not declared anything but classes at the top level
of the program.</p>
<pre><code class="language-k">  syntax KItem ::= &quot;execute&quot;
  rule &lt;k&gt; execute =&gt; new Main(.Exps); &lt;/k&gt; &lt;env&gt; .Map &lt;/env&gt;  [structural]
</code></pre>
<p>The semantics of <code>new</code> (defined below) requires the
execution of all the class' declarations (and also of its
superclasses').</p>
<h3>Object and method closures</h3>
<p>Before we can define the semantics of method application (previously
called function application in SIMPLE), we need to add two more values
to the language, namely object and method closures:</p>
<pre><code class="language-k">  syntax Val ::= objectClosure(Id, List)
               | methodClosure(Id,Int,Ids,Stmt)
</code></pre>
<p>An object value consists of an <code>objectClosure</code>-wrapped bag
containing the current class of the object and the environment stack
of the object.  The current class of an object will always be one of
the classes mapped to an environment in the environment stack of the
object.  A method closure encapsulates the method's parameters and
code (last two arguments), as well as the object context in which the
method code should execute.  This object context includes the current
class of the object (the first argument of <code>methodClosure</code>) and
the object environment stack (located in the object stored at the
location specified as the second argument of <code>methodClosure</code>).</p>
<h3>Method application</h3>
<p>KOOL has a complex mechanism to invoke methods, because it allows both
dynamic method dispatch and methods as first-class-citizen values (the
latter making it a higher-order language).  The invocation mechanism
will be defined later.  What is sufficient to know for now is that
the two arguments of the application construct eventually reduce to
values, the first being a method closure and the latter a list of
values.  The semantics of the method closure application is then as
expected: the local environment and control are stacked, then we
switch to method closure's class and object environment and execute
the method body.  The <code>mkDecls</code> construct is the one that came
with the unchanged semantics of SIMPLE above.</p>
<pre><code class="language-k">  syntax KItem ::= fstackFrame(Map,K,List,K)
  // TODO(KORE): drop the additional production once parsing issue #1842 is fixed
                 | (Map,K,K)

  rule &lt;k&gt; methodClosure(Class,OL,Xs,S)(Vs:Vals) ~&gt; K
           =&gt; mkDecls(Xs,Vs) S return; &lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;store&gt;... OL |-&gt; objectClosure(_, EnvStack)...&lt;/store&gt;
     //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
       &lt;control&gt;
          &lt;xstack&gt; XS &lt;/xstack&gt;
          &lt;fstack&gt; .List =&gt; ListItem(fstackFrame(Env, K, XS, &lt;crntObj&gt; Obj' &lt;/crntObj&gt;))
          ...&lt;/fstack&gt;
          &lt;crntObj&gt; Obj' =&gt; &lt;crntClass&gt; Class &lt;/crntClass&gt; &lt;envStack&gt; EnvStack &lt;/envStack&gt; &lt;/crntObj&gt;
       &lt;/control&gt;
</code></pre>
<h3>Spawn</h3>
<p>We want to extend the semantics of <code>spawn</code> to also share the
current object environment with the child thread, in addition to the
current environment.  This extension will allow us to also use method
invocations in the spawned statements, which will be thus looked up as
expected, using dynamic method dispatch.  This lookup operation would
fail if the child thread did not have access to its parent's object
environment.</p>
<pre><code class="language-k">  rule &lt;thread&gt;...
         &lt;k&gt; spawn S =&gt; !T:Int ...&lt;/k&gt;
         &lt;env&gt; Env &lt;/env&gt;
         &lt;crntObj&gt; Obj &lt;/crntObj&gt;
       ...&lt;/thread&gt;
       (.Bag =&gt; &lt;thread&gt;...
               &lt;k&gt; S &lt;/k&gt;
               &lt;env&gt; Env &lt;/env&gt;
               &lt;id&gt; !T &lt;/id&gt;
               &lt;crntObj&gt; Obj &lt;/crntObj&gt;
             ...&lt;/thread&gt;)
</code></pre>
<h3>Semantics of the new KOOL constructs</h3>
<h3>Class declaration</h3>
<p>Initially, the classes forming the program are moved into their
corresponding cells:</p>
<pre><code class="language-k">  rule &lt;k&gt; class Class1 extends Class2 { S } =&gt; . ...&lt;/k&gt;
       &lt;classes&gt;... (.Bag =&gt; &lt;classData&gt;
                            &lt;className&gt; Class1 &lt;/className&gt;
                            &lt;baseClass&gt; Class2 &lt;/baseClass&gt;
                            &lt;declarations&gt; S &lt;/declarations&gt;
                        &lt;/classData&gt;)
       ...&lt;/classes&gt;  [structural]
</code></pre>
<h3>Method declaration</h3>
<p>Like in SIMPLE, method names are added to the environment and bound
to their code.  However, unlike in SIMPLE where each function was
executed in the same environment, namely the program global
environment, a method in KOOL needs to be executed into its object's
environment.  Thus, methods evaluate to closures, which encapsulate
their object's context (i.e., the current class and environment stack
of the object) in addition to method's parameters and body.  This
approach to bind method names to method closures in the environment
will also allow objects to pass their methods to other objects, to
dynamically change their methods by assigning them other method
closures, and even to allow all these to be done from other objects.
This gives the KOOL programmer a lot of power; one should use this
power wisely, though, because programs can become easily hard to
understand and reason about if one overuses these features.</p>
<pre><code class="language-k">  rule &lt;k&gt; method F:Id(Xs:Ids) S =&gt; . ...&lt;/k&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;location&gt; OL:Int &lt;/location&gt;
       &lt;env&gt; Env =&gt; Env[F &lt;- L] &lt;/env&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; methodClosure(Class,OL,Xs,S) ...&lt;/store&gt;
       &lt;nextLoc&gt; L =&gt; L +Int 1 &lt;/nextLoc&gt;
</code></pre>
<h3>New</h3>
<p>The semantics of <code>new</code> consists of two actions: memory
allocation for the new object and execution of the corresponding
constructor.  Then the created object is returned as the result of the
<code>new</code> operation; the value returned by the constructor, if any,
is discarded.  The current environment and object are stored onto the
stack and recovered after new (according to the semantics of
<code>return</code> borrowed from SIMPLE, when the statement
<code>return this;</code> in the rule below is reached and evaluated),
because the object creation part of <code>new</code> will destroy them.
The rule below also initializes the object creation process by
emptying the local environment and the current object, and allocating
a location in the store where the created object will be eventually
stored (this is what the <code>storeObj</code> task after the object
creation task in the rule below will do—its rule is defined
shortly).  The location where the object will be stored is also made
available in the <code>crntObj</code> cell, so that method closures can
refer to it (see rule above).</p>
<pre><code class="language-k">  syntax KItem ::= &quot;envStackFrame&quot; &quot;(&quot; Id &quot;,&quot; Map &quot;)&quot;

  rule &lt;k&gt; new Class:Id(Vs:Vals) ~&gt; K
           =&gt; create(Class) ~&gt; storeObj ~&gt; Class(Vs); return this; &lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;nextLoc&gt; L:Int =&gt; L +Int 1 &lt;/nextLoc&gt;
     //&lt;br/&gt; // TODO(KORE): support latex annotations #1799
       &lt;control&gt; &lt;xstack&gt; XS &lt;/xstack&gt;
         &lt;crntObj&gt; Obj
                   =&gt; &lt;crntClass&gt; Object &lt;/crntClass&gt;
                      &lt;envStack&gt; ListItem(envStackFrame(Object, .Map)) &lt;/envStack&gt;
                      &lt;location&gt; L &lt;/location&gt;
         &lt;/crntObj&gt;
         &lt;fstack&gt; .List =&gt; ListItem(fstackFrame(Env, K, XS, &lt;crntObj&gt; Obj &lt;/crntObj&gt;)) ...&lt;/fstack&gt;
       &lt;/control&gt;
</code></pre>
<p>The creation of a new object (the memory allocation part only) is
a recursive process, requiring to first create an object for the
superclass.  A memory object representation is a layered structure:
for each class on the path from the instance class to the root of the
hierarchy there is a layer including the memory allocated for the
members (both fields and methods) of that class.</p>
<pre><code class="language-k">  syntax KItem ::= create(Id)

  rule &lt;k&gt; create(Class:Id)
           =&gt; create(Class1) ~&gt; setCrntClass(Class) ~&gt; S ~&gt; addEnvLayer ...&lt;/k&gt;
       &lt;className&gt; Class &lt;/className&gt;
       &lt;baseClass&gt; Class1:Id &lt;/baseClass&gt;
       &lt;declarations&gt; S &lt;/declarations&gt;  [structural]

  rule &lt;k&gt; create(Object) =&gt; . ...&lt;/k&gt;  [structural]
</code></pre>
<p>The next operation sets the current class of the current object.
This is necessary to be done at each layer, because the current class
of the object is enclosed as part of the method closures (see the
semantics of method declarations above).</p>
<pre><code class="language-k">  syntax KItem ::= setCrntClass(Id)

  rule &lt;k&gt; setCrntClass(C) =&gt; . ...&lt;/k&gt;
       &lt;crntClass&gt; _ =&gt; C &lt;/crntClass&gt;  [structural]
</code></pre>
<p>The next operation adds a new tagged environment layer to the
current object and gets ready for the next layer by clearing the
environment (note that <code>create</code> expects the environment to be
empty).</p>
<pre><code class="language-k">  syntax KItem ::= &quot;addEnvLayer&quot;

  rule &lt;k&gt; addEnvLayer =&gt; . ...&lt;/k&gt;
       &lt;env&gt; Env =&gt; .Map &lt;/env&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; .List =&gt; ListItem(envStackFrame(Class, Env)) ...&lt;/envStack&gt;
    [structural]
</code></pre>
<p>The following operation stores the created object at the location
reserved by <code>new</code>.  Note that the location reserved by
<code>new</code> was temporarily stored in the <code>crntObj</code> cell
precisely for this purpose.  Now that the newly created object is
stored at its location and that all method closures are aware of it,
the location is unnecessary and thus we delete it from the
<code>crntObj</code> cell.</p>
<pre><code class="language-k">  syntax KItem ::= &quot;storeObj&quot;

  rule &lt;k&gt; storeObj =&gt; . ...&lt;/k&gt;
       &lt;crntObj&gt; &lt;crntClass&gt; CC &lt;/crntClass&gt; &lt;envStack&gt; ES &lt;/envStack&gt; (&lt;location&gt; L:Int &lt;/location&gt; =&gt; .Bag) &lt;/crntObj&gt;
       &lt;store&gt;... .Map =&gt; L |-&gt; objectClosure(CC, ES) ...&lt;/store&gt;
</code></pre>
<h3>Self reference</h3>
<p>The semantics of <code>this</code> is straightforward: evaluate to the
current object.</p>
<pre><code class="language-k">  rule &lt;k&gt; this =&gt; objectClosure(CC, ES) ...&lt;/k&gt;
       &lt;crntObj&gt; &lt;crntClass&gt; CC &lt;/crntClass&gt; &lt;envStack&gt; ES &lt;/envStack&gt; &lt;/crntObj&gt;
</code></pre>
<h3>Object member access</h3>
<p>We can access an object member (field or method) either explicitly,
using the construct <code>e.x</code>, or implicitly, using only the member
name <code>x</code> directly.  The borrowed semantics of SIMPLE will
already lookup a sole name in the local environment.  The first rule
below reduces implicit member access to explicit access when the name
cannot be found in the local environment.  There are two cases to
analyze for explicit object member access, depending upon whether the
object is a proper object or it is just a redirection to the parent
class via the construct <code>super</code>.  In the first case, we
evaluate the object expression and lookup the member starting with the
current class (static scoping).  Note the use of the conditional
evaluation context.  In the second case, we just lookup the member
starting with the superclass of the current class.  In both cases,
the <code>lookupMember</code> task eventually yields a <code>lookup(L)</code>
task for some appropriate location <code>L</code>, which will be further
solved with the corresponding rule borrowed from SIMPLE.  Note that the
current object is not altered by <code>super</code>, so future method
invocations see the entire object, as needed for dynamic method dispatch.</p>
<pre><code class="language-k">  rule &lt;k&gt; X:Id =&gt; this . X ...&lt;/k&gt; &lt;env&gt; Env:Map &lt;/env&gt;
    when notBool(X in keys(Env))  [structural]

  context HOLE._::Id when (HOLE =/=K super)

// TODO: explain how Assoc matching has been replaced with two rules here.
// Maybe also improve it a bit.

/*  rule objectClosure(&lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
                     &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt;)
       . X:Id
    =&gt; lookupMember(envStackFrame(Class,EnvC) EStack, X)
    [structural]*/

  rule objectClosure(Class:Id, ListItem(envStackFrame(Class,Env)) EStack)
       . X:Id
    =&gt; lookupMember(ListItem(envStackFrame(Class,Env)) EStack, X)
    [structural]
  rule objectClosure(Class:Id, (ListItem(envStackFrame(Class':Id,_)) =&gt; .List) _)
       . X:Id
    when Class =/=K Class'  [structural]

/*  rule &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,EnvC) EStack &lt;/envStack&gt;
    [structural]*/
  rule &lt;k&gt; super . X =&gt; lookupMember(EStack, X) ...&lt;/k&gt;
       &lt;crntClass&gt; Class:Id &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class,_)) EStack &lt;/envStack&gt;
    [structural]
  rule &lt;k&gt; super . X ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class':Id,_)) =&gt; .List ...&lt;/envStack&gt;
    when Class =/=K Class'  [structural]
</code></pre>
<h3>Method invocation</h3>
<p>Unlike in SIMPLE, in KOOL application was declared strict only in its
second argument.  That is because we want to ensure dynamic method
dispatch when the first argument is a method access.  As a
consequence, we need to consider all the cases of interest for the
first argument and to explicitly say what to do in each case.  In all
cases except for method access in a proper object (i.e., not
<code>super</code>), we want the same behavior for the first argument as
if it was not in a method invocation position.  When it is a member
access (the third rule below), we look it up starting with the
instance class of the corresponding object.  This ensures dynamic
dispatch for methods; it actually dynamically dispatches field
accesses, too, which is correct in KOOL, because one can assign method
closures to fields and the field appeared in a method invocation
context.  The last context declaration below says that method
applications or array accesses are also allowed as first argument to
applications; that is because methods are allowed to return methods
and arrays are allowed to hold methods in KOOL, since it is
higher-order.  If that is the case, then we want to evaluate the
method call or the array access.</p>
<pre><code class="language-k">  rule &lt;k&gt; (X:Id =&gt; V)(_:Exps) ...&lt;/k&gt;
       &lt;env&gt;... X |-&gt; L ...&lt;/env&gt;
       &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;  [lookup]

  rule &lt;k&gt; (X:Id =&gt; this . X)(_:Exps) ...&lt;/k&gt;
       &lt;env&gt; Env &lt;/env&gt;
    when notBool(X in keys(Env))  [structural]

  context HOLE._::Id(_) when HOLE =/=K super

  rule (objectClosure(_, EStack) . X
    =&gt; lookupMember(EStack, X:Id))(_:Exps)  [structural]

/*  rule &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt;... envStackFrame(Class,_) EStack &lt;/envStack&gt;
    [structural]*/
  rule &lt;k&gt; (super . X
            =&gt; lookupMember(EStack,X))(_:Exps)...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class,_)) EStack &lt;/envStack&gt;
    [structural]
  rule &lt;k&gt; (super . X)(_:Exps) ...&lt;/k&gt;
       &lt;crntClass&gt; Class &lt;/crntClass&gt;
       &lt;envStack&gt; ListItem(envStackFrame(Class':Id,_)) =&gt; .List ...&lt;/envStack&gt;
    when Class =/=K Class'  [structural]

  // TODO(KORE): fix getKLabel #1801
  rule (A:Exp(B:Exps))(C:Exps) =&gt; A(B) ~&gt; #freezerFunCall(C)
  rule (A:Exp[B:Exps])(C:Exps) =&gt; A[B] ~&gt; #freezerFunCall(C)
  rule V:Val ~&gt; #freezerFunCall(C:Exps) =&gt; V(C)
  syntax KItem ::= &quot;#freezerFunCall&quot; &quot;(&quot; K &quot;)&quot;
  /*
  context HOLE(_:Exps)
    when getKLabel(HOLE) ==K #klabel(`_(_)`) orBool getKLabel(HOLE) ==K #klabel(`_[_]`)
  */
</code></pre>
<p>Eventually, each of the rules above produces a <code>lookup(L)</code>
task as a replacement for the method.  When that happens, we just
lookup the value at location <code>L</code>:</p>
<pre><code class="language-k">  rule &lt;k&gt; (lookup(L) =&gt; V)(_:Exps) ...&lt;/k&gt;  &lt;store&gt;... L |-&gt; V:Val ...&lt;/store&gt;
    [lookup]
</code></pre>
<p>The value <code>V</code> looked up above is expected to be a method closure,
in which case the semantics of method application given above will
apply.  Otherwise, the execution will get stuck.</p>
<h3>Instance Of</h3>
<p>It searches the object environment for a layer corresponding to the
desired class.  It returns <code>true</code> iff it can find the class,
otherwise it returns <code>false</code>; it only gets stuck when its first
argument does not evaluate to an object.</p>
<pre><code class="language-k">  rule objectClosure(_, ListItem(envStackFrame(C,_)) _)
       instanceOf C =&gt; true

  rule objectClosure(_, (ListItem(envStackFrame(C,_)) =&gt; .List) _)
       instanceOf C'  when C =/=K C'  [structural]
//TODO: remove the sort cast ::Id of C above, when sort inference bug fixed

  rule objectClosure(_, .List) instanceOf _ =&gt; false
</code></pre>
<h3>Cast</h3>
<p>In untyped KOOL, we prefer to not check the validity of casting.  In
other words, any cast is allowed on any object, simply changing the
current class of the object to the desired class.  The execution will
get stuck later if one attempts to access a field which is not
available.  Moreover, the execution may complete successfully even
in the presence of invalid casts, provided that each accessed member
during the current execution is, or happens to be, available.</p>
<pre><code class="language-k">  rule (C) objectClosure(_ , EnvStack) =&gt; objectClosure(C ,EnvStack)
</code></pre>
<h3>KOOL-specific auxiliary declarations and operations</h3>
<p>Here we define all the auxiliary constructs used in the above
KOOL-specific semantics (those used in the SIMPLE fragment
have already been defined in a corresponding section above).</p>
<h3>Objects as lvalues</h3>
<p>The current machinery borrowed with the semantics of SIMPLE allows us
to enrich the set of lvalues, this way allowing new means to assign
values to locations.  In KOOL, we want object member names to be
lvalues, so that we can assign values to them using the already
existing machinery.  The first rule below ensures that the object is
always explicit, the evaluation context enforces the object to be
evaluated, and finally the second rule initiates the lookup for the
member's location based on the current class of the object.</p>
<pre><code class="language-k">  rule &lt;k&gt; lvalue(X:Id =&gt; this . X) ...&lt;/k&gt;  &lt;env&gt; Env &lt;/env&gt;
    when notBool(X in keys(Env))  [structural]

  context lvalue((HOLE . _)::Exp)

/*  rule lvalue(objectClosure(&lt;crntClass&gt; C &lt;/crntClass&gt;
                            &lt;envStack&gt;... envStackFrame(C,EnvC) EStack &lt;/envStack&gt;)
              . X
              =&gt; lookupMember(&lt;envStack&gt; envStackFrame(C,EnvC) EStack &lt;/envStack&gt;,
                              X))  [structural]*/
  rule lvalue(objectClosure(Class, ListItem(envStackFrame(Class,Env)) EStack)
              . X
              =&gt; lookupMember(ListItem(envStackFrame(Class,Env)) EStack,
                              X))  [structural]
  rule lvalue(objectClosure(Class, (ListItem(envStackFrame(Class':Id,_)) =&gt; .List) _)
              . X)
    when Class =/=K Class'  [structural]
</code></pre>
<h3>Lookup member</h3>
<p>It searches for the given member in the given environment stack,
starting with the most concrete class and going up in the hierarchy.</p>
<pre><code class="language-k">  // TODO(KORE): clarify sort inferences #1803
  syntax Exp ::= lookupMember(List, Id)  [function]
  /*
  syntax KItem ::= lookupMember(EnvStackCell,Id)  [function]
  */

//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt;... X|-&gt;L ...&lt;/env&gt;) ...&lt;/envStack&gt;, X)
//    =&gt; lookup(L)
  rule lookupMember(ListItem(envStackFrame(_, X|-&gt;L _)) _, X)
    =&gt; lookup(L)

//  rule lookupMember(&lt;envStack&gt; envStackFrame(_, &lt;env&gt; Env &lt;/env&gt;) =&gt; .List ...&lt;/envStack&gt;, X)
//    when notBool(X in keys(Env))
  rule lookupMember(ListItem(envStackFrame(_, Env)) Rest, X) =&gt;
       lookupMember(Rest, X)
    when notBool(X in keys(Env))
//TODO: beautify the above

endmodule
</code></pre>
<p>Go to <a href="../2_typed/1_dynamic/kool-typed-dynamic.md">Lesson 2, KOOL typed dynamic</a>.</p>

          </div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../assets/js/index.js"></script>
    <script>
      $(function () {
        // Set header
        const headerSelector =
          ".markdown-preview h1, .markdown-preview h2, .markdown-preview h3";
        if ($(headerSelector).length) {
          if ($(headerSelector)[0].innerText.match(/^copyright/)) {
            $(headerSelector)[0].remove();
          }
          if ($(headerSelector).length) {
            const title = $(headerSelector)[0].innerText;
            $(".title").text(title);
            $(headerSelector)[0].remove();
          }
        }

        const anchorElements = document.querySelectorAll(".markdown-preview a");
        for (let i = 0; i < anchorElements.length; i++) {
          if (i > 3) {
            break;
          }
          const anchorElement = anchorElements[i];
          const href = anchorElement.getAttribute("href");
          if (href.match(/^https?:\/\/youtu.be\//)) {
            const match = href.match(/^https?:\/\/youtu.be\/(.+?)$/);
            if (match && match[1]) {
              const youtubeId = match[1];
              const $iframe = $(`<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/${youtubeId}"
  frameborder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
  style="max-width: 100%;"
></iframe>`);
              $(".markdown-preview a")[0].replaceWith($iframe[0]);
            }
          } else if (anchorElement.innerText.match(/Try it online/i)) {
            anchorElement.remove();
            document
              .getElementById("try-it-online-link")
              .setAttribute("href", href);
          }
        }
        if (
          !document.getElementById("try-it-online-link").getAttribute("href")
        ) {
          document.getElementById("try-it-online-link").remove();
        }
      });
    </script>
  </body>
</html>
