<!DOCTYPE html>
<html lang="en">
  <head>
    {{include/head.html}}
  </head>

  <body>
    {{include/header.html}}

    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
        {{include/sidebar.html}}
        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <h1>Lesson 1, LAMBDA: Syntax Modules and Basic K Commands</h1>
          <p>Go back to <a href="{{$ROOT}}/tutorials.html">K Tutorial.</a></p>
          <p>
            <a
              href="https://github.com/kframework/k/tree/master/k-distribution/tutorial/1_k/1_lambda/lesson_1"
              >All files</a
            >
            in the K tool distribution that were used in this movie.
          </p>
          <iframe
            width="560"
            height="315"
            src="https://www.youtube.com/embed/y5Tf1EZVj8E"
            frameborder="0"
            allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen
            style="max-width: 100%;"
          ></iframe>
          <p>
            <a
              href="https://kframework.org/tool/run/?autoload=tutorial/1_k/1_lambda/lesson_1/lambda.k"
              target="_blank"
              rel="noopener"
            >
              <img src="{{$ROOT}}/assets/img/try-it-online.jpg" /> Open Full
              Tool Page</a
            >
          </p>
          <div
            class="introduction"
            data-markdown="Here we define our first K module, which contains the initial syntax of the\nLAMBDA language, and learn how to use the basic K commands.\n\nLet us create an empty working folder, and open a terminal window\n(to the left) and an editor window (to the right).  We will edit our K\ndefinition in the right window in a file called `lambda.k`, and will call\nthe K tool commands in the left window.\n\nLet us start by defining a K module, containing the syntax of LAMBDA.\n\nK modules are introduced with the keywords `module` ... `endmodule`.\n\nThe keyword `syntax` adds new productions to the syntax grammar, using a\nBNF-like notation.\n\nTerminals are enclosed in double-quotes, like strings.\n\nYou can define multiple productions for the same non-terminal in the same\nsyntax declaration using the `|` separator.\n\nProductions can have attributes, which are enclosed in square brackets.\n\nThe attribute `left` tells the parser that we want the lambda application to be\nleft associative.  For example, `a b c d` will then parse as `(((a b) c) d)`.\n\nThe attribute `bracket` tells the parser to not generate a node for the\nparenthesis production in the abstract syntax trees associated to programs.\nIn other words, we want to allow parentheses to be used for grouping, but we\ndo not want to bother to give them their obvious (ignore) semantics.\n\nIn our variant of lambda calculus defined here, identifiers and lambda\nabstractions are meant to be irreducible, that is, are meant to be values.\nHowever, so far `Val` is just another non-terminal, just like `Exp`,\nwithout any semantic meaning.  It will get a semantic meaning later.\n\nAfter we are done typing our definition in the file `lambda.k`, we can kompile\nit with the command:\n\n    kompile lambda.k\n\nIf we get no errors then a parser has been generated.  This parser will be\ncalled from now on by default by the krun tool.  To see whether and how the\nparser works, we are going to write some LAMBDA programs and store them in\nfiles with the extension `.lambda`.\n\nLet us create a file `identity.lambda`, which contains the identity lambda\nabstraction:\n\n    lambda x . x\n\nNow let us call `krun` on `identity.lambda`:\n\n    krun identity.lambda\n\nMake sure you call the `krun` command from the folder containing your language\ndefinition (otherwise type `krun --help` to learn how to pass a language\ndefinition as a parameter to `krun`).  The krun command produces the output:\n\n    <k>\n      lambda x . x \n    </k>\n\nIf you see such an output it means that your program has been parsed (and then\npretty printed) correctly.  If you want to see the internal abstract syntax\ntree (AST) representation of the parsed program, which we call the K AST, then\ntype `kast` in the command instead of `krun`:\n\n    kast identity.lambda\n\nYou should normally never need to see this internal representation in your\nK definitions, so do not get scared (yes, it is ugly for humans, but it is\nvery convenient for tools).\n\nNote that `krun` placed the program in a `<k> ... </k>` cell.  In K, computations\nhappen only in cells.  If you do not define a configuration in your definition,\nlike we did here, then a configuration will be created automatically for you\nwhich contains only one cell, the default `k` cell, which holds the program.\n\nNext, let us create a file `free-variable-capture.lambda`, which contains an\nexpression which, in order to execute correctly in a substitution-based\nsemantics of LAMBDA, the substitution operation needs to avoid\nvariable-capture:\n\n    a (((lambda x.lambda y.x) y) z)\n\nNext, file `closed-variable-capture.lambda` shows an expression which also\nrequires a capture-free substitution, but this expression is closed (that is,\nit has no free variables) and all its bound variables are distinct (I believe\nthis is the smallest such expression):\n\n    (lambda z.(z z)) (lambda x.lambda y.(x y))\n\nFinally, the file `omega.lambda` contains the classic omega combinator\n(or closed expression), which is the smallest expression which loops forever\n(not now, but after we define the semantics of LAMBDA):\n\n    (lambda x.(x x)) (lambda x.(x x))\n\nFeel free to define and parse several other LAMBDA programs to get a feel for\nhow the parser works.  Parse also some incorrect programs, to see how the\nparser generates error messages.\n\nIn the next lesson we will see how to define semantic rules that iteratively\nrewrite expressions over the defined syntax until they evaluate to a result.\nThis way, we obtain our first programming language defined using K."
          ></div>
          <p>
            Go to
            <a href="">Lesson 2, LAMBDA: Module Importing, Rules, Variables</a>.
          </p>
        </main>
      </div>
    </div>
    {{include/footer.html}}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="{{$ROOT}}/assets/js/index.js"></script>
  </body>
</html>
